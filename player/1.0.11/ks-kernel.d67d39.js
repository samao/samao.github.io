(window.webpackJsonp_name_=window.webpackJsonp_name_||[]).push([[10],{217:function(module,exports,__webpack_require__){var factory;window,factory=function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}({"./node_modules/@ks/adaptive-multi-rate/lib/index.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n(function ($fog$262, $fog$0, $fog$1, $fog$2, $fog$3, $fog$4, $fog$5, $fog$6, $fog$7, $fog$8, $fog$9, $fog$10, $fog$11, $fog$12, $fog$13, $fog$14, $fog$15, $fog$16, $fog$17, $fog$18, $fog$19, $fog$20, $fog$21, $fog$22, $fog$23, $fog$24, $fog$25, $fog$26, $fog$27, $fog$28, $fog$29, $fog$30, $fog$31, $fog$32, $fog$33, $fog$34, $fog$35, $fog$36, $fog$37, $fog$38, $fog$39, $fog$40, $fog$41, $fog$42, $fog$43, $fog$44, $fog$45, $fog$46, $fog$47, $fog$48, $fog$49, $fog$50, $fog$51, $fog$52, $fog$53, $fog$54, $fog$55, $fog$56, $fog$57, $fog$58, $fog$59, $fog$60, $fog$61, $fog$62, $fog$63, $fog$64, $fog$65, $fog$66, $fog$67, $fog$68, $fog$69, $fog$70, $fog$71, $fog$72, $fog$73, $fog$74, $fog$75, $fog$76, $fog$77, $fog$78, $fog$79, $fog$80, $fog$81, $fog$82, $fog$83, $fog$84, $fog$85, $fog$86, $fog$87, $fog$88, $fog$89, $fog$90, $fog$91, $fog$92, $fog$93, $fog$94, $fog$95, $fog$96, $fog$97, $fog$98, $fog$99, $fog$100, $fog$101, $fog$102, $fog$103, $fog$104, $fog$105, $fog$106, $fog$107, $fog$108, $fog$109, $fog$110, $fog$111, $fog$112, $fog$113, $fog$114, $fog$115, $fog$116, $fog$117, $fog$118, $fog$119, $fog$120, $fog$121, $fog$122, $fog$123, $fog$124, $fog$125, $fog$126, $fog$127, $fog$128, $fog$129, $fog$130, $fog$131, $fog$132, $fog$133, $fog$134, $fog$135, $fog$136, $fog$137, $fog$138, $fog$139, $fog$140, $fog$141, $fog$142, $fog$143, $fog$144, $fog$145, $fog$146, $fog$147, $fog$148, $fog$149, $fog$150, $fog$151, $fog$152, $fog$153, $fog$154, $fog$155, $fog$156, $fog$157, $fog$158, $fog$159, $fog$160, $fog$161, $fog$162, $fog$163, $fog$164, $fog$165, $fog$166, $fog$167, $fog$168, $fog$169, $fog$170, $fog$171, $fog$172, $fog$173, $fog$174, $fog$175, $fog$176, $fog$177, $fog$178, $fog$179, $fog$180, $fog$181, $fog$182, $fog$183, $fog$184, $fog$185, $fog$186, $fog$187, $fog$188, $fog$189, $fog$190, $fog$191, $fog$192, $fog$193, $fog$194, $fog$195, $fog$196, $fog$197, $fog$198, $fog$199, $fog$200, $fog$201, $fog$202, $fog$203, $fog$204, $fog$205, $fog$206, $fog$207, $fog$208, $fog$209, $fog$210, $fog$211, $fog$212, $fog$213, $fog$214, $fog$215, $fog$216, $fog$217, $fog$218, $fog$219, $fog$220, $fog$221, $fog$222, $fog$223, $fog$224, $fog$225, $fog$226, $fog$227, $fog$228, $fog$229, $fog$230, $fog$231, $fog$232, $fog$233, $fog$234, $fog$235, $fog$236, $fog$237, $fog$238, $fog$239, $fog$240, $fog$241, $fog$242, $fog$243, $fog$244, $fog$245, $fog$246, $fog$247, $fog$248, $fog$249, $fog$250, $fog$251, $fog$252, $fog$253, $fog$254, $fog$255, $fog$256, $fog$257, $fog$258, $fog$259, $fog$260, $fog$261) {\n  \nif ("‮" !== $fog$262) {\n  return;\n}\n        \n  !function(e,t){$fog$0==typeof exports&&$fog$0==typeof module?module[$fog$1]=t():$fog$2=="function"&&__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")[$fog$3]?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):$fog$0==typeof exports?exports[$fog$4]=t():e[$fog$4]=t()}(window,function(){return function(e){var t={};function r(n){if(t[n])return t[n][$fog$1];var i=t[n]={i:n,l:!$fog$6,exports:{}};return e[n][$fog$7](i[$fog$1],i,i[$fog$1],r),i[$fog$8]=!$fog$9,i[$fog$1]}return r[$fog$10]=e,r[$fog$11]=t,r[$fog$12]=function(e,t,n){r[$fog$13](e,t)||Object[$fog$14](e,t,{enumerable:!$fog$9,get:n})},r[$fog$15]=function(e){$fog$16!=typeof Symbol&&Symbol[$fog$17]&&Object[$fog$14](e,Symbol[$fog$17],{value:$fog$18}),Object[$fog$14](e,$fog$19,{value:!$fog$9})},r[$fog$20]=function(e,t){if($fog$6&t&&(e=r(e)),$fog$21&t)return e;if($fog$22&t&&$fog$0==typeof e&&e&&e[$fog$19])return e;var n=Object[$fog$23]($fog$24);if(r[$fog$15](n),Object[$fog$14](n,$fog$5,{enumerable:!$fog$9,value:e}),$fog$25&t&&$fog$26!=typeof e)for(var i in e)r[$fog$12](n,i,function(t){return e[t]}[$fog$27]($fog$24,i));return n},r[$fog$28]=function(e){var t=e&&e[$fog$19]?function(){return e[$fog$5]}:function(){return e};return r[$fog$12](t,$fog$29,t),t},r[$fog$13]=function(e,t){return Object[$fog$31][$fog$30][$fog$7](e,t)},r[$fog$32]=$fog$33,r(r[$fog$34]=$fog$25)}([function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n=function(){function e(e,t){for(var r=$fog$9;r<t[$fog$35];r++){var n=t[r];n[$fog$36]=n[$fog$36]||!$fog$6,n[$fog$37]=!$fog$9,$fog$38 in n&&(n[$fog$39]=!$fog$9),Object[$fog$14](e,n[$fog$40],n)}}return function(t,r,n){return r&&e(t[$fog$31],r),n&&e(t,n),t}}(),i=$fog$2==typeof Symbol&&$fog$41==typeof Symbol[$fog$42]?function(e){return typeof e}:function(e){return e&&$fog$2==typeof Symbol&&e[$fog$43]===Symbol&&e!==Symbol[$fog$31]?$fog$41:typeof e};var o=$fog$44,a=[];function s(e,t){t&&$fog$9!==t[$fog$35]||(t=[e],e=$fog$33);var r=t[$fog$45](function(e){return $fog$0===(void $fog$9===e?$fog$16:i(e))?JSON[$fog$46](e):e});return r[$fog$47]($fog$48+o+(e?$fog$49+e:$fog$33)+$fog$50),r}var u={LEVEL_ERROR:$fog$51,LEVEL_WARN:$fog$52,LEVEL_INFO:$fog$53,LEVEL_DEBUG:$fog$12,LEVEL_VERBOSE:$fog$54},f=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError($fog$55)}(this,e)}return n(e,$fog$24,[{key:$fog$56,value:function(t){switch(e[$fog$57]=e[$fog$58]=e[$fog$59]=e[$fog$60]=e[$fog$61]=!$fog$6,t){case u[$fog$62]:e[$fog$57]=!$fog$9;break;case u[$fog$63]:e[$fog$57]=e[$fog$58]=!$fog$9;break;case u[$fog$64]:e[$fog$57]=e[$fog$58]=e[$fog$59]=!$fog$9;break;case u[$fog$65]:e[$fog$57]=e[$fog$58]=e[$fog$59]=e[$fog$60]=!$fog$9;break;case u[$fog$66]:e[$fog$57]=e[$fog$58]=e[$fog$59]=e[$fog$60]=e[$fog$61]=!$fog$9}}},{key:$fog$51,value:function(t){if(e[$fog$57]){for(var r=arguments[$fog$35],n=Array(r>$fog$6?r-$fog$6:$fog$9),i=$fog$6;i<r;i++)n[i-$fog$6]=arguments[i];(console[$fog$68]||console[$fog$69]||console[$fog$70])[$fog$67](console,s(t,n))}}},{key:$fog$52,value:function(t){for(var r=arguments[$fog$35],n=Array(r>$fog$6?r-$fog$6:$fog$9),i=$fog$6;i<r;i++)n[i-$fog$6]=arguments[i];var o=s(t,n),u=(new Date)[$fog$71]($fog$72,{hour12:!$fog$6});a[$fog$73](u+$fog$74+o[$fog$75]($fog$74)),e[$fog$58]&&(console[$fog$69]||console[$fog$70])[$fog$67](console,o)}},{key:$fog$53,value:function(t){if(e[$fog$59]){for(var r=arguments[$fog$35],n=Array(r>$fog$6?r-$fog$6:$fog$9),i=$fog$6;i<r;i++)n[i-$fog$6]=arguments[i];(console[$fog$76]||console[$fog$70])[$fog$67](console,s(t,n))}}},{key:$fog$12,value:function(t){if(e[$fog$60]){for(var r=arguments[$fog$35],n=Array(r>$fog$6?r-$fog$6:$fog$9),i=$fog$6;i<r;i++)n[i-$fog$6]=arguments[i];(console[$fog$77]||console[$fog$70])[$fog$67](console,s(t,n))}}},{key:$fog$54,value:function(t){if(e[$fog$61]){for(var r=arguments[$fog$35],n=Array(r>$fog$6?r-$fog$6:$fog$9),i=$fog$6;i<r;i++)n[i-$fog$6]=arguments[i];console[$fog$70][$fog$67](console,s(t,n))}}},{key:$fog$78,value:function(){if($fog$9===a[$fog$35])return{};var e=a[$fog$75]($fog$79);return a=[],{warning:e}}}]),e}();f[$fog$57]=!$fog$9,f[$fog$58]=!$fog$6,f[$fog$59]=!$fog$6,f[$fog$60]=!$fog$6,f[$fog$61]=!$fog$6,t[$fog$80]=f,t[$fog$81]=u},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9}),t[$fog$82]=t[$fog$83]=t[$fog$84]=t[$fog$85]=void $fog$9;var n=function(){return function(e,t){if(Array[$fog$86](e))return e;if(Symbol[$fog$42] in Object(e))return function(e,t){var r=[],n=!$fog$9,i=!$fog$6,o=void $fog$9;try{for(var a,s=e[Symbol[$fog$42]]();!(n=(a=s[$fog$88]())[$fog$87])&&(r[$fog$73](a[$fog$38]),!t||r[$fog$35]!==t);n=!$fog$9);}catch(e){i=!$fog$9,o=e}finally{try{!n&&s[$fog$89]&&s[$fog$89]()}finally{if(i)throw o}}return r}(e,t);throw new TypeError($fog$90)}}(),i=r($fog$91),o=r($fog$9);var a=$fog$92;function s(e,t){var r=arguments[$fog$35]>$fog$25&&void $fog$9!==arguments[$fog$25]?arguments[$fog$25]:i[$fog$94][e][$fog$93],n=i[$fog$94][e];return isNaN(t)||$fog$24===t?(o[$fog$80][$fog$52](a,$fog$95,e,t,$fog$5,r),r):((t<n[$fog$93]||t>n[$fog$96]||$fog$97!=typeof t)&&o[$fog$80][$fog$52](a,$fog$98,e,t,$fog$93,n[$fog$93],$fog$96,n[$fog$96]),Number(t))}t[$fog$85]=s,t[$fog$84]=function(e){if(!e)return o[$fog$80][$fog$52](a,$fog$99,e),i[$fog$100];var t=Object[$fog$101][$fog$67](Object,[{}][$fog$102](function(e){if(Array[$fog$86](e)){for(var t=$fog$9,r=Array(e[$fog$35]);t<e[$fog$35];t++)r[t]=e[t];return r}return Array[$fog$103](e)}(Object[$fog$104](i[$fog$100])[$fog$45](function(t){var r=n(t,$fog$25),i=r[$fog$9],o=r[$fog$6];return function(e,t,r){return t in e?Object[$fog$14](e,t,{value:r,enumerable:!$fog$9,configurable:!$fog$9,writable:!$fog$9}):e[t]=r,e}({},i,s(i,e[i],o))}))));return o[$fog$80][$fog$12](a,$fog$105,t),t},t[$fog$83]=function(e){return!e||!e[$fog$106]||!e[$fog$106][$fog$107]||e[$fog$106][$fog$107][$fog$35]<$fog$6?(o[$fog$80][$fog$52](a,$fog$108,e),i[$fog$109][$fog$106][$fog$107]):e[$fog$106][$fog$107]},t[$fog$82]=function(e){if(!e)return o[$fog$80][$fog$52](a,$fog$110,e),i[$fog$111];var t={buffered:s($fog$112,e[$fog$112]),download:function(e){return e?{size:s($fog$113,e[$fog$114]),duration:s($fog$115,e[$fog$116])}:(o[$fog$80][$fog$52](a,$fog$117,e),i[$fog$111][$fog$118])}(e[$fog$118])};return o[$fog$80][$fog$12](a,$fog$119,t),t}},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n=Object[$fog$101]||function(e){for(var t=$fog$6;t<arguments[$fog$35];t++){var r=arguments[t];for(var n in r)Object[$fog$31][$fog$30][$fog$7](r,n)&&(e[n]=r[n])}return e},i=function(){function e(e,t){for(var r=$fog$9;r<t[$fog$35];r++){var n=t[r];n[$fog$36]=n[$fog$36]||!$fog$6,n[$fog$37]=!$fog$9,$fog$38 in n&&(n[$fog$39]=!$fog$9),Object[$fog$14](e,n[$fog$40],n)}}return function(t,r,n){return r&&e(t[$fog$31],r),n&&e(t,n),t}}(),o=d(r($fog$120)),a=d(r($fog$22)),s=d(r($fog$121)),u=d(r($fog$122)),f=r($fog$9),l=r($fog$6),c=d(r($fog$21));function d(e){return e&&e[$fog$19]?e:{default:e}}var _=$fog$123,h=function(e){function t(e,r,n){!function(e,t){if(!(e instanceof t))throw new TypeError($fog$55)}(this,t);var i=function(e,t){if(!e)throw new ReferenceError($fog$124);return!t||$fog$0!=typeof t&&$fog$2!=typeof t?e:t}(this,(t[$fog$125]||Object[$fog$126](t))[$fog$7](this));f[$fog$80][$fog$12](_,$fog$127,$fog$128),i[$fog$129]=($fog$9,l[$fog$84])(r);var o=($fog$9,l[$fog$83])(e),d=new c[$fog$5](i[$fog$129]);if(i[$fog$130]=new s[$fog$5](o,i[$fog$129],d),i[$fog$131]=new a[$fog$5](i[$fog$129]),i[$fog$132]=new u[$fog$5](i[$fog$129],d),n){var h=n[$fog$133],p=n[$fog$134];i[$fog$130][$fog$135](h),i[$fog$131][$fog$136](p),i[$fog$132][$fog$136](p)}return i[$fog$137]=$fog$9,i[$fog$138]=Date[$fog$139](),i}return function(e,t){if($fog$2!=typeof t&&$fog$24!==t)throw new TypeError($fog$140+typeof t);e[$fog$31]=Object[$fog$23](t&&t[$fog$31],{constructor:{value:e,enumerable:!$fog$6,writable:!$fog$9,configurable:!$fog$9}}),t&&(Object[$fog$141]?Object[$fog$141](e,t):e[$fog$125]=t)}(t,o[$fog$5]),i(t,[{key:$fog$142,value:function(e){if(this[$fog$142][$fog$143]){this[$fog$137]+=$fog$6;var t=($fog$9,l[$fog$82])(e),r=t[$fog$112],n=t[$fog$118];this[$fog$131][$fog$144](r);var i=this[$fog$132][$fog$145](n);this[$fog$146]($fog$147,{type:$fog$148,data:{time:Date[$fog$139](),speed:i,buffered:r}})}else this[$fog$142][$fog$143]=!$fog$9}},{key:$fog$149,value:function(e){var t=($fog$9,l[$fog$82])(e),r=t[$fog$112],n=t[$fog$118],i=this[$fog$132][$fog$145](n),o=this[$fog$130][$fog$150](),a=Date[$fog$139]()-this[$fog$138];this[$fog$138]=Date[$fog$139]();var s=this[$fog$132][$fog$151](r,o,a),u=this[$fog$137]<=this[$fog$129][$fog$152];f[$fog$80][$fog$12](_,$fog$153,u);var c=u?this[$fog$154]():this[$fog$155](r,s),d=c[$fog$133],h=c[$fog$156],p=Date[$fog$139]();return this[$fog$146]($fog$147,{type:$fog$148,data:{time:p,speed:i,buffered:r}}),this[$fog$146]($fog$147,{type:$fog$156,data:{time:p,bitrate:h,speedUpperLimit:s}}),d}},{key:$fog$154,value:function(){return this[$fog$130][$fog$157]()}},{key:$fog$155,value:function(e,t){var r=this[$fog$130][$fog$158](),n=this[$fog$131][$fog$159](t,r);return this[$fog$130][$fog$160](n)}},{key:$fog$161,value:function(){return{speed:this[$fog$132][$fog$162](),extra:JSON[$fog$46](n({},f[$fog$80][$fog$78](),this[$fog$130][$fog$161](),this[$fog$131][$fog$161](),this[$fog$132][$fog$161]()))}}}],[{key:$fog$163,value:function(e){f[$fog$80][$fog$56](e)}}]),t}();t[$fog$5]=h},function(e,t){function r(){this[$fog$164]=this[$fog$164]||{},this[$fog$165]=this[$fog$165]||void $fog$9}function n(e){return $fog$2==typeof e}function i(e){return $fog$0==typeof e&&$fog$24!==e}function o(e){return void $fog$9===e}e[$fog$1]=r,r[$fog$166]=r,r[$fog$31][$fog$164]=void $fog$9,r[$fog$31][$fog$165]=void $fog$9,r[$fog$167]=$fog$168,r[$fog$31][$fog$169]=function(e){if(!function(e){return $fog$97==typeof e}(e)||e<$fog$9||isNaN(e))throw TypeError($fog$170);return this[$fog$165]=e,this},r[$fog$31][$fog$146]=function(e){var t,r,a,s,u,f;if(this[$fog$164]||(this[$fog$164]={}),$fog$68===e&&(!this[$fog$164][$fog$68]||i(this[$fog$164][$fog$68])&&!this[$fog$164][$fog$68][$fog$35])){if((t=arguments[$fog$6])instanceof Error)throw t;var l=new Error($fog$171+t+$fog$172);throw l[$fog$173]=t,l}if(o(r=this[$fog$164][e]))return!$fog$6;if(n(r))switch(arguments[$fog$35]){case $fog$6:r[$fog$7](this);break;case $fog$25:r[$fog$7](this,arguments[$fog$6]);break;case $fog$120:r[$fog$7](this,arguments[$fog$6],arguments[$fog$25]);break;default:s=Array[$fog$31][$fog$174][$fog$7](arguments,$fog$6),r[$fog$67](this,s)}else if(i(r))for(s=Array[$fog$31][$fog$174][$fog$7](arguments,$fog$6),a=(f=r[$fog$174]())[$fog$35],u=$fog$9;u<a;u++)f[u][$fog$67](this,s);return!$fog$9},r[$fog$31][$fog$175]=function(e,t){var a;if(!n(t))throw TypeError($fog$176);return this[$fog$164]||(this[$fog$164]={}),this[$fog$164][$fog$177]&&this[$fog$146]($fog$177,e,n(t[$fog$178])?t[$fog$178]:t),this[$fog$164][e]?i(this[$fog$164][e])?this[$fog$164][e][$fog$73](t):this[$fog$164][e]=[this[$fog$164][e],t]:this[$fog$164][e]=t,i(this[$fog$164][e])&&!this[$fog$164][e][$fog$179]&&(a=o(this[$fog$165])?r[$fog$167]:this[$fog$165])&&a>$fog$9&&this[$fog$164][e][$fog$35]>a&&(this[$fog$164][e][$fog$179]=!$fog$9,console[$fog$68]($fog$180,this[$fog$164][e][$fog$35]),$fog$2==typeof console[$fog$181]&&console[$fog$181]()),this},r[$fog$31][$fog$182]=r[$fog$31][$fog$175],r[$fog$31][$fog$183]=function(e,t){if(!n(t))throw TypeError($fog$176);var r=!$fog$6;function i(){this[$fog$184](e,i),r||(r=!$fog$9,t[$fog$67](this,arguments))}return i[$fog$178]=t,this[$fog$182](e,i),this},r[$fog$31][$fog$184]=function(e,t){var r,o,a,s;if(!n(t))throw TypeError($fog$176);if(!this[$fog$164]||!this[$fog$164][e])return this;if(a=(r=this[$fog$164][e])[$fog$35],o=-$fog$6,r===t||n(r[$fog$178])&&r[$fog$178]===t)delete this[$fog$164][e],this[$fog$164][$fog$184]&&this[$fog$146]($fog$184,e,t);else if(i(r)){for(s=a;s-- >$fog$9;)if(r[s]===t||r[s][$fog$178]&&r[s][$fog$178]===t){o=s;break}if(o<$fog$9)return this;$fog$6===r[$fog$35]?(r[$fog$35]=$fog$9,delete this[$fog$164][e]):r[$fog$185](o,$fog$6),this[$fog$164][$fog$184]&&this[$fog$146]($fog$184,e,t)}return this},r[$fog$31][$fog$186]=function(e){var t,r;if(!this[$fog$164])return this;if(!this[$fog$164][$fog$184])return $fog$9===arguments[$fog$35]?this[$fog$164]={}:this[$fog$164][e]&&delete this[$fog$164][e],this;if($fog$9===arguments[$fog$35]){for(t in this[$fog$164])$fog$184!==t&&this[$fog$186](t);return this[$fog$186]($fog$184),this[$fog$164]={},this}if(n(r=this[$fog$164][e]))this[$fog$184](e,r);else if(r)for(;r[$fog$35];)this[$fog$184](e,r[r[$fog$35]-$fog$6]);return delete this[$fog$164][e],this},r[$fog$31][$fog$187]=function(e){return this[$fog$164]&&this[$fog$164][e]?n(this[$fog$164][e])?[this[$fog$164][e]]:this[$fog$164][e][$fog$174]():[]},r[$fog$31][$fog$188]=function(e){if(this[$fog$164]){var t=this[$fog$164][e];if(n(t))return $fog$6;if(t)return t[$fog$35]}return $fog$9},r[$fog$188]=function(e,t){return e[$fog$188](t)}},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n=function(){function e(e,t){for(var r=$fog$9;r<t[$fog$35];r++){var n=t[r];n[$fog$36]=n[$fog$36]||!$fog$6,n[$fog$37]=!$fog$9,$fog$38 in n&&(n[$fog$39]=!$fog$9),Object[$fog$14](e,n[$fog$40],n)}}return function(t,r,n){return r&&e(t[$fog$31],r),n&&e(t,n),t}}(),i=r($fog$9),o=r($fog$6);var a=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError($fog$55)}(this,e),this[$fog$129]=t,this[$fog$189]=$fog$9}return n(e,[{key:$fog$144,value:function(e){($fog$9,o[$fog$85])($fog$190,e-this[$fog$189]),this[$fog$189]=e}},{key:$fog$159,value:function(e,t){var r=this,n=t[$fog$45](function(t){return r[$fog$191](e,t)});return i[$fog$80][$fog$12]($fog$134,$fog$192,n),n}},{key:$fog$191,value:function(e,t){var r=e/t*$fog$193-$fog$193,n=r>$fog$9?this[$fog$129][$fog$194]:this[$fog$129][$fog$195];return this[$fog$189]+n*r}},{key:$fog$161,value:function(){return{}}},{key:$fog$136,value:function(e){return this[$fog$189]=($fog$9,o[$fog$85])($fog$112,e,this[$fog$189]),this}}]),e}();t[$fog$5]=a},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n={consistent_bitrate_threshold:{min:$fog$9,max:$fog$168},lower_buffered_time:{min:$fog$9,max:$fog$196},upper_buffered_time:{min:$fog$9,max:$fog$196},timeout_minutes:{min:$fog$9,max:Number[$fog$197]},buffer_up_ahead:{min:$fog$9,max:$fog$198},buffer_down_ahead:{min:$fog$9,max:$fog$198},start_up_duration:{min:$fog$9,max:$fog$198},speed_heartbeat_limit:{min:$fog$9,max:$fog$198},buffered:{min:$fog$9,max:$fog$199},bufferDiff:{min:-$fog$200,max:$fog$199},downloadSize:{min:$fog$9,max:$fog$201},downloadDuration:{min:$fog$9,max:$fog$202},bitrate:{min:$fog$198,max:$fog$196}};t[$fog$109]={adaptationSet:{representation:[{bitrate:$fog$203},{bitrate:$fog$193},{bitrate:$fog$204}]}},t[$fog$100]={consistent_bitrate_threshold:$fog$120,lower_buffered_time:$fog$205,upper_buffered_time:$fog$206,timeout_minutes:$fog$207,buffer_up_ahead:$fog$120,buffer_down_ahead:$fog$91,start_up_duration:$fog$120,speed_heartbeat_limit:$fog$208},t[$fog$94]=n,t[$fog$111]={buffered:$fog$9,download:{size:$fog$9,duration:$fog$9}}},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n=function(){function e(e,t){for(var r=$fog$9;r<t[$fog$35];r++){var n=t[r];n[$fog$36]=n[$fog$36]||!$fog$6,n[$fog$37]=!$fog$9,$fog$38 in n&&(n[$fog$39]=!$fog$9),Object[$fog$14](e,n[$fog$40],n)}}return function(t,r,n){return r&&e(t[$fog$31],r),n&&e(t,n),t}}(),i=r($fog$9),o=r($fog$6);var a=$fog$156,s=function(){function e(t,r,n){!function(e,t){if(!(e instanceof t))throw new TypeError($fog$55)}(this,e),this[$fog$209]=t[$fog$45](function(e,t){return{bitrate:e[$fog$156],index:t}})[$fog$211](function(e){var t=e[$fog$156];return t===($fog$9,o[$fog$85])($fog$156,t)})[$fog$210](function(e,t){return e[$fog$156]-t[$fog$156]}),i[$fog$80][$fog$12](a,$fog$212,this[$fog$209][$fog$45](function(e){return e[$fog$156]})),this[$fog$213]=n,this[$fog$129]=r;var s=this[$fog$213][$fog$214]($fog$156,$fog$9);this[$fog$215]=this[$fog$216](s),this[$fog$217]=$fog$9}return n(e,[{key:$fog$216,value:function(e){return Math[$fog$96]($fog$9,this[$fog$209][$fog$211](function(t){return t[$fog$156]<=e})[$fog$35]-$fog$6)}},{key:$fog$160,value:function(e){var t=this,r=this[$fog$215];return this[$fog$218](e[r])?(r=Math[$fog$96]($fog$9,e[$fog$211](function(e){return!t[$fog$218](e)})[$fog$35]-$fog$6),i[$fog$80][$fog$12](a,$fog$219,r)):this[$fog$220](e[r])&&(r=Math[$fog$93](this[$fog$209][$fog$35]-$fog$6,r+$fog$6)),this[$fog$221](r)}},{key:$fog$158,value:function(){return this[$fog$209][$fog$45](function(e){return e[$fog$156]})}},{key:$fog$157,value:function(){return this[$fog$221](this[$fog$215])}},{key:$fog$221,value:function(e){this[$fog$222](e);var t=this[$fog$223](e);this[$fog$224](t);var r=this[$fog$225](e);return i[$fog$80][$fog$12](a,$fog$226,r,$fog$227,t),{index:r,bitrate:t}}},{key:$fog$218,value:function(e){return e<this[$fog$129][$fog$228]}},{key:$fog$220,value:function(e){return e>=this[$fog$129][$fog$229]&&this[$fog$217]>=this[$fog$129][$fog$230]}},{key:$fog$222,value:function(e){e!==this[$fog$215]?(this[$fog$215]=e,this[$fog$217]=$fog$6):this[$fog$217]+=$fog$6}},{key:$fog$223,value:function(e){return this[$fog$209][e][$fog$156]}},{key:$fog$224,value:function(e){this[$fog$213][$fog$231]($fog$156,e)}},{key:$fog$225,value:function(e){return this[$fog$209][e][$fog$133]}},{key:$fog$161,value:function(){return{}}},{key:$fog$135,value:function(e){var t=this[$fog$209][$fog$232](function(t){return t[$fog$133]===e});return-$fog$6===t?i[$fog$80][$fog$52](a,$fog$233,e):this[$fog$215]=t,this}},{key:$fog$150,value:function(){return this[$fog$223](this[$fog$215])}}]),e}();t[$fog$5]=s},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n=function(){function e(e,t){for(var r=$fog$9;r<t[$fog$35];r++){var n=t[r];n[$fog$36]=n[$fog$36]||!$fog$6,n[$fog$37]=!$fog$9,$fog$38 in n&&(n[$fog$39]=!$fog$9),Object[$fog$14](e,n[$fog$40],n)}}return function(t,r,n){return r&&e(t[$fog$31],r),n&&e(t,n),t}}(),i=r($fog$9),o=r($fog$6);var a=function(){function e(t,r){!function(e,t){if(!(e instanceof t))throw new TypeError($fog$55)}(this,e),this[$fog$213]=r,this[$fog$129]=t,this[$fog$234]=this[$fog$213][$fog$214]($fog$235,[]),this[$fog$236]=this[$fog$213][$fog$214]($fog$237,$fog$9),this[$fog$238]=this[$fog$213][$fog$214]($fog$239,$fog$9),this[$fog$189]=$fog$9}return n(e,[{key:$fog$136,value:function(e){return this[$fog$189]=($fog$9,o[$fog$85])($fog$112,e,this[$fog$189]),this}},{key:$fog$145,value:function(e){return this[$fog$234][$fog$47](e),this[$fog$236]=this[$fog$240](),i[$fog$80][$fog$12]($fog$237,$fog$241,this[$fog$236]),this[$fog$213][$fog$231]($fog$237,this[$fog$236]),this[$fog$213][$fog$231]($fog$235,this[$fog$234]),this[$fog$236]}},{key:$fog$240,value:function(){var e=this,t=$fog$9,r=$fog$9;return this[$fog$234][$fog$242](function(n,i){var o=n[$fog$114],a=n[$fog$116],s=$fog$193*e[$fog$129][$fog$243]-r;a>s&&(o=o*s/a,a=s,e[$fog$234][i]={size:o,duration:a},e[$fog$234][$fog$185](i+$fog$6)),r+=a,t+=o}),t/r*$fog$21||$fog$9}},{key:$fog$162,value:function(){return Math[$fog$244](this[$fog$236])}},{key:$fog$161,value:function(){return{speedUpperLimit:Math[$fog$244](this[$fog$238])}}},{key:$fog$151,value:function(e,t,r){if(e>=this[$fog$189])this[$fog$238]=t;else{var n=e+r-this[$fog$189];i[$fog$80][$fog$12]($fog$237,$fog$116,r,$fog$245,n),this[$fog$238]=n*t/Math[$fog$96](r,$fog$6)}return this[$fog$189]=e,i[$fog$80][$fog$12]($fog$237,$fog$246,this[$fog$238]),this[$fog$213][$fog$231]($fog$239,this[$fog$238]),this[$fog$238]}}]),e}();t[$fog$5]=a},function(e,t,r){"use strict";Object[$fog$14](t,$fog$19,{value:!$fog$9});var n=function(){function e(e,t){for(var r=$fog$9;r<t[$fog$35];r++){var n=t[r];n[$fog$36]=n[$fog$36]||!$fog$6,n[$fog$37]=!$fog$9,$fog$38 in n&&(n[$fog$39]=!$fog$9),Object[$fog$14](e,n[$fog$40],n)}}return function(t,r,n){return r&&e(t[$fog$31],r),n&&e(t,n),t}}(),i=r($fog$9);var o=$fog$247,a=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError($fog$55)}(this,e),this[$fog$129]=t,this[$fog$248]=new Set;try{this[$fog$231]($fog$249,!$fog$9),this[$fog$250]=!$fog$9}catch(e){this[$fog$250]=!$fog$6}i[$fog$80][$fog$12](o,$fog$251,this[$fog$250])}return n(e,[{key:$fog$231,value:function(e,t){if(this[$fog$250]){this[$fog$248][$fog$252](e);var r=(new Date)[$fog$253]();localStorage[$fog$254](e,JSON[$fog$46]({value:t,time:r}))}}},{key:$fog$214,value:function(t,r){var n=arguments[$fog$35]>$fog$25&&void $fog$9!==arguments[$fog$25]?arguments[$fog$25]:this[$fog$129][$fog$255];if(this[$fog$250]){this[$fog$248][$fog$252](t);var a=localStorage[$fog$256](t);if(a){var s=JSON[$fog$257](a),u=s[$fog$38],f=s[$fog$258],l=void $fog$9===f?$fog$9:f;if(!e[$fog$259](new Date(l),n))return u;i[$fog$80][$fog$12](o,$fog$260)}}return r}}],[{key:$fog$259,value:function(e,t){return(Date[$fog$139]()-e)/ $fog$261>t}}]),e}();t[$fog$5]=a}])[$fog$5]});\n})("‮", "object", "exports", "function", "amd", "adaptiveMultiRate", "default", 1, "call", "l", 0, "m", "c", "d", "o", "defineProperty", "r", "undefined", "toStringTag", "Module", "__esModule", "t", 8, 4, "create", null, 2, "string", "bind", "n", "a", "hasOwnProperty", "prototype", "p", "", "s", "length", "enumerable", "configurable", "value", "writable", "key", "symbol", "iterator", "constructor", "kwai-a", "map", "stringify", "unshift", "[", "::", "] > ", "e", "w", "i", "v", "Cannot call a class as a function", "level", "ENABLE_ERROR", "ENABLE_WARN", "ENABLE_INFO", "ENABLE_DEBUG", "ENABLE_VERBOSE", "LEVEL_ERROR", "LEVEL_WARN", "LEVEL_INFO", "LEVEL_DEBUG", "LEVEL_VERBOSE", "apply", "error", "warn", "log", "toLocaleTimeString", "CN", "push", " ", "join", "info", "debug", "qos", ";    ", "Log", "LOG_LEVEL", "validInfo", "validRepresentation", "validConfig", "validNumber", "isArray", "done", "next", "return", "Invalid attempt to destructure non-iterable instance", 5, "check", "min", "REASONABLE_VALUE", "invalid number:", "max", "number", "unexpected number value or type:", "invalid config:", "CONFIG", "assign", "concat", "from", "entries", "config:", "adaptationSet", "representation", "invalid representation:", "MANIFEST", "invalid info:", "INFO", "buffered", "downloadSize", "size", "downloadDuration", "duration", "invalid download:", "download", "info:", 3, 6, 7, "main", "this hasn\'t been initialised - super() hasn\'t been called", "__proto__", "getPrototypeOf", "version:", "1.2.6", "_config", "_bitrateCalculator", "_bufferPredictor", "_speedPredictor", "index", "buffer", "setLastIndex", "setLastBuffer", "_seconds", "_time", "now", "Super expression must either be null or a function, not ", "setPrototypeOf", "heartbeatReport", "valid", "recordBuffer", "recordDownload", "emit", "adaptiveAlgorithm", "heartbeat", "nextBitrateIndex", "getLastBitrate", "getSpeedUpperLimitAndUpdate", "start_up_duration", "isStarting:", "_startUpIndex", "_nextIndex", "bitrate", "nextStartUp", "availableBitrates", "predictBuffers", "nextIndexAndBitrate", "getQos", "getSpeed", "setLogLevel", "_events", "_maxListeners", "EventEmitter", "defaultMaxListeners", 10, "setMaxListeners", "n must be a positive number", "Uncaught, unspecified \\"error\\" event. (", ")", "context", "slice", "addListener", "listener must be a function", "newListener", "listener", "warned", "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", "trace", "on", "once", "removeListener", "splice", "removeAllListeners", "listeners", "listenerCount", "_lastBuffer", "bufferDiff", "predictBuffer", "predicted buffer:", 1000, "buffer_up_ahead", "buffer_down_ahead", 100000, "MAX_SAFE_INTEGER", 100, 300000, 1300, 1000000000, 1100, 900, 1500, 3000, 6000, .1, 9, "_availableBitrates", "sort", "filter", "available bitrates:", "_storage", "read", "_lastRequestedIndex", "_highestIndexBelowThan", "_consistentCount", "_needToDecrease", "index:", "_needToIncrease", "_generateResult", "_recordIndex", "_sortedIndex2Rate", "_recordBitrate", "_sortedIndex2Representation", "next index:", "bitrate:", "lower_buffered_time", "upper_buffered_time", "consistent_bitrate_threshold", "write", "findIndex", "fail to find index:", "_downloads", "downloads", "_speed", "speed", "_speedUpperLimit", "speedUpperLimit", "_calculateSpeed", "predictedSpeed:", "forEach", "speed_heartbeat_limit", "round", "downloadBuffer", "speedUpperLimit:", "storage", "_names", "alg", "_isLocalStorageAvailable", "isLocalStorageAvailable", "add", "toLocaleString", "setItem", "timeout_minutes", "getItem", "parse", "time", "timeOut", "read timeout", 60000);\n     \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/@ks/adaptive-multi-rate/lib/index.js?')},"./node_modules/events/events.js":function(module,exports){eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/events/events.js?")},"./node_modules/querystringify/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  return decodeURIComponent(input.replace(/\\+/g, ' '));\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    if (key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/querystringify/index.js?")},"./node_modules/requires-port/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/requires-port/index.js?")},"./node_modules/url-parse/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar required = __webpack_require__(/*! requires-port */ \"./node_modules/requires-port/index.js\")\n  , qs = __webpack_require__(/*! querystringify */ \"./node_modules/querystringify/index.js\")\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address) {          // Sanitize what is left of the address\n    return address.replace('\\\\', '/');\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var location = global && global.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address) {\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} location Location defaults for relative paths.\n * @param {Boolean|Function} parser Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.qs = qs;\n\nmodule.exports = Url;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/url-parse/index.js?")},"./node_modules/url-toolkit/src/url-toolkit.js":function(module,exports,__webpack_require__){eval("// see https://tools.ietf.org/html/rfc1808\r\n\r\n/* jshint ignore:start */\r\n(function(root) { \r\n/* jshint ignore:end */\r\n\r\n  var URL_REGEX = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/\\;?#]*)?(.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/;\r\n  var FIRST_SEGMENT_REGEX = /^([^\\/;?#]*)(.*)$/;\r\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\r\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g;\r\n\r\n  var URLToolkit = { // jshint ignore:line\r\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\r\n    // E.g\r\n    // With opts.alwaysNormalize = false (default, spec compliant)\r\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\r\n    // With opts.alwaysNormalize = true (not spec compliant)\r\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\r\n    buildAbsoluteURL: function(baseURL, relativeURL, opts) {\r\n      opts = opts || {};\r\n      // remove any remaining space and CRLF\r\n      baseURL = baseURL.trim();\r\n      relativeURL = relativeURL.trim();\r\n      if (!relativeURL) {\r\n        // 2a) If the embedded URL is entirely empty, it inherits the\r\n        // entire base URL (i.e., is set equal to the base URL)\r\n        // and we are done.\r\n        if (!opts.alwaysNormalize) {\r\n          return baseURL;\r\n        }\r\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\r\n        if (!basePartsForNormalise) {\r\n          throw new Error('Error trying to parse base URL.');\r\n        }\r\n        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\r\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\r\n      }\r\n      var relativeParts = URLToolkit.parseURL(relativeURL);\r\n      if (!relativeParts) {\r\n        throw new Error('Error trying to parse relative URL.');\r\n      }\r\n      if (relativeParts.scheme) {\r\n        // 2b) If the embedded URL starts with a scheme name, it is\r\n        // interpreted as an absolute URL and we are done.\r\n        if (!opts.alwaysNormalize) {\r\n          return relativeURL;\r\n        }\r\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\r\n        return URLToolkit.buildURLFromParts(relativeParts);\r\n      }\r\n      var baseParts = URLToolkit.parseURL(baseURL);\r\n      if (!baseParts) {\r\n        throw new Error('Error trying to parse base URL.');\r\n      }\r\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\r\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\r\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\r\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\r\n        baseParts.netLoc = pathParts[1];\r\n        baseParts.path = pathParts[2];\r\n      }\r\n      if (baseParts.netLoc && !baseParts.path) {\r\n        baseParts.path = '/';\r\n      }\r\n      var builtParts = {\r\n        // 2c) Otherwise, the embedded URL inherits the scheme of\r\n        // the base URL.\r\n        scheme: baseParts.scheme,\r\n        netLoc: relativeParts.netLoc,\r\n        path: null,\r\n        params: relativeParts.params,\r\n        query: relativeParts.query,\r\n        fragment: relativeParts.fragment\r\n      };\r\n      if (!relativeParts.netLoc) {\r\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\r\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\r\n        // (if any) of the base URL.\r\n        builtParts.netLoc = baseParts.netLoc;\r\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\r\n        // path is not relative and we skip to Step 7.\r\n        if (relativeParts.path[0] !== '/') {\r\n          if (!relativeParts.path) {\r\n            // 5) If the embedded URL path is empty (and not preceded by a\r\n            // slash), then the embedded URL inherits the base URL path\r\n            builtParts.path = baseParts.path;\r\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\r\n            // step 7; otherwise, it inherits the <params> of the base\r\n            // URL (if any) and\r\n            if (!relativeParts.params) {\r\n              builtParts.params = baseParts.params;\r\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\r\n              // step 7; otherwise, it inherits the <query> of the base\r\n              // URL (if any) and we skip to step 7.\r\n              if (!relativeParts.query) {\r\n                builtParts.query = baseParts.query;\r\n              }\r\n            }\r\n          } else {\r\n            // 6) The last segment of the base URL's path (anything\r\n            // following the rightmost slash \"/\", or the entire path if no\r\n            // slash is present) is removed and the embedded URL's path is\r\n            // appended in its place.\r\n            var baseURLPath = baseParts.path;\r\n            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\r\n            builtParts.path = URLToolkit.normalizePath(newPath);\r\n          }\r\n        }\r\n      }\r\n      if (builtParts.path === null) {\r\n        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\r\n      }\r\n      return URLToolkit.buildURLFromParts(builtParts);\r\n    },\r\n    parseURL: function(url) {\r\n      var parts = URL_REGEX.exec(url);\r\n      if (!parts) {\r\n        return null;\r\n      }\r\n      return {\r\n        scheme: parts[1] || '',\r\n        netLoc: parts[2] || '',\r\n        path: parts[3] || '',\r\n        params: parts[4] || '',\r\n        query: parts[5] || '',\r\n        fragment: parts[6] || ''\r\n      };\r\n    },\r\n    normalizePath: function(path) {\r\n      // The following operations are\r\n      // then applied, in order, to the new path:\r\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\r\n      // segment, are removed.\r\n      // 6b) If the path ends with \".\" as a complete path segment,\r\n      // that \".\" is removed.\r\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\r\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\r\n      // complete path segment not equal to \"..\", are removed.\r\n      // Removal of these path segments is performed iteratively,\r\n      // removing the leftmost matching pattern on each iteration,\r\n      // until no matching pattern remains.\r\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\r\n      // complete path segment not equal to \"..\", that\r\n      // \"<segment>/..\" is removed.\r\n      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line\r\n      return path.split('').reverse().join('');\r\n    },\r\n    buildURLFromParts: function(parts) {\r\n      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\r\n    }\r\n  };\r\n\r\n/* jshint ignore:start */\r\n  if(true)\r\n    module.exports = URLToolkit;\r\n  else {}\r\n})(this);\r\n/* jshint ignore:end */\r\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/url-toolkit/src/url-toolkit.js?")},"./node_modules/webpack/buildin/amd-define.js":function(module,exports){eval('module.exports = function() {\n\tthrow new Error("define cannot be used indirect");\n};\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/(webpack)/buildin/amd-define.js?')},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/(webpack)/buildin/global.js?')},"./node_modules/webpack/buildin/module.js":function(module,exports){eval('module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/(webpack)/buildin/module.js?')},"./node_modules/webworkify-webpack/index.js":function(module,exports,__webpack_require__){eval("function webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __webpack_require__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __webpack_require__.m = modules;\n\n/******/  // expose the module cache\n/******/  __webpack_require__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __webpack_require__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __webpack_require__.d = function(exports, name, getter) {\n/******/    if(!__webpack_require__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __webpack_require__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __webpack_require__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __webpack_require__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __webpack_require__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\((\\/\\\\*.*?\\\\*\\/)?\\s?.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __webpack_require__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __webpack_require__.m\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/./node_modules/webworkify-webpack/index.js?")},"./src/config.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaultConfig = {\n    isLive: false, // 是否是直播\n    box: 'flv', // 容器\n    alwaysSeekKeyframe: false, // 总是seek 到关键帧\n    lazyLoadMaxDuration: 2 * 60, // 懒加载 最大播放长度\n    lazyLoadRecoverDuration: 30, // 懒加载还有多少长度 重启加载功能\n    debug: true, // 是否开启debug模式\n    webWorker: true, // 是否开启webworker\n    autoCleanupSourceBuffer: true, // 是否自动清除 sourcebuffer\n    autoCleanupMaxBackwardDuration: 60, // 清除sourcebuffer最大时间\n    autoCleanupMinBackwardDuration: 15, // 清除sourcebuffer最小时间\n    seekType: 'range', // seek请求的方式 是range 还是 query\n    bufferStrategyLimit: 5000, // 卡时buffer的上限\n    bufferStrategyFirst: 1500, // 卡时buffer的初始值\n    bufferStrategyIncrementStep: 200, // 卡时buffer的增长\n    skipLostFrame: true,\n    appendErrorMaxRetry: 3, // mse append出错后重试次数\n    credentials: false, // 请求是否带cookie\n    // bitrateStart: 0, // HLS起始码率，默认undefined\n    hlsStreamingMux: true // HLS流式处理\n};\n\nvar ConfigHelper = function () {\n    function ConfigHelper() {\n        _classCallCheck(this, ConfigHelper);\n    }\n\n    _createClass(ConfigHelper, null, [{\n        key: 'processConfig',\n\n        /**\n         * 处理传入的config\n         * @param {object} userConfig 传入config\n         * @returns {object} config\n         */\n        value: function processConfig(userConfig) {\n            var config = Object.assign({}, defaultConfig);\n            Object.assign(config, userConfig);\n            config.skipLostFrame = config.isLive ? config.skipLostFrame : false;\n            return ConfigHelper.setSrc(config);\n        }\n\n        /**\n         * 重新设置config的src\n         * @param {object} config 传入config\n         * @param {*} src src或manifest\n         * @returns {object} config\n         */\n\n    }, {\n        key: 'setSrc',\n        value: function setSrc(config) {\n            var src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (src) {\n                config.src = src;\n            }\n            var needProcessConfig = _typeof(config.src) === 'object';\n            if (needProcessConfig) {\n                config.adaptiveMultiRate = ConfigHelper._multiratePreProcessing(config);\n                if (config.adaptiveMultiRate) {\n                    return config;\n                }\n                config.multipart = ConfigHelper._multipartDataPreProcessing(config);\n                if (config.multipart) {\n                    return config;\n                }\n                return null;\n            }\n\n            return config;\n        }\n\n        /**\n         * 检查是否为多码率manifest\n         * @param {object} config 传入config\n         * @returns {object} config\n         */\n\n    }, {\n        key: '_multiratePreProcessing',\n        value: function _multiratePreProcessing(config) {\n            var manifest = config.src;\n            if (manifest && manifest.hasOwnProperty('adaptationSet') && manifest.adaptationSet.hasOwnProperty('representation') && Array.isArray(manifest.adaptationSet.representation) && manifest.adaptationSet.representation.length > 0) {\n                config.manifest = manifest;\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * 分片数据预处理\n         * @param {object} config 分片flv数据\n         * @returns {boolean} 数据是否合法\n         */\n\n    }, {\n        key: '_multipartDataPreProcessing',\n        value: function _multipartDataPreProcessing(config) {\n            var data = config.src;\n            if (data.segments && Array.isArray(data.segments) && data.segments.length > 0) {\n                var times = 0;\n                var filepositions = 0;\n                var startFromIndex = -1;\n                data.keyframesIndex = { times: [], filepositions: [] };\n                config.duration = config.src.duration || 0;\n                // 为flv切片列表添加时间及位置属性，并验证数据格式，计算起始时间点对应的分片起始位置\n                for (var i = 0; i < data.segments.length; i++) {\n                    if (data.segments[i].hasOwnProperty('duration') && data.segments[i].hasOwnProperty('filesize')) {\n                        data.keyframesIndex.times.push(times);\n                        data.keyframesIndex.filepositions.push(filepositions);\n                        data.segments[i].time = times;\n                        data.segments[i].fileposition = filepositions;\n                        filepositions += data.segments[i].filesize;\n                        times += data.segments[i].duration;\n                        if (startFromIndex === -1 && times > config.startFrom) {\n                            startFromIndex = i;\n                            config.startFromKeyframePoint = data.segments[i].time;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n                // 未找到起始事件对应位置，从0开始播放\n                if (startFromIndex === -1) {\n                    config.startFrom = 0;\n                    config.startFromKeyframePoint = 0;\n                }\n            } else {\n                return false;\n            }\n            return true;\n        }\n    }]);\n\n    return ConfigHelper;\n}();\n\nexports.defaultConfig = defaultConfig;\nexports.ConfigHelper = ConfigHelper;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/config.js?")},"./src/const.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nvar ERRORNO = exports.ERRORNO = {\n    UNKNOW_ERROR: 10,\n    NET_ERROR: 100,\n    CODEC_ERROR: 101,\n    CANNOT_SEEK: 102,\n    ENDOFSTREAM_ERROR: 103,\n    MEDIASOURCE_ERROR: 104,\n    SOURCEBUFFER_ERROR: 105,\n    SBABORT_ERROR: 106,\n    APPENDBUFFER_ERROR: 107,\n    FORMAT_ERROR: 108,\n    CODEC_UNSUPPORTED: 109,\n    VIDEO_ELEMENT_PLAY_ERROR: 110,\n    CONFIG_DATA_ERROR: 111\n};\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/const.js?')},"./src/core/kernel-errors.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar ErrorTypes = exports.ErrorTypes = {\n    // Identifier for a network error (loading error / timeout ...)\n    NETWORK_ERROR: 'networkError',\n    // Identifier for a media Error (video/parsing/mediasource error)\n    MEDIA_ERROR: 'mediaError',\n    // EME (encrypted media extensions) errors\n    KEY_SYSTEM_ERROR: 'keySystemError',\n    // Identifier for a mux Error (demuxing/remuxing)\n    MUX_ERROR: 'muxError',\n    // Identifier for all other errors\n    OTHER_ERROR: 'otherError',\n    MSE_ERROR: 'mseError'\n};\n\n/**\n * @enum {ErrorDetails}\n * @typedef {string} ErrorDetail\n */\nvar ErrorDetails = exports.ErrorDetails = {\n    // Identifier for fragment load error\n    // data: { frag : fragment object, response : { code: error code, text: error text }}\n    LOAD_ERROR: 'loadError',\n    // Identifier for fragment load timeout error - data: { frag : fragment object}\n    LOAD_TIMEOUT: 'loadTimeOut',\n    ADDSOURCEBUFFER_ERROR: 'addSourceBufferError',\n    SOURCEBUFFER_ERROR: 'sourceBufferError',\n    ENDOFSTREAM_ERROR: 'endOfStreamError',\n    APPENDBUFFER_ERROR: 'appendBufferError',\n    CANNOT_SEEK: 'canNotSeek',\n    MEDIASOURCE_ERROR: 'mediaSourceError',\n    // Identifier for a manifest load error\n    // data: { url : faulty URL, response : { code: error code, text: error text }}\n    HLS_MANIFEST_LOAD_ERROR: 'hlsManifestLoadError',\n    // Identifier for a manifest load timeout\n    // data: { url : faulty URL, response : { code: error code, text: error text }}\n    HLS_MANIFEST_LOAD_TIMEOUT: 'hlsManifestLoadTimeOut',\n    // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n    HLS_MANIFEST_PARSING_ERROR: 'hlsManifestParsingError',\n    // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n    HLS_MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'hlsManifestIncompatibleCodecsError',\n    // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n    HLS_LEVEL_LOAD_ERROR: 'hlsLevelLoadError',\n    // Identifier for a level load timeout\n    // data: { url : faulty URL, response : { code: error code, text: error text }}\n    HLS_LEVEL_LOAD_TIMEOUT: 'hlsLevelLoadTimeOut',\n    // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n    HLS_LEVEL_SWITCH_ERROR: 'hlsLevelSwitchError',\n    // Identifier for a fragment decryption error event\n    //  data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n    // FRAG_DECRYPT_ERROR: 'fragDecryptError',\n    // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n    // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n    PARSING_ERROR: 'parsingError',\n    // Identifier for a remux alloc error event\n    // data: { id : demuxer Id, frag : fragment object,\n    // bytes : nb of bytes on which allocation failed , reason : error text }\n    REMUX_ALLOC_ERROR: 'remuxAllocError',\n    REMUX_ERROR: 'remuxError',\n    // Identifier for decrypt key load error\n    // data: { frag : fragment object, response : { code: error code, text: error text }}\n    HLS_KEY_LOAD_ERROR: 'keyLoadError',\n    // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n    HLS_KEY_LOAD_TIMEOUT: 'keyLoadTimeOut'\n};\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/kernel-errors.js?")},"./src/core/kernel-events.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar KernelEvents = {\n    // flv metadata\n    METADATA: 'metadata',\n    MEDIA_INFO: 'mediaInfo',\n    PARSING_INIT_SEGMENT: 'parsingInitSegment',\n    PARSING_DATA: 'parsingData',\n    // 解析到flv script tag\n    SCRIPT_PARSED: 'scriptParsed',\n    // 直播丢帧\n    LOST_FRAMES: 'lostFrames',\n    // 数据收集\n    REPORT: 'report',\n    // 下载完成\n    END: 'end',\n    // 流出现中断\n    DISCONTINUITY: 'discontinuity',\n    // Identifier for an error event - data:\n    // { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover,\n    // if false, hls.js will try to recover,other error specific data }\n    ERROR: 'kernelError',\n    // fired when a level switch is effective - data: { bitrate: current bitrate, smooth }\n    LEVEL_SWITCHED: 'levelSwitched',\n    // fired when a level playlist loading finishes - data:\n    // { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }\n    LEVEL_LOADED: 'levelLoaded',\n    // fired when a level's details have been updated based on previous details, after it has been loaded - data:\n    // { details : levelDetails object, level : id of updated level }\n    LEVEL_UPDATED: 'hlsLevelUpdated',\n    // 收到IDR，用于flv自适应码率\n    IDR: 'idr',\n    // fired after manifest has been loaded - data:\n    // { levels : [available quality levels], audioTracks : [ available audio tracks],\n    // url : manifestURL, stats : { trequest, tfirst, tload, mtime}}\n    HLS_MANIFEST_LOADED: 'hlsManifestLoaded',\n    // fired after manifest has been parsed - data:\n    // { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n    MANIFEST_PARSED: 'manifestParsed',\n    // fired when a level's PTS information has been updated after parsing a fragment - data:\n    // { details : levelDetails object, level : id of updated level,\n    // drift: PTS drift observed when parsing last fragment }\n    HLS_LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',\n    // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }\n    HLS_INIT_PTS_FOUND: 'hlsInitPtsFound',\n    // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n    HLS_FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',\n    // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n    HLS_FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',\n    // fired when a fragment loading is completed - data:\n    // { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }\n    HLS_FRAG_LOADED: 'hlsFragLoaded',\n    // fired when a fragment has finished decrypting - data:\n    // { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n    HLS_FRAG_DECRYPTED: 'hlsFragDecrypted',\n    // fired when parsing sei text is completed - data:\n    // { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n    // HLS_FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',\n    // fired when parsing id3 is completed - data:\n    // { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n    // HLS_FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',\n    // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n    HLS_FRAG_PARSED: 'hlsFragParsed',\n    // fired when a decrypt key loading is completed - data:\n    // { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }\n    HLS_KEY_LOADED: 'hlsKeyLoaded'\n};\n\nexports.default = KernelEvents;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/kernel-events.js?")},"./src/core/mse-controller.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _kernelEvents = __webpack_require__(/*! ./kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _kernelErrors = __webpack_require__(/*! ./kernel-errors */ \"./src/core/kernel-errors.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MSEController = function (_Events) {\n    _inherits(MSEController, _Events);\n\n    /**\n     * Mediasource 控制层\n     * @class Mediasource\n     * @param {Element} videoElement videoElement\n     * @param {object} config config\n     */\n    function MSEController(videoElement, config) {\n        _classCallCheck(this, MSEController);\n\n        var _this = _possibleConstructorReturn(this, (MSEController.__proto__ || Object.getPrototypeOf(MSEController)).call(this));\n\n        _this.video = videoElement;\n        _this.config = config;\n        _this.tag = 'mse-controller';\n        _this.e = {\n            onSourceOpen: _this.onSourceOpen.bind(_this),\n            onSourceEnded: _this.onSourceEnded.bind(_this),\n            onSourceClose: _this.onSourceClose.bind(_this),\n            onSourceBufferError: _this.onSourceBufferError.bind(_this),\n            onSourceBufferUpdateEnd: _this.onSourceBufferUpdateEnd.bind(_this)\n        };\n        _this.hasVideo = false;\n        _this.hasAudio = false;\n        _this.removeRangesList = {\n            video: [],\n            audio: []\n        };\n        _this.removeBucketing = false;\n        _this.timer = {\n            video: null,\n            audio: null\n        };\n        _this.queue = {\n            video: [],\n            audio: []\n        };\n        _this.sourceBuffer = {\n            video: null,\n            audio: null\n        };\n        _this.mimeCodec = {\n            video: null,\n            audio: null\n        };\n        _this.sourceBufferEvent();\n        _this.complete = false;\n\n        if (MediaSource) {\n            var ms = _this.mediaSource = new MediaSource();\n            _this.video.src = URL.createObjectURL(ms);\n            ms.addEventListener('sourceopen', _this.e.onSourceOpen);\n            ms.addEventListener('sourceended', _this.e.onSourceEnded);\n            ms.addEventListener('sourceclose', _this.e.onSourceClose);\n        } else {\n            _this.emit(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.MSE_ERROR,\n                details: _kernelErrors.ErrorDetails.MEDIASOURCE_ERROR,\n                fatal: true,\n                reason: 'MediaSource is not support'\n            });\n        }\n        return _this;\n    }\n\n    /**\n     * mediaSource init\n     * @param {Object} mediaInfo mediaInfo\n     */\n\n\n    _createClass(MSEController, [{\n        key: 'init',\n        value: function init(mediaInfo) {\n            if (mediaInfo.hasAudio && mediaInfo.audioCodec) {\n                this.mimeCodec.audio = 'audio/mp4; codecs=\"' + mediaInfo.audioCodec + '\"';\n                this.hasAudio = true;\n            }\n            if (mediaInfo.hasVideo && mediaInfo.videoCodec) {\n                this.mimeCodec.video = 'video/mp4; codecs=\"' + mediaInfo.videoCodec + '\"';\n                this.hasVideo = true;\n            }\n            if (this.mediaSource) {\n                if (this.mediaSource.readyState === 'open') {\n                    if (this.hasAudio) {\n                        this.addSourceBuffer('audio');\n                    }\n                    if (this.hasVideo) {\n                        this.addSourceBuffer('video');\n                    }\n                }\n                return;\n            }\n        }\n\n        /**\n         * mediaSource open\n         */\n\n    }, {\n        key: 'onSourceOpen',\n        value: function onSourceOpen() {\n            _log.Log.i(this.tag, 'MediaSource onSourceOpen');\n            this.mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n            if (this.hasAudio) {\n                this.addSourceBuffer('audio');\n            }\n            if (this.hasVideo) {\n                this.addSourceBuffer('video');\n            }\n            if (this.hasQueueList()) {\n                this.doUpdate();\n            }\n            this.emit('source_open');\n        }\n\n        /**\n         * addSourceBuffer\n         * @param {String} type type\n         */\n\n    }, {\n        key: 'addSourceBuffer',\n        value: function addSourceBuffer(type) {\n            if (this.sourceBuffer[type]) {\n                return;\n            }\n            try {\n                this.sourceBuffer[type] = this.mediaSource.addSourceBuffer(this.mimeCodec[type]);\n            } catch (e) {\n                // this.emit('error', { errno: ERRORNO.SOURCEBUFFER_ERROR, errmsg: e.toString() });\n                _log.Log.e(this.tag, e);\n                this.emit(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MSE_ERROR,\n                    details: _kernelErrors.ErrorDetails.ADDSOURCEBUFFER_ERROR,\n                    fatal: true,\n                    reason: e.message\n                });\n                return;\n            }\n            var sb = this.sourceBuffer[type];\n            sb.addEventListener('error', this.e.onSourceBufferError);\n            sb.addEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n        }\n    }, {\n        key: 'hasRemoveList',\n        value: function hasRemoveList() {\n            return this.removeRangesList.video.length || this.removeRangesList.audio.length;\n        }\n    }, {\n        key: 'hasQueueList',\n        value: function hasQueueList() {\n            return this.queue.video.length || this.queue.audio.length;\n        }\n\n        /**\n         * addSourceBuffer\n         */\n\n    }, {\n        key: 'doUpdate',\n        value: function doUpdate() {\n            if (this._needFlush()) {\n                this.cleanRangesList();\n            } else {\n                for (var type in this.queue) {\n                    if (this.queue[type].length > 0 && this.sourceBuffer[type] && !this.sourceBuffer[type].updating && !this.appendBufferError) {\n                        var data = this.queue[type].shift();\n                        this.appendBuffer(data, type);\n                    }\n                }\n                if (this._waitingEnd) {\n                    this.endOfStream();\n                }\n            }\n        }\n\n        /**\n         * sourceBuffer event\n         */\n\n    }, {\n        key: 'sourceBufferEvent',\n        value: function sourceBufferEvent() {\n            var _this2 = this;\n\n            this._segLen = 0;\n            this.on(_kernelEvents2.default.PARSING_DATA, function (data) {\n                var type = data.type;\n                _this2.queue[type].push(data.data);\n                _this2._segLen += data.data.byteLength;\n                if (_this2.sourceBuffer[type]) {\n                    _this2.doUpdate();\n                }\n            });\n\n            this.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, function (data) {\n                var type = data.type;\n                _log.Log.v(_this2.tag, 'PARSING_INIT_SEGMENT', type);\n                _this2.queue[type].push(data.data);\n            });\n        }\n\n        /**\n         * need clean sourcebuffer\n         * @param {string} type 类型\n         * @returns {boolean} 是否需要清缓存\n         */\n\n    }, {\n        key: 'needCleanupSourceBuffer',\n        value: function needCleanupSourceBuffer(type) {\n            var currentTime = this.video.currentTime;\n            if (this.sourceBuffer[type] && !this.video.seeking) {\n                var buffered = this.sourceBuffer[type].buffered;\n                if (buffered.length >= 1) {\n                    if (currentTime - buffered.start(0) >= this.config.autoCleanupMaxBackwardDuration) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        /**\n         * clean buffer\n         * @param {string} type type\n         */\n\n    }, {\n        key: 'doCleanupSourceBuffer',\n        value: function doCleanupSourceBuffer(type) {\n            var removeEnd = this.video.currentTime - this.config.autoCleanupMinBackwardDuration;\n            var sb = this.sourceBuffer[type];\n            if (sb && !this.video.seeking) {\n                for (var i = 0; i < sb.buffered.length; i++) {\n                    var start = sb.buffered.start(i);\n                    var end = sb.buffered.end(i);\n                    if (removeEnd > start) {\n                        if (removeEnd < end) {\n                            end = Math.floor(removeEnd);\n                        }\n                        this.removeRangesList[type].push({ start: start, end: end });\n                    } else {\n                        break;\n                    }\n                }\n                if (!sb.updating) {\n                    this.cleanRangesList(type);\n                }\n            }\n        }\n\n        /**\n         * clean bufferlist\n         * @param {String} type type\n         * @return {boolean} is succeed\n         */\n\n    }, {\n        key: 'cleanRangesList',\n        value: function cleanRangesList(type) {\n            if (!this.sourceBuffer[type] || this.sourceBuffer[type].updating) {\n                return false;\n            }\n            var sb = this.sourceBuffer[type];\n            while (this.removeRangesList[type].length && !sb.updating) {\n                var ranges = this.removeRangesList[type].shift();\n                if (ranges.end <= ranges.start) {\n                    ranges.start = ranges.end - 1;\n                }\n                sb.remove(ranges.start, ranges.end);\n            }\n            return true;\n        }\n\n        /**\n         * appendBuffer\n         * @param {Object} data data\n         * @param {String} type type\n         */\n\n    }, {\n        key: 'appendBuffer',\n        value: function appendBuffer(data, type) {\n            if (!this.sourceBuffer[type]) {\n                return;\n            }\n            try {\n                this.sourceBuffer[type].appendBuffer(data.buffer);\n            } catch (e) {\n                _log.Log.w(this.tag, e.code, e);\n                if (e.code !== 22) {\n                    if (this.appendError) {\n                        this.appendError++;\n                    } else {\n                        this.appendError = 1;\n                    }\n                    if (this.appendError > this.config.appendErrorMaxRetry) {\n                        this.appendBufferError = true;\n                        // this.emit('error', { errno: ERRORNO.APPENDBUFFER_ERROR, errmsg: e });\n                        this.emit(_kernelEvents2.default.ERROR, {\n                            type: _kernelErrors.ErrorTypes.MSE_ERROR,\n                            details: _kernelErrors.ErrorDetails.APPENDBUFFER_ERROR,\n                            fatal: true,\n                            reason: e.message\n                        });\n                    }\n                } else {\n                    this.queue[type].unshift();\n                    this.emit('bufferFull');\n                }\n            }\n        }\n\n        /**\n         * sourcebuffer end\n         */\n\n    }, {\n        key: 'onSourceEnded',\n        value: function onSourceEnded() {\n            _log.Log.i(this.tag, 'MediaSource onSourceEnded');\n        }\n\n        /**\n         * sourcebuffer close\n         */\n\n    }, {\n        key: 'onSourceClose',\n        value: function onSourceClose() {\n            _log.Log.i(this.tag, 'MediaSource onSourceClose');\n            if (this.mediaSource && this.e !== null) {\n                this.mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen);\n                this.mediaSource.removeEventListener('sourceended', this.e.onSourceEnded);\n                this.mediaSource.removeEventListener('sourceclose', this.e.onSourceClose);\n            }\n        }\n    }, {\n        key: 'onSourceBufferUpdateEnd',\n        value: function onSourceBufferUpdateEnd() {\n            if (!this.sourceBuffer) {\n                return;\n            }\n            for (var type in this.sourceBuffer) {\n                if (this.sourceBuffer[type] && !this.sourceBuffer[type].updating && this.needCleanupSourceBuffer(type)) {\n                    this.doCleanupSourceBuffer(type);\n                }\n            }\n            if (this._needFlush()) {\n                this._doFlush();\n            } else if (this.hasQueueList()) {\n                this.doUpdate();\n            } else if (this.complete) {\n                var updating = 0;\n                for (var _type in this.sourceBuffer) {\n                    var sb = this.sourceBuffer[_type];\n                    if (sb && sb.updating) {\n                        updating++;\n                    }\n                }\n                if (!updating) {\n                    this.endOfStream();\n                }\n            }\n            this.emit('updateend');\n        }\n\n        /**\n         * sourcebuffer error\n         * @param {Object} e 事件\n         */\n\n    }, {\n        key: 'onSourceBufferError',\n        value: function onSourceBufferError(e) {\n            _log.Log.e(this.tag, 'SourceBuffer Error: ' + e);\n            // this.emit('error', { errno: ERRORNO.SOURCEBUFFER_ERROR, errmsg: e.message });\n            this.emit(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.MSE_ERROR,\n                details: _kernelErrors.ErrorDetails.SOURCEBUFFER_ERROR,\n                fatal: true,\n                reason: e.message\n            });\n        }\n\n        /**\n         * seek\n         */\n\n    }, {\n        key: 'flush',\n        value: function flush() {\n            this._waitingEnd = false;\n            for (var type in this.sourceBuffer) {\n                var sb = this.sourceBuffer[type];\n                if (!sb) {\n                    continue;\n                }\n                this.queue[type] = [];\n                for (var i = 0; i < sb.buffered.length; i++) {\n                    var start = sb.buffered.start(i);\n                    var end = sb.buffered.end(i);\n                    this.removeRangesList[type].push({ start: start, end: end });\n                }\n            }\n\n            if (this._needFlush()) {\n                this._doFlush();\n            }\n        }\n\n        /**\n         * resume\n         */\n\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this.doUpdate();\n        }\n\n        /**\n         * pause\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            // this.endOfStream();\n        }\n    }, {\n        key: 'endOfData',\n        value: function endOfData() {\n            if (this.hasQueueList()) {\n                this._waitingEnd = true;\n            } else {\n                this.endOfStream();\n            }\n        }\n    }, {\n        key: 'endOfStream',\n        value: function endOfStream() {\n            if (this.mediaSource) {\n                var ms = this.mediaSource;\n                this.complete = true;\n                var sb = this.sourceBuffer;\n                if (sb.video && sb.video.updating || sb.audio && sb.audio.updating) {\n                    return;\n                }\n                if (ms.readyState === 'open') {\n                    try {\n                        ms.endOfStream();\n                        this.complete = false;\n                    } catch (error) {\n                        _log.Log.e(this.tag, error);\n                        // this.emit('error', { errno: ERRORNO.ENDOFSTREAM_ERROR, errmsg: error.message });\n                        this.emit(_kernelEvents2.default.ERROR, {\n                            type: _kernelErrors.ErrorTypes.MSE_ERROR,\n                            details: _kernelErrors.ErrorDetails.ENDOFSTREAM_ERROR,\n                            fatal: true,\n                            reason: error.message\n                        });\n                    }\n                }\n            }\n        }\n\n        /**\n         * destroy\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this.mediaSource) {\n                var ms = this.mediaSource;\n                // pending segments should be discard\n\n                // remove all sourcebuffers\n                this.complete = false;\n                this.endOfStream();\n                if (this.sourceBuffer) {\n                    if (ms.readyState !== 'closed') {\n                        for (var type in this.sourceBuffer) {\n                            this.sourceBuffer[type].removeEventListener('error', this.e.onSourceBufferError);\n                            this.sourceBuffer[type].removeEventListener('updateend', this.e.onSourceBufferUpdateEnd);\n                            ms.removeSourceBuffer(this.sourceBuffer[type]);\n                        }\n                    }\n                }\n                ms.removeEventListener('sourceopen', this.e.onSourceOpen);\n                ms.removeEventListener('sourceended', this.e.onSourceEnded);\n                ms.removeEventListener('sourceclose', this.e.onSourceClose);\n                this.mediaSource = null;\n            }\n            this.removeAllListeners();\n            this.queue = null;\n            this.sourceBuffer = null;\n            this.mimeCodec = null;\n        }\n    }, {\n        key: '_needFlush',\n        value: function _needFlush() {\n            var range = this.removeRangesList;\n            for (var type in range) {\n                if (range[type].length > 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: '_doFlush',\n        value: function _doFlush() {\n            var range = this.removeRangesList;\n            for (var type in range) {\n                if (this.sourceBuffer[type]) {\n                    this.cleanRangesList(type);\n                } else {\n                    range[type] = [];\n                }\n            }\n        }\n    }]);\n\n    return MSEController;\n}(_events2.default);\n\nexports.default = MSEController;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/mse-controller.js?")},"./src/core/report-types.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar REPORT_TYPES = exports.REPORT_TYPES = {\n    LOADER_OPEN: 'loader-open',\n    LOADER_CHUNK_ARRIVAL: 'loader-chunk-arrival',\n    MEDIA_DEMUX_FLV: 'media-demux-flv',\n    MEDIA_SEGMENT_INIT: 'media-segment-init',\n    MEDIA_INFO: 'media-info',\n    MEDIA_SEGMENT: 'media-segment',\n    PLAYING: 'playing',\n    CANPLAY: 'canplay',\n    NEW_SOURCE: 'newSource',\n    TIMEUPDATE: 'timeupdate',\n    LIVE_ADAPTIVE_QOS_STAT: 'liveAdaptiveQosStat',\n    MP_SLICE_LOAD_STAT: 'mpSliceLoadStat'\n};\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/report-types.js?")},"./src/core/transmuxer-hls-worker.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (ctx) {\n    var hls = void 0;\n    var observer = new _events2.default();\n    observer.trigger = function trigger(event) {\n        var _observer;\n\n        for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            data[_key - 1] = arguments[_key];\n        }\n\n        (_observer = observer).emit.apply(_observer, [event, event].concat(data));\n    };\n\n    observer.off = function off(event) {\n        var _observer2;\n\n        for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            data[_key2 - 1] = arguments[_key2];\n        }\n\n        (_observer2 = observer).removeListener.apply(_observer2, [event].concat(data));\n    };\n    var forwardMessage = function forwardMessage(ev, data) {\n        self.postMessage({ event: ev, data: data });\n    };\n    observer.on(_kernelEvents2.default.MANIFEST_PARSED, forwardMessage);\n    observer.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, forwardMessage);\n    observer.on(_kernelEvents2.default.HLS_FRAG_PARSED, forwardMessage);\n    observer.on(_kernelEvents2.default.ERROR, forwardMessage);\n    observer.on(_kernelEvents2.default.LEVEL_UPDATED, forwardMessage);\n    observer.on(_kernelEvents2.default.LEVEL_SWITCHED, forwardMessage);\n    observer.on(_kernelEvents2.default.LEVEL_LOADED, forwardMessage);\n    observer.on(_kernelEvents2.default.REPORT, forwardMessage);\n    observer.on(_kernelEvents2.default.END, forwardMessage);\n    observer.on(_kernelEvents2.default.PARSING_DATA, function (ev, data) {\n        var transferable = [];\n        var message = { event: ev, data: data };\n        if (data.data1) {\n            message.data1 = data.data1.buffer;\n            transferable.push(data.data1.buffer);\n            delete data.data1;\n        }\n        if (data.data2) {\n            message.data2 = data.data2.buffer;\n            transferable.push(data.data2.buffer);\n            delete data.data2;\n        }\n        self.postMessage(message, transferable);\n    });\n\n    function init(config, typeSupported) {\n        hls = new _hls2.default(observer, config, typeSupported);\n        hls.init();\n    }\n\n    function destroy() {\n        if (hls) {\n            hls.destroy();\n            hls = null;\n        }\n        if (observer) {\n            observer.removeAllListeners();\n            observer = null;\n        }\n    }\n    ctx.addEventListener('message', function (e) {\n        switch (e.data.cmd) {\n            case 'init':\n                {\n                    var config = e.data.config;\n                    var typeSupported = e.data.typeSupported;\n                    _log.Log.level(config.kwaiKernelLog);\n                    init(config, typeSupported);\n                }\n                break;\n            case 'loadSource':\n                hls.loadSource();\n                break;\n            case 'pause':\n                hls.pause();\n                break;\n            case 'seek':\n                hls.seek(e.data.data);\n                break;\n            case 'resume':\n                hls.resume();\n                break;\n            case 'destroy':\n                destroy();\n                break;\n            case 'selectBitrate':\n                hls.selectBitrate(e.data.data.bitrate, e.data.data.currentTime);\n                break;\n        }\n    });\n};\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _hls = __webpack_require__(/*! ../demux/hls/hls */ \"./src/demux/hls/hls.js\");\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _kernelEvents = __webpack_require__(/*! ./kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/transmuxer-hls-worker.js?")},"./src/core/transmuxer-hls.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ \"./node_modules/webworkify-webpack/index.js\");\n\nvar _webworkifyWebpack2 = _interopRequireDefault(_webworkifyWebpack);\n\nvar _hls = __webpack_require__(/*! ../demux/hls/hls */ \"./src/demux/hls/hls.js\");\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _kernelEvents = __webpack_require__(/*! ./kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _reportTypes = __webpack_require__(/*! ./report-types */ \"./src/core/report-types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TransmuxerHls = function (_Events) {\n    _inherits(TransmuxerHls, _Events);\n\n    function TransmuxerHls(config) {\n        _classCallCheck(this, TransmuxerHls);\n\n        var _this = _possibleConstructorReturn(this, (TransmuxerHls.__proto__ || Object.getPrototypeOf(TransmuxerHls)).call(this));\n\n        _this.tag = 'TransmuxerHls';\n        _this._config = config;\n        _this._typeSupported = {\n            mp4: MediaSource.isTypeSupported('video/mp4')\n        };\n\n        _this._config.forceKeyFrameOnDiscontinuity = false;\n\n        _this._frag = null;\n        _this._lastFrag = null;\n        _this._totalduration = 0;\n        return _this;\n    }\n\n    _createClass(TransmuxerHls, [{\n        key: 'init',\n        value: function init() {\n            if (this._config.webWorker) {\n                _log.Log.i(this.tag, 'webWorker');\n                this._w = (0, _webworkifyWebpack2.default)(/*require.resolve*/(/*! ./transmuxer-hls-worker */ \"./src/core/transmuxer-hls-worker.js\"));\n                this._onWorkerMessage = this._onWorkerMessage.bind(this);\n                this._w.addEventListener('message', this._onWorkerMessage);\n                this._w.postMessage(JSON.parse(JSON.stringify({ cmd: 'init', config: this._config, typeSupported: this._typeSupported })));\n            } else {\n                var observer = this._observer = new _events2.default();\n                observer.trigger = function trigger(event) {\n                    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                        data[_key - 1] = arguments[_key];\n                    }\n\n                    observer.emit.apply(observer, [event, event].concat(data));\n                };\n\n                observer.off = function off(event) {\n                    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                        data[_key2 - 1] = arguments[_key2];\n                    }\n\n                    observer.removeListener.apply(observer, [event].concat(data));\n                };\n                var onMessage = this._onMessage.bind(this);\n                observer.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, onMessage);\n                observer.on(_kernelEvents2.default.PARSING_DATA, onMessage);\n                observer.on(_kernelEvents2.default.ERROR, onMessage);\n                observer.on(_kernelEvents2.default.LEVEL_UPDATED, onMessage);\n                observer.on(_kernelEvents2.default.LEVEL_SWITCHED, onMessage);\n                observer.on(_kernelEvents2.default.MANIFEST_PARSED, onMessage);\n                observer.on(_kernelEvents2.default.LEVEL_LOADED, onMessage);\n                observer.on(_kernelEvents2.default.REPORT, onMessage);\n                observer.on(_kernelEvents2.default.END, onMessage);\n\n                this._hls = new _hls2.default(observer, this._config, this._typeSupported);\n                this._hls.init();\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var w = this._w;\n            if (w) {\n                w.postMessage({ cmd: 'destroy' });\n                w.removeEventListener('message', this._onWorkerMessage);\n                w.terminate();\n                this._w = null;\n            } else {\n                var hls = this._hls;\n                if (hls) {\n                    hls.destroy();\n                    this.hls = null;\n                }\n            }\n\n            var observer = this.observer;\n            if (observer) {\n                observer.removeAllListeners();\n                this.observer = null;\n            }\n        }\n    }, {\n        key: 'loadSource',\n        value: function loadSource() {\n            this.emit(_kernelEvents2.default.REPORT, {\n                type: _reportTypes.REPORT_TYPES.NEW_SOURCE,\n                index: 0,\n                sync: 0,\n                url: this._config.url\n            });\n            this.emit(_kernelEvents2.default.REPORT, { type: _reportTypes.REPORT_TYPES.LOADER_OPEN, ts: Date.now() });\n\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'loadSource' });\n            } else {\n                this._hls.loadSource();\n            }\n        }\n    }, {\n        key: 'pause',\n        value: function pause() {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'pause' });\n            } else {\n                this._hls.pause();\n            }\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'resume' });\n            } else {\n                this._hls.resume();\n            }\n        }\n    }, {\n        key: 'seek',\n        value: function seek(keyframe) {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'seek', data: keyframe.keyframetime / 1000 });\n            } else {\n                if (this._hls) {\n                    this._hls.seek(keyframe.keyframetime / 1000);\n                }\n                this._seek = true;\n            }\n        }\n    }, {\n        key: 'heartbeat',\n        value: function heartbeat() {}\n    }, {\n        key: 'getStreamTime',\n        value: function getStreamTime(time) {}\n    }, {\n        key: 'getNearestKeyframe',\n        value: function getNearestKeyframe(time) {\n            var info = this._getFragInfo(time / 1000);\n            if (info) {\n                return { keyframetime: info.start * 1000 };\n            }\n            return null;\n        }\n    }, {\n        key: 'getCurrentUrl',\n        value: function getCurrentUrl() {\n            var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var info = this._getFragInfo(time / 1000);\n            if (info) {\n                return info.url;\n            }\n            return '';\n        }\n    }, {\n        key: 'waitingBuffered',\n        value: function waitingBuffered() {}\n    }, {\n        key: 'isSeekable',\n        value: function isSeekable() {\n            return !this._config.isLive && this._fragsInfo;\n        }\n    }, {\n        key: 'getBitrates',\n        value: function getBitrates() {\n            return this._bitrates;\n        }\n    }, {\n        key: 'selectBitrate',\n        value: function selectBitrate(bitrate) {\n            var time = this._getCurrentTime();\n            if (this._config.webWorker) {\n                this._w.postMessage({\n                    cmd: 'selectBitrate',\n                    data: { bitrate: bitrate, currentTime: time / 1000 }\n                });\n            } else if (this._hls) {\n                this._hls.selectBitrate(bitrate, time / 1000);\n            }\n        }\n    }, {\n        key: 'getCurrentBitrate',\n        value: function getCurrentBitrate() {\n            if (this._currentLevel) {\n                return this._currentLevel.bitrate;\n            }\n            return 0;\n        }\n\n        /**\n         * 设置当前时间回调\n         * @param {function} fun 回调\n         */\n\n    }, {\n        key: '_getFragInfo',\n        value: function _getFragInfo(time) {\n            if (this._fragsInfo) {\n                for (var i = this._fragsInfo.length - 1; i >= 0; i--) {\n                    if (time >= this._fragsInfo[i].start) {\n                        return this._fragsInfo[i];\n                    }\n                }\n            }\n            return null;\n        }\n    }, {\n        key: '_onWorkerMessage',\n        value: function _onWorkerMessage(ev) {\n            var data = ev.data;\n            if (ev.data.event === _kernelEvents2.default.PARSING_DATA) {\n                data.data.data1 = new Uint8Array(data.data1);\n                if (data.data2) {\n                    data.data.data2 = new Uint8Array(data.data2);\n                }\n            }\n            this._onMessage(ev.data.event, data.data);\n        }\n    }, {\n        key: '_onMessage',\n        value: function _onMessage(ev, data) {\n            switch (ev) {\n                case _kernelEvents2.default.REPORT:\n                    this.emit(_kernelEvents2.default.REPORT, data);\n                    break;\n                case _kernelEvents2.default.PARSING_INIT_SEGMENT:\n                    {\n                        var mediaInfo = { hasVideo: false, hasAudio: false };\n                        if (data.tracks.video) {\n                            mediaInfo.hasVideo = true;\n                            mediaInfo.videoCodec = data.tracks.video.codec;\n                            mediaInfo.width = data.tracks.video.metadata.width;\n                            mediaInfo.height = data.tracks.video.metadata.height;\n                            mediaInfo.fps = data.tracks.video.metadata.fps;\n                        }\n                        if (data.tracks.audio) {\n                            mediaInfo.hasAudio = true;\n                            mediaInfo.audioCodec = data.tracks.audio.codec;\n                        }\n                        this.emit(_kernelEvents2.default.MEDIA_INFO, mediaInfo);\n\n                        if (mediaInfo.hasVideo) {\n                            var initVideo = { type: 'video', data: new Uint8Array(data.tracks.video.initSegment) };\n                            this.emit(_kernelEvents2.default.PARSING_INIT_SEGMENT, initVideo);\n                        }\n                        if (mediaInfo.hasAudio) {\n                            var initAudio = { type: 'audio', data: new Uint8Array(data.tracks.audio.initSegment) };\n                            this.emit(_kernelEvents2.default.PARSING_INIT_SEGMENT, initAudio);\n                        }\n                    }\n                    break;\n                case _kernelEvents2.default.PARSING_DATA:\n                    {\n                        var info = {\n                            type: _reportTypes.REPORT_TYPES.MEDIA_SEGMENT,\n                            ts: Date.now(),\n                            byteLength: data.data1.byteLength,\n                            segmentType: data.type,\n                            pts: Math.floor(data.startPTS * 1000),\n                            keyFrame: false\n                        };\n                        this.emit(_kernelEvents2.default.PARSING_DATA, { data: data.data1, type: data.type });\n                        if (data.data2) {\n                            info.byteLength += data.data2.byteLength;\n                            this.emit(_kernelEvents2.default.PARSING_DATA, { data: data.data2, type: data.type });\n                        }\n                        this.emit(_kernelEvents2.default.REPORT, info);\n                    }\n                    break;\n                case _kernelEvents2.default.LEVEL_LOADED:\n                    this._currentLevel = data;\n                    break;\n                case _kernelEvents2.default.LEVEL_UPDATED:\n                    this._fragsInfo = data;\n                    break;\n                case _kernelEvents2.default.END:\n                    this.emit(_kernelEvents2.default.END);\n                    break;\n                case _kernelEvents2.default.ERROR:\n                    this.emit(_kernelEvents2.default.ERROR, data);\n                    break;\n                case _kernelEvents2.default.LEVEL_SWITCHED:\n                    this._currentLevel = data.level;\n                    this.emit(_kernelEvents2.default.LEVEL_SWITCHED, data);\n                    break;\n                case _kernelEvents2.default.MANIFEST_PARSED:\n                    this._currentLevel = data;\n                    this._bitrates = data.bitrates;\n                    this.emit(_kernelEvents2.default.MANIFEST_PARSED, data);\n                    break;\n            }\n        }\n    }, {\n        key: 'currentTimeFun',\n        set: function set(fun) {\n            this._getCurrentTime = fun;\n        }\n    }]);\n\n    return TransmuxerHls;\n}(_events2.default);\n\nexports.default = TransmuxerHls;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/transmuxer-hls.js?")},"./src/core/transmuxer-proxy.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _transmuxer = __webpack_require__(/*! ./transmuxer */ \"./src/core/transmuxer.js\");\n\nvar _transmuxer2 = _interopRequireDefault(_transmuxer);\n\nvar _adaptiveMultiRate = __webpack_require__(/*! @ks/adaptive-multi-rate */ \"./node_modules/@ks/adaptive-multi-rate/lib/index.js\");\n\nvar _adaptiveMultiRate2 = _interopRequireDefault(_adaptiveMultiRate);\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _reportTypes = __webpack_require__(/*! ./report-types */ \"./src/core/report-types.js\");\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _urlParse = __webpack_require__(/*! url-parse */ \"./node_modules/url-parse/index.js\");\n\nvar _urlParse2 = _interopRequireDefault(_urlParse);\n\nvar _kernelEvents = __webpack_require__(/*! ./kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * 封装transmuxer，处理自动清晰度逻辑\n */\nvar TransmuxerProxy = function (_Events) {\n    _inherits(TransmuxerProxy, _Events);\n\n    function TransmuxerProxy(config) {\n        _classCallCheck(this, TransmuxerProxy);\n\n        var _this = _possibleConstructorReturn(this, (TransmuxerProxy.__proto__ || Object.getPrototypeOf(TransmuxerProxy)).call(this));\n\n        _this.tag = 'transmuxerProxy';\n        _this._config = {};\n        Object.assign(_this._config, config);\n        // this._config = config;\n        _this._representationIndex = 0;\n\n        // segment缓存\n        _this._segmentCache = null;\n        // segment缓存最大值\n        _this.MAX_CACHE_LEN = 300;\n\n        // 每2s上报一次自适应码率日志，目前公用heartbeat计时器\n        _this._qosStatInterval = 2;\n        _this._qosStatIntervalCount = 0;\n        _this._currentGopDuration = 0;\n\n        // 传递给AdaptiveMultiRate的最近下载量（不重复）\n        _this._downloadSize = 0;\n        _this._downloadStartTime = Date.now();\n\n        _this._referenceTime = {\n            dtsA: 0, // 最新audio dts\n            dtsAStream: 0, // 最新audio dts对应的stream dts\n            dtsV: 0, // 最新video dts\n            refA: 0, // 最新可用于切换参照的audio dts\n            refV: 0, // 最新可用于切换参照的video dts\n            refTime: 0, // 流切换参照时间\n            requestStartTime: 0 // URL请求时间\n        };\n\n        _this._bitrates = [];\n        // 当前流收到I帧计数\n        _this._keyCount = 0;\n        return _this;\n    }\n\n    _createClass(TransmuxerProxy, [{\n        key: 'init',\n        value: function init() {\n            this._initMultiRate();\n            this._currentTransmuxer = new _transmuxer2.default(this._config);\n            this._transmuxerEvent(this._currentTransmuxer);\n            if (!this._config.multipart) {\n                this._currentUrl = this._config.src;\n            }\n        }\n    }, {\n        key: 'loadSource',\n        value: function loadSource() {\n            this.emit(_kernelEvents2.default.REPORT, {\n                type: _reportTypes.REPORT_TYPES.NEW_SOURCE,\n                index: this._representationIndex,\n                sync: this._referenceTime.refTime || 0,\n                url: this._config.url\n            });\n            this._currentTransmuxer.loadSource();\n        }\n\n        /**\n         * 设置获取video buffer长度的回调方法\n         * @param {function} fun 回调\n         */\n\n    }, {\n        key: 'testNextResolution',\n\n\n        /**\n         * test 手动切换测试\n         * @param {Number} value index变化值\n         */\n        value: function testNextResolution(value) {\n            var i = (this._representationIndex + value + this._manifest.adaptationSet.representation.length) % this._manifest.adaptationSet.representation.length;\n            this._changeResolution(i);\n        }\n\n        /**\n         * 获取当前buffer长度\n         * @private\n         * @returns {Number} buffer 毫秒\n         */\n\n    }, {\n        key: '_getBufferedLength',\n        value: function _getBufferedLength() {\n            if (this._bufferedLength) {\n                var cached = 0;\n                if (this._segmentCache) {\n                    cached = this._segmentCache.endDts - this._segmentCache.dts;\n                }\n                return this._bufferedLength() + cached;\n            }\n            return NaN;\n        }\n\n        /**\n         * 抛出所有cache数据\n         * @private\n         */\n\n    }, {\n        key: '_flushSegmentCache',\n        value: function _flushSegmentCache() {\n            if (this._segmentCache) {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this._segmentCache.cache[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var cache = _step.value;\n\n                        this.emit(_kernelEvents2.default.PARSING_DATA, cache);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                this._segmentCache = null;\n            }\n        }\n\n        /**\n         * 切换清晰度\n         * @param {number} index 清晰度index\n         * @private\n         */\n\n    }, {\n        key: '_changeResolution',\n        value: function _changeResolution(index) {\n            var config = {};\n            // 清空卡顿缓存\n            this._flushSegmentCache();\n            if (this._manifest && this._manifest.adaptationSet.representation.length > index && index !== this._representationIndex) {\n                var time = this._referenceTime;\n                this._representationIndex = index;\n                this._keyCount = 0;\n                Object.assign(config, this._config);\n                config.src = this._manifest.adaptationSet.representation[index].url;\n\n                // 回收当前流处理器\n                this._currentTransmuxer.destroy();\n                this._unbindTransmuxerEvent(this._currentTransmuxer);\n\n                config.src = this._handleRequestUrl(config.src, time.requestStartTime);\n                this._currentUrl = config.src;\n\n                time.refTime = Math.min(time.refA, time.refV);\n                // 新流处理器\n                config.alignBase = time.refTime || 0;\n                this._currentTransmuxer = new _transmuxer2.default(config);\n                this._transmuxerEvent(this._currentTransmuxer);\n                this._currentTransmuxer.loadSource();\n                this._adaptiveQosStat.playStartTime = Date.now();\n\n                _log.Log.v('changeResolution', time.refTime);\n                // 抛出切换清晰度事件\n                this.emit(_kernelEvents2.default.REPORT, {\n                    type: _reportTypes.REPORT_TYPES.NEW_SOURCE,\n                    index: index,\n                    sync: time.refTime || 0,\n                    url: this._config.url\n                });\n                this.emit(_kernelEvents2.default.LEVEL_SWITCHED, {\n                    bitrate: this._manifest.adaptationSet.representation[index].bitrate,\n                    smooth: true\n                });\n            } else {\n                return;\n            }\n        }\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this._currentTransmuxer.pause();\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this._currentTransmuxer.resume();\n        }\n    }, {\n        key: 'seek',\n        value: function seek(keyframe) {\n            this._currentTransmuxer.seek(keyframe);\n        }\n    }, {\n        key: 'isSeekable',\n        value: function isSeekable() {\n            return this._currentTransmuxer.isSeekable();\n        }\n    }, {\n        key: 'getNearestKeyframe',\n        value: function getNearestKeyframe(times) {\n            return this._currentTransmuxer.getNearestKeyframe(times);\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._unbindTransmuxerEvent(this._currentTransmuxer);\n            this._currentTransmuxer.destroy();\n            this._currentTransmuxer = null;\n            this._destroyAdaptiveMultiRate();\n            this.segmentCache = null;\n        }\n\n        /**\n         * 设置一个缓冲时间，攒够设置长度的segment后再抛出数据\n         * @param {number} bufferedMillis 缓存时间\n         */\n\n    }, {\n        key: 'waitingBuffered',\n        value: function waitingBuffered(bufferedMillis) {\n            this._segmentCache = { cache: [], dts: 0, endDts: 0, needBufferLen: bufferedMillis };\n        }\n\n        /**\n         * 返回播放时间对应的流时间\n         * @param {number} time 播放时间\n         * @returns {number} 流时间\n         */\n\n    }, {\n        key: 'getStreamTime',\n        value: function getStreamTime(time) {\n            var times = this._referenceTime;\n            if (times) {\n                return time - times.dtsA + times.dtsAStream;\n            }\n            return NaN;\n        }\n    }, {\n        key: 'getCurrentUrl',\n        value: function getCurrentUrl() {\n            var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            if (this._config.multipart) {\n                var i = 0;\n                for (i = 0; i < this._config.src.segments.length; i++) {\n                    if (this._config.src.segments[i].time > ms) {\n                        break;\n                    }\n                }\n                return this._config.src.segments[Math.max(0, i - 1)].url;\n            }\n            return this._currentUrl;\n        }\n    }, {\n        key: 'heartbeat',\n        value: function heartbeat() {\n            if (this._multiRateAdaption) {\n                var info = this._getBufferedInfo();\n                this._multiRateAdaption.heartbeatReport(info);\n                if (this._qosStatIntervalCount % this._qosStatInterval === 0) {\n                    this._sendAdaptiveQosStat();\n                }\n                this._qosStatIntervalCount = (this._qosStatIntervalCount + 1) % this._qosStatInterval;\n            }\n        }\n    }, {\n        key: 'getCurrentBitrate',\n        value: function getCurrentBitrate() {\n            if (this._bitrates.length) {\n                return this._bitrates[this._representationIndex];\n            }\n            return null;\n        }\n    }, {\n        key: 'getBitrates',\n        value: function getBitrates() {\n            return this._bitrates;\n        }\n    }, {\n        key: 'selectBitrate',\n        value: function selectBitrate(value) {\n            if (value <= 0) {\n                this._createAdaptiveMultiRate();\n            } else if (this._bitrates.length) {\n                this._destroyAdaptiveMultiRate();\n                for (var i = this._bitrates.length - 1; i >= 0; i--) {\n                    if (this._bitrates[i] <= value) {\n                        this._changeResolution(i);\n                        return;\n                    }\n                }\n            }\n        }\n\n        /**\n         * 进行Transmuxer事件绑定\n         * @param {Transmuxer} transmuxer 转封装器\n         * @private\n         */\n\n    }, {\n        key: '_transmuxerEvent',\n        value: function _transmuxerEvent(transmuxer) {\n            var _this2 = this;\n\n            transmuxer.on(_kernelEvents2.default.PARSING_DATA, function (data) {\n                data.data = new Uint8Array(data.data);\n                _this2.emit(_kernelEvents2.default.REPORT, {\n                    type: _reportTypes.REPORT_TYPES.MEDIA_SEGMENT,\n                    byteLength: data.data.byteLength,\n                    ts: Date.now(),\n                    segmentType: data.type,\n                    pts: data.info.startPts,\n                    keyFrame: !!data.info.key\n                });\n\n                if (data.type === 'audio') {\n                    _this2._referenceTime.dtsA = data.info.endDts;\n                    _this2._referenceTime.dtsAStream = data.info.streamDts;\n                } else if (data.type === 'video') {\n                    _this2._referenceTime.dtsV = data.info.endDts;\n                }\n\n                // 是否需要攒buffer\n                if (_this2._segmentCache) {\n                    _this2._segmentCache.dts = _this2._segmentCache.dts || data.info.startDts;\n                    _this2._segmentCache.endDts = data.info.endDts;\n                    // 判断buffer达到上限或者已满足条件\n                    if (_this2._segmentCache.endDts - _this2._segmentCache.dts < _this2._segmentCache.needBufferLen && _this2._segmentCache.cache.length < _this2.MAX_CACHE_LEN) {\n                        _this2._segmentCache.cache.push({ type: data.type, data: data.data });\n                    } else {\n                        _this2._segmentCache.cache.push({ type: data.type, data: data.data });\n                        _log.Log.i(_this2.tag, 'segment buffered：', _this2._segmentCache.needBufferLen);\n                        _this2._flushSegmentCache();\n                    }\n                }\n                _this2.emit(_kernelEvents2.default.PARSING_DATA, { type: data.type, data: data.data });\n            });\n            transmuxer.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, function (data) {\n                _this2.emit(_kernelEvents2.default.PARSING_INIT_SEGMENT, data);\n            });\n            transmuxer.on(_kernelEvents2.default.ERROR, function (errorMessage) {\n                _this2.emit(_kernelEvents2.default.ERROR, errorMessage);\n            });\n            transmuxer.on(_kernelEvents2.default.END, function (data) {\n                _this2.emit(_kernelEvents2.default.END, data);\n            });\n            transmuxer.on(_kernelEvents2.default.MEDIA_INFO, function (mediaInfo) {\n                _this2.emit(_kernelEvents2.default.MEDIA_INFO, mediaInfo);\n            });\n            transmuxer.on(_kernelEvents2.default.REPORT, function (data) {\n                if (data.type === _reportTypes.REPORT_TYPES.LOADER_CHUNK_ARRIVAL) {\n                    _this2._downloadSize += data.byteLength;\n                }\n                _this2.emit(_kernelEvents2.default.REPORT, data);\n            });\n            transmuxer.on(_kernelEvents2.default.SCRIPT_PARSED, this._processScriptData.bind(this));\n            transmuxer.on(_kernelEvents2.default.LOST_FRAMES, function (data) {\n                _this2.emit(_kernelEvents2.default.LOST_FRAMES, data);\n            });\n            transmuxer.on(_kernelEvents2.default.IDR, function () {\n                _this2._keyCount++;\n                var t = _this2._referenceTime;\n                t.refA = t.dtsA;\n                t.refV = t.dtsV;\n                t.requestStartTime = t.dtsAStream;\n\n                if (_this2._multiRateAdaption && _this2._keyCount > 1) {\n                    var info = _this2._getBufferedInfo();\n                    var index = _this2._multiRateAdaption.nextBitrateIndex(info);\n                    if (index !== _this2._representationIndex) {\n                        _this2._changeResolution(index);\n                    }\n                }\n            });\n        }\n\n        /**\n         * 处理script tag中的数据\n         * @param {object} data script tag数据\n         * @private\n         */\n\n    }, {\n        key: '_processScriptData',\n        value: function _processScriptData(data) {\n            if (data.hasOwnProperty('onMetadata')) {\n                this.emit(_kernelEvents2.default.SCRIPT_PARSED, data);\n            }\n        }\n\n        /**\n         * 解除transmuxer事件绑定\n         * @param {Transmuxer} transmuxer 转封装器\n         * @private\n         */\n\n    }, {\n        key: '_unbindTransmuxerEvent',\n        value: function _unbindTransmuxerEvent(transmuxer) {\n            transmuxer.removeAllListeners();\n        }\n\n        /**\n         * 处理请求url\n         * @param {string} url 请求地址\n         * @param {number} startTime 偏移量\n         * @returns {string} 拼接完成的url\n         */\n\n    }, {\n        key: '_handleRequestUrl',\n        value: function _handleRequestUrl(url, startTime) {\n            var urlparse = new _urlParse2.default(url, true);\n            /* eslint-disable */\n            urlparse.query.ks_start_time = startTime;\n            /* eslint-enable */\n            return urlparse.toString();\n        }\n    }, {\n        key: '_createAdaptiveMultiRate',\n        value: function _createAdaptiveMultiRate() {\n            var _this3 = this;\n\n            var first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (!this._adaptiveMultiRate || this._multiRateAdaption) {\n                return;\n            }\n            this._multiRateAdaption = new _adaptiveMultiRate2.default(this._manifest, this._config.liveAdaptiveConfig, first ? null : {\n                index: this._representationIndex,\n                buffer: this._getBufferedLength() || 0\n            });\n            this._multiRateAdaption.on('adaptiveAlgorithm', function (e) {\n                return _this3.emit('adaptiveAlgorithm', e);\n            });\n        }\n    }, {\n        key: '_destroyAdaptiveMultiRate',\n        value: function _destroyAdaptiveMultiRate() {\n            if (this._multiRateAdaption) {\n                this._multiRateAdaption.removeAllListeners();\n                this._multiRateAdaption = null;\n            }\n        }\n    }, {\n        key: '_initMultiRate',\n        value: function _initMultiRate() {\n            this._manifest = this._config.manifest;\n            this._adaptiveMultiRate = this._config.adaptiveMultiRate;\n\n            if (this._adaptiveMultiRate) {\n                this._manifest.adaptationSet.representation.sort(function (a, b) {\n                    return a.bitrate - b.bitrate;\n                });\n                this._bitrates = [];\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = this._manifest.adaptationSet.representation[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var representation = _step2.value;\n\n                        this._bitrates.push(representation.bitrate);\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n\n                if (this._config.bitrateStart) {\n                    for (var i = this._bitrates.length - 1; i >= 0; i--) {\n                        if (this._bitrates[i] <= this._config.bitrateStart) {\n                            this._representationIndex = i;\n                            break;\n                        }\n                    }\n                } else {\n                    this._createAdaptiveMultiRate(true);\n                    this._representationIndex = this._multiRateAdaption.nextBitrateIndex({\n                        buffered: 0,\n                        details: [],\n                        download: { size: 0, duration: 0 }\n                    }) || 0;\n                }\n                this._config.src = this._handleRequestUrl(this._manifest.adaptationSet.representation[this._representationIndex].url, this._referenceTime.requestStartTime);\n                this._adaptiveQosStat = {};\n                this._adaptiveQosStat.playStartTime = this._adaptiveQosStat.tickStart = Date.now();\n            }\n        }\n\n        /**\n         * 抛出自适应码率数据上报事件\n         * @private\n         */\n\n    }, {\n        key: '_sendAdaptiveQosStat',\n        value: function _sendAdaptiveQosStat() {\n            var algorithmQos = this._multiRateAdaption.getQos();\n            _log.Log.v('alg::qos', algorithmQos);\n            /* eslint-disable */\n            var data = _extends({\n                type: _reportTypes.REPORT_TYPES.LIVE_ADAPTIVE_QOS_STAT,\n                play_url: this._currentUrl,\n                play_start_time: this._adaptiveQosStat.playStartTime,\n                tick_start: this._adaptiveQosStat.tickStart,\n                current_gop_duration: this._currentGopDuration,\n                buffer_time: Math.floor(this._getBufferedLength())\n            }, algorithmQos);\n            /* eslint-enable */\n            this._adaptiveQosStat.tickStart = Date.now();\n            this.emit(_kernelEvents2.default.REPORT, data);\n        }\n\n        /**\n         * 获取buffer信息，buffer中的Gop信息\n         * @returns {object} buffer信息\n         * @private\n         */\n\n    }, {\n        key: '_getBufferedInfo',\n        value: function _getBufferedInfo() {\n            var info = {\n                currentTime: Math.floor(this._getCurrentTime()),\n                buffered: Math.floor(this._getBufferedLength()),\n                download: { size: this._downloadSize, duration: Date.now() - this._downloadStartTime }\n            };\n            this._downloadStartTime = Date.now();\n            this._downloadSize = 0;\n            return info;\n        }\n    }, {\n        key: 'bufferedLengthFun',\n        set: function set(fun) {\n            this._bufferedLength = fun;\n        }\n\n        /**\n         * 设置当前时间回调\n         * @param {function} fun 回调\n         */\n\n    }, {\n        key: 'currentTimeFun',\n        set: function set(fun) {\n            this._getCurrentTime = fun;\n        }\n    }]);\n\n    return TransmuxerProxy;\n}(_events2.default);\n\nexports.default = TransmuxerProxy;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/transmuxer-proxy.js?")},"./src/core/transmuxer-worker.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (ctx) {\n    var flv = void 0;\n\n    var observer = this._observer = new _events2.default();\n    observer.trigger = function trigger(event) {\n        var _observer;\n\n        for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            data[_key - 1] = arguments[_key];\n        }\n\n        (_observer = observer).emit.apply(_observer, [event, event].concat(data));\n    };\n\n    observer.off = function off(event) {\n        var _observer2;\n\n        for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            data[_key2 - 1] = arguments[_key2];\n        }\n\n        (_observer2 = observer).removeListener.apply(_observer2, [event].concat(data));\n    };\n    var forwardMessage = function forwardMessage(ev, data) {\n        self.postMessage({ event: ev, data: data });\n    };\n    observer.on(_kernelEvents2.default.METADATA, forwardMessage);\n    observer.on(_kernelEvents2.default.MEDIA_INFO, forwardMessage);\n    observer.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, forwardMessage);\n    observer.on(_kernelEvents2.default.ERROR, forwardMessage);\n    observer.on(_kernelEvents2.default.SCRIPT_PARSED, forwardMessage);\n    observer.on(_kernelEvents2.default.LOST_FRAMES, forwardMessage);\n    observer.on(_kernelEvents2.default.REPORT, forwardMessage);\n    observer.on(_kernelEvents2.default.IDR, forwardMessage);\n    observer.on(_kernelEvents2.default.END, forwardMessage);\n    observer.on(_kernelEvents2.default.PARSING_DATA, function (ev, data) {\n        var transferable = [];\n        var message = { event: ev, data: data };\n        if (data.data1) {\n            message.data1 = data.data1.buffer;\n            transferable.push(data.data1.buffer);\n            delete data.data1;\n        }\n        if (data.data2) {\n            message.data2 = data.data2.buffer;\n            transferable.push(data.data2.buffer);\n            delete data.data2;\n        }\n        self.postMessage(message, transferable);\n    });\n\n    function init(config) {\n        flv = new _flv2.default(observer, config);\n        flv.init();\n    }\n\n    function destroy() {\n        if (flv) {\n            flv.destroy();\n            flv = null;\n        }\n        if (observer) {\n            observer.removeAllListeners();\n            observer = null;\n        }\n    }\n\n    ctx.addEventListener('message', function (e) {\n        switch (e.data.cmd) {\n            case 'init':\n                {\n                    var config = e.data.config;\n                    _log.Log.level(config.kwaiKernelLog);\n                    init(config);\n                }\n                break;\n            case 'loadSource':\n                flv.loadSource();\n                break;\n            case 'pause':\n                flv.pause();\n                break;\n            case 'seek':\n                flv.seek(e.data.keyframe);\n                break;\n            case 'resume':\n                flv.resume();\n                break;\n            case 'destroy':\n                destroy();\n                break;\n            case 'switchStream':\n                flv.switchStream(e.data.data);\n                break;\n        }\n    });\n};\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _kernelEvents = __webpack_require__(/*! ./kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _flv = __webpack_require__(/*! ../demux/flv/flv */ \"./src/demux/flv/flv.js\");\n\nvar _flv2 = _interopRequireDefault(_flv);\n\n__webpack_require__(/*! ../utils/polyfill */ \"./src/utils/polyfill.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/transmuxer-worker.js?")},"./src/core/transmuxer.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ \"./node_modules/webworkify-webpack/index.js\");\n\nvar _webworkifyWebpack2 = _interopRequireDefault(_webworkifyWebpack);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _reportTypes = __webpack_require__(/*! ./report-types */ \"./src/core/report-types.js\");\n\nvar _kernelEvents = __webpack_require__(/*! ./kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _kernelErrors = __webpack_require__(/*! ./kernel-errors */ \"./src/core/kernel-errors.js\");\n\nvar _flv = __webpack_require__(/*! ../demux/flv/flv */ \"./src/demux/flv/flv.js\");\n\nvar _flv2 = _interopRequireDefault(_flv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Transmuxer controller\n * @class Transmuxer\n * @param {object} config 配置\n */\nvar Transmuxer = function (_Events) {\n    _inherits(Transmuxer, _Events);\n\n    function Transmuxer(config) {\n        _classCallCheck(this, Transmuxer);\n\n        var _this = _possibleConstructorReturn(this, (Transmuxer.__proto__ || Object.getPrototypeOf(Transmuxer)).call(this));\n\n        _this.tag = 'transmuxer';\n        _this._config = config || {};\n        if (_this._config.multipart) {\n            _this._keyframesIndex = _this._config.src.keyframesIndex;\n        }\n        _this._keyframePoint = false;\n        _this._w = null;\n\n        var observer = _this._observer = new _events2.default();\n        observer.trigger = function trigger(event) {\n            for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                data[_key - 1] = arguments[_key];\n            }\n\n            observer.emit.apply(observer, [event, event].concat(data));\n        };\n\n        observer.off = function off(event) {\n            for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                data[_key2 - 1] = arguments[_key2];\n            }\n\n            observer.removeListener.apply(observer, [event].concat(data));\n        };\n        var onMessage = _this._onMessage.bind(_this);\n        observer.on(_kernelEvents2.default.METADATA, onMessage);\n        observer.on(_kernelEvents2.default.MEDIA_INFO, onMessage);\n        observer.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, onMessage);\n        observer.on(_kernelEvents2.default.PARSING_DATA, onMessage);\n        observer.on(_kernelEvents2.default.ERROR, onMessage);\n        observer.on(_kernelEvents2.default.SCRIPT_PARSED, onMessage);\n        observer.on(_kernelEvents2.default.LOST_FRAMES, onMessage);\n        observer.on(_kernelEvents2.default.REPORT, onMessage);\n        observer.on(_kernelEvents2.default.IDR, onMessage);\n\n        if (_this._config.webWorker) {\n            _log.Log.i(_this.tag, 'webWorker');\n            _this._onWorkMessage = _this._onWorkMessage.bind(_this);\n            _this._w = (0, _webworkifyWebpack2.default)(/*require.resolve*/(/*! ./transmuxer-worker */ \"./src/core/transmuxer-worker.js\"));\n            _this._w.addEventListener('message', _this._onWorkMessage);\n            _this._w.postMessage(JSON.parse(JSON.stringify({ cmd: 'init', config: config })));\n        } else {\n            _this._flv = new _flv2.default();\n            _this._flv.init();\n        }\n        return _this;\n    }\n\n    _createClass(Transmuxer, [{\n        key: '_onWorkMessage',\n        value: function _onWorkMessage(ev) {\n            var data = ev.data;\n            if (ev.data.event === _kernelEvents2.default.PARSING_DATA) {\n                data.data.data1 = new Uint8Array(data.data1);\n                if (data.data2) {\n                    data.data.data2 = new Uint8Array(data.data2);\n                }\n            }\n            this._onMessage(ev.data.event, data.data);\n        }\n    }, {\n        key: 'switchStream',\n        value: function switchStream(data) {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'switchStream', data: data });\n            } else {\n                this._flv.switchStream(data);\n            }\n        }\n\n        /**\n         * instance ioloader\n         */\n\n    }, {\n        key: 'loadSource',\n        value: function loadSource() {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'loadSource' });\n            } else {\n                this._flv.loadSource();\n            }\n        }\n    }, {\n        key: '_onMessage',\n        value: function _onMessage(ev, data) {\n            switch (ev) {\n                case _kernelEvents2.default.MEDIA_INFO:\n                    this._mediaInfo = data;\n                    this.emit(_kernelEvents2.default.MEDIA_INFO, data);\n                    break;\n                case _kernelEvents2.default.PARSING_INIT_SEGMENT:\n                    if (Array.isArray(data)) {\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var initSeg = _step.value;\n\n                                this.emit(_kernelEvents2.default.PARSING_INIT_SEGMENT, initSeg);\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                case _kernelEvents2.default.PARSING_DATA:\n                    {\n                        var info = {\n                            type: _reportTypes.REPORT_TYPES.MEDIA_SEGMENT,\n                            ts: Date.now(),\n                            byteLength: data.data1.byteLength,\n                            segmentType: data.type,\n                            pts: Math.floor(data.startPTS * 1000),\n                            keyFrame: false,\n                            streamDts: data.streamDTS * 1000,\n                            endStreamDts: Math.floor(data.endStreamDts * 1000),\n                            startPts: Math.floor(data.startPTS * 1000),\n                            startDts: Math.floor(data.startDTS * 1000),\n                            endDts: Math.floor(data.endDTS * 1000),\n                            key: !!data.key\n                        };\n                        if (data.data2) {\n                            info.byteLength += data.data2.byteLength;\n                            this.emit(_kernelEvents2.default.PARSING_DATA, {\n                                data: this._mergeBoxes(data.data1, data.data2),\n                                type: data.type,\n                                info: info\n                            });\n                        } else {\n                            this.emit(_kernelEvents2.default.PARSING_DATA, { data: data.data1, type: data.type, info: info });\n                        }\n                        this.emit(_kernelEvents2.default.REPORT, info);\n                    }\n                    break;\n                case _kernelEvents2.default.LOST_FRAMES:\n                    this.emit(_kernelEvents2.default.LOST_FRAMES, data);\n                    break;\n                case _kernelEvents2.default.SCRIPT_PARSED:\n                    this.emit(_kernelEvents2.default.SCRIPT_PARSED, data);\n                    break;\n                case _kernelEvents2.default.REPORT:\n                    this.onReport(data);\n                    break;\n                case _kernelEvents2.default.IDR:\n                    this.emit(_kernelEvents2.default.IDR);\n                    break;\n                case _kernelEvents2.default.ERROR:\n                    this.emit(_kernelEvents2.default.ERROR, data);\n                    break;\n                case _kernelEvents2.default.END:\n                    this.emit(_kernelEvents2.default.END);\n                    break;\n            }\n        }\n    }, {\n        key: '_mergeBoxes',\n        value: function _mergeBoxes(moof, mdat) {\n            var result = new Uint8Array(moof.byteLength + mdat.byteLength);\n            result.set(moof, 0);\n            result.set(mdat, moof.byteLength);\n            return result;\n        }\n    }, {\n        key: '_discontinuityCallback',\n        value: function _discontinuityCallback(baseTime) {\n            this._baseTime = baseTime;\n            this._discontinuity = true;\n        }\n    }, {\n        key: 'onReport',\n        value: function onReport(data) {\n            if (data.type === 'demux') {\n                this.emit(_kernelEvents2.default.REPORT, {\n                    type: _reportTypes.REPORT_TYPES.MEDIA_DEMUX_FLV,\n                    ts: data.ts\n                });\n            } else {\n                this.emit(_kernelEvents2.default.REPORT, data);\n            }\n        }\n\n        /**\n         * stop loader\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'pause' });\n            } else {\n                this._flv.pause();\n            }\n        }\n\n        /**\n         * resume loader\n         */\n\n    }, {\n        key: 'resume',\n        value: function resume() {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'resume' });\n            } else {\n                this._flv.resume();\n            }\n        }\n        /**\n         * flv can seek\n         * @returns {boolean} 是否可seek\n         */\n\n    }, {\n        key: 'isSeekable',\n        value: function isSeekable() {\n            return !!this._keyframesIndex;\n        }\n        /**\n         * video seek\n         * @param {object} keyframe 关键帧集合\n         */\n\n    }, {\n        key: 'seek',\n        value: function seek(keyframe) {\n            if (!this.isSeekable()) {\n                this.emit(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                    details: _kernelErrors.ErrorDetails.CANNOT_SEEK,\n                    fatal: true,\n                    reason: 'can not seek'\n                });\n                return;\n            }\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'seek', keyframe: keyframe });\n            } else {\n                this._flv.seek(keyframe);\n            }\n        }\n\n        /**\n         * destroy\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this._config.webWorker) {\n                this._w.postMessage({ cmd: 'destroy' });\n                this._w.removeEventListener('message', this._onWorkMessage);\n                this._w.terminate();\n            }\n            if (this._flv) {\n                this._flv = null;\n            }\n\n            var observer = this._observer;\n            if (observer) {\n                observer.removeAllListeners();\n                this._observer = null;\n            }\n        }\n\n        /**\n         * get nearlest keyframe binary search\n         * @param {Number} times time\n         * @returns {object} 关键帧信息\n         */\n\n    }, {\n        key: 'getNearestKeyframe',\n        value: function getNearestKeyframe(times) {\n            if (this._keyframesIndex) {\n                var keyframesList = this._keyframesIndex.times;\n                var keyframesPositions = this._keyframesIndex.filepositions;\n                var binarySearch = function binarySearch(list, val) {\n                    var length = list.length;\n                    var index = Math.floor(length / 2);\n                    if (length === 1) {\n                        var _position = keyframesList.indexOf(list[0]);\n                        return {\n                            keyframetime: list[0],\n                            keyframePoint: keyframesPositions[_position]\n                        };\n                    } else if (list[index] > val) {\n                        return binarySearch(list.slice(0, index), val);\n                    } else if (list[index] < val) {\n                        return binarySearch(list.slice(index), val);\n                    }\n                    var position = keyframesList.indexOf(list[0]);\n                    return {\n                        keyframetime: list[0],\n                        keyframePoint: keyframesPositions[position]\n                    };\n                };\n                return binarySearch(keyframesList, times);\n            }\n            return 0;\n        }\n    }]);\n\n    return Transmuxer;\n}(_events2.default);\n\nexports.default = Transmuxer;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/core/transmuxer.js?")},"./src/demux/adts.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getAudioConfig = getAudioConfig;\nexports.isHeaderPattern = isHeaderPattern;\nexports.getHeaderLength = getHeaderLength;\nexports.getFullFrameLength = getFullFrameLength;\nexports.isHeader = isHeader;\nexports.probe = probe;\nexports.initTrackConfig = initTrackConfig;\nexports.getFrameDuration = getFrameDuration;\nexports.parseFrameHeader = parseFrameHeader;\nexports.appendFrame = appendFrame;\n\nvar _kernelEvents = __webpack_require__(/*! ../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _kernelErrors = __webpack_require__(/*! ../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n    var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'hls';\n\n    var adtsObjectType = void 0,\n        // :int\n    adtsSampleingIndex = void 0,\n        // :int\n    adtsExtensionSampleingIndex = void 0,\n        // :int\n    adtsChanelConfig = void 0,\n        // :int\n    config = void 0,\n        userAgent = navigator.userAgent.toLowerCase(),\n        manifestCodec = audioCodec,\n        adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    // byte 2\n    if (type === 'flv') {\n        // debugger;\n        // 5 bits\n        adtsObjectType = data[offset + 2] >>> 3;\n        // 4 bits\n        adtsSampleingIndex = (data[offset + 2] & 0x07) << 1 | data[offset + 3] >>> 7;\n        if (adtsSampleingIndex < 0 || adtsSampleingIndex >= adtsSampleingRates.length) {\n            observer.trigger(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: 'invalid ADTS sampling index:' + adtsSampleingIndex\n            });\n            return;\n        }\n\n        // 4 bits\n        adtsChanelConfig = (data[offset + 3] & 0x78) >>> 3;\n        if (adtsChanelConfig < 0 || adtsChanelConfig >= 8) {\n            observer.trigger(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: 'invalid ADTS sampling index:' + adtsSampleingIndex\n            });\n            return;\n        }\n    } else {\n        adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n        adtsSampleingIndex = (data[offset + 2] & 0x3c) >>> 2;\n        if (adtsSampleingIndex > adtsSampleingRates.length - 1) {\n            observer.trigger(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: 'invalid ADTS sampling index:' + adtsSampleingIndex\n            });\n            return;\n        }\n        adtsChanelConfig = (data[offset + 2] & 0x01) << 2;\n        // byte 3\n        adtsChanelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n    }\n    _log.Log.v('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);\n    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n    if (/firefox/i.test(userAgent)) {\n        if (adtsSampleingIndex >= 6) {\n            adtsObjectType = 5;\n            config = new Array(4);\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n        } else {\n            adtsObjectType = 2;\n            config = new Array(2);\n            adtsExtensionSampleingIndex = adtsSampleingIndex;\n        }\n        // Android : always use AAC\n    } else if (userAgent.indexOf('android') !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSampleingIndex = adtsSampleingIndex;\n    } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n        */\n        adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;\n        } else {\n            // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n            // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n            if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {\n                adtsObjectType = 2;\n                config = new Array(2);\n            }\n            adtsExtensionSampleingIndex = adtsSampleingIndex;\n        }\n    }\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n    sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n    */\n    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    config[0] = adtsObjectType << 3;\n    // samplingFrequencyIndex\n    config[0] |= (adtsSampleingIndex & 0x0e) >> 1;\n    config[1] |= (adtsSampleingIndex & 0x01) << 7;\n    // channelConfiguration\n    config[1] |= adtsChanelConfig << 3;\n    if (adtsObjectType === 5) {\n        // adtsExtensionSampleingIndex\n        config[1] |= (adtsExtensionSampleingIndex & 0x0e) >> 1;\n        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n    }\n    return {\n        config: config,\n        samplerate: adtsSampleingRates[adtsSampleingIndex],\n        channelCount: adtsChanelConfig,\n        codec: 'mp4a.40.' + adtsObjectType,\n        manifestCodec: manifestCodec\n    };\n} /**\n   *  ADTS parser helper\n   */\nfunction isHeaderPattern(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\n\nfunction getHeaderLength(data, offset) {\n    return data[offset + 1] & 0x01 ? 7 : 9;\n}\n\nfunction getFullFrameLength(data, offset) {\n    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\n\nfunction isHeader(data, offset) {\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction probe(data, offset) {\n    // same as isHeader but we also check that ADTS frame follows last ADTS frame\n    // or end of data is reached\n    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n        // ADTS header Length\n        var headerLength = getHeaderLength(data, offset);\n        // ADTS frame Length\n        var frameLength = headerLength;\n        if (offset + 5 < data.length) {\n            frameLength = getFullFrameLength(data, offset);\n        }\n\n        var newOffset = offset + frameLength;\n        if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction initTrackConfig(track, observer, data, offset, audioCodec, type) {\n    if (!track.samplerate) {\n        var config = getAudioConfig(observer, data, offset, audioCodec, type);\n        track.config = config.config;\n        track.samplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        _log.Log.v('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);\n    }\n}\n\nfunction getFrameDuration(samplerate) {\n    return 1024 * 90000 / samplerate;\n}\n\nfunction parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {\n    var headerLength = void 0,\n        frameLength = void 0,\n        stamp = void 0;\n    var length = data.length;\n\n    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n    headerLength = getHeaderLength(data, offset);\n    // retrieve frame size\n    frameLength = getFullFrameLength(data, offset);\n    frameLength -= headerLength;\n\n    if (frameLength > 0 && offset + headerLength + frameLength <= length) {\n        stamp = pts + frameIndex * frameDuration;\n        // Log.v(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n        return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };\n    }\n\n    return undefined;\n}\n\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n    var frameDuration = getFrameDuration(track.samplerate);\n    var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);\n    if (header) {\n        var stamp = header.stamp;\n        var headerLength = header.headerLength;\n        var frameLength = header.frameLength;\n\n        // Log.v(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n        var aacSample = {\n            unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),\n            pts: stamp,\n            dts: stamp\n        };\n\n        track.samples.push(aacSample);\n        track.len += frameLength;\n\n        return { sample: aacSample, length: frameLength + headerLength };\n    }\n\n    return undefined;\n}\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/adts.js?")},"./src/demux/exp-golomb.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\n// Exponential-Golomb buffer decoder\nvar ExpGolomb = function () {\n    function ExpGolomb(uint8array) {\n        _classCallCheck(this, ExpGolomb);\n\n        this.TAG = this.constructor.name;\n\n        this._buffer = uint8array;\n        this._buffer_index = 0;\n        this._total_bytes = uint8array.byteLength;\n        this._total_bits = uint8array.byteLength * 8;\n        this._current_word = 0;\n        this._current_word_bits_left = 0;\n    }\n\n    _createClass(ExpGolomb, [{\n        key: 'destroy',\n        value: function destroy() {\n            this._buffer = null;\n        }\n    }, {\n        key: '_fillCurrentWord',\n        value: function _fillCurrentWord() {\n            var buffer_bytes_left = this._total_bytes - this._buffer_index;\n            if (buffer_bytes_left <= 0) {\n                throw new IllegalStateException('ExpGolomb: _fillCurrentWord() but no bytes available');\n            }\n\n            var bytes_read = Math.min(4, buffer_bytes_left);\n            var word = new Uint8Array(4);\n            word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\n            this._current_word = new DataView(word.buffer).getUint32(0, false);\n\n            this._buffer_index += bytes_read;\n            this._current_word_bits_left = bytes_read * 8;\n        }\n    }, {\n        key: 'readBits',\n        value: function readBits(bits) {\n            if (bits > 32) {\n                throw new InvalidArgumentException('ExpGolomb: readBits() bits exceeded max 32bits!');\n            }\n\n            if (bits <= this._current_word_bits_left) {\n                var _result = this._current_word >>> 32 - bits;\n                this._current_word <<= bits;\n                this._current_word_bits_left -= bits;\n                return _result;\n            }\n\n            var result = this._current_word_bits_left ? this._current_word : 0;\n            result = result >>> 32 - this._current_word_bits_left;\n            var bits_need_left = bits - this._current_word_bits_left;\n\n            this._fillCurrentWord();\n            var bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\n\n            var result2 = this._current_word >>> 32 - bits_read_next;\n            this._current_word <<= bits_read_next;\n            this._current_word_bits_left -= bits_read_next;\n\n            result = result << bits_read_next | result2;\n            return result;\n        }\n    }, {\n        key: 'readBool',\n        value: function readBool() {\n            return this.readBits(1) === 1;\n        }\n\n        // ():int\n\n    }, {\n        key: 'readUByte',\n        value: function readUByte() {\n            return this.readBits(8);\n        }\n    }, {\n        key: 'readByte',\n        value: function readByte() {\n            return this.readBits(8);\n        }\n    }, {\n        key: '_skipLeadingZero',\n        value: function _skipLeadingZero() {\n            var zero_count = void 0;\n            for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\n                if ((this._current_word & 0x80000000 >>> zero_count) !== 0) {\n                    this._current_word <<= zero_count;\n                    this._current_word_bits_left -= zero_count;\n                    return zero_count;\n                }\n            }\n            this._fillCurrentWord();\n            return zero_count + this._skipLeadingZero();\n        }\n    }, {\n        key: 'readUEG',\n        value: function readUEG() {\n            // unsigned exponential golomb\n            var leading_zeros = this._skipLeadingZero();\n            return this.readBits(leading_zeros + 1) - 1;\n        }\n    }, {\n        key: 'readSEG',\n        value: function readSEG() {\n            // signed exponential golomb\n            var value = this.readUEG();\n            if (value & 0x01) {\n                return value + 1 >>> 1;\n            } else {\n                return -1 * (value >>> 1);\n            }\n        }\n    }, {\n        key: 'readSliceType',\n        value: function readSliceType() {\n            // skip NALu type\n            this.readUByte();\n            // discard first_mb_in_slice\n            this.readUEG();\n            // return slice_type\n            return this.readUEG();\n        }\n    }]);\n\n    return ExpGolomb;\n}();\n\nexports.default = ExpGolomb;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/exp-golomb.js?")},"./src/demux/flv/amf.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable */\n\n\nvar _decodeUTF = __webpack_require__(/*! ../../utils/decodeUTF8 */ \"./src/utils/decodeUTF8.js\");\n\nvar _decodeUTF2 = _interopRequireDefault(_decodeUTF);\n\nvar _log = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AMF = function () {\n    function AMF() {\n        _classCallCheck(this, AMF);\n\n        this.tag = 'AMF';\n    }\n\n    _createClass(AMF, null, [{\n        key: 'parseObject',\n        value: function parseObject(arrayBuffer, dataOffset, dataSize) {\n            var name = AMF.parseString(arrayBuffer, dataOffset, dataSize);\n            var value = AMF.parseScript(arrayBuffer, dataOffset + name.size);\n            var isObjectEnd = value.objectEnd;\n\n            return {\n                data: {\n                    name: name.data,\n                    value: value.data\n                },\n                size: value.size,\n                objectEnd: isObjectEnd\n            };\n        }\n    }, {\n        key: 'parseVariable',\n        value: function parseVariable(arrayBuffer, dataOffset, dataSize) {\n            return AMF.parseObject(arrayBuffer, dataOffset, dataSize);\n        }\n    }, {\n        key: 'parseLongString',\n        value: function parseLongString(arrayBuffer, dataOffset, dataSize) {\n            var v = new DataView(arrayBuffer, dataOffset);\n            var length = v.getUint32(0);\n\n            var str = void 0;\n            if (length > 0) {\n                str = (0, _decodeUTF2.default)(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n            } else {\n                str = '';\n            }\n\n            return {\n                data: str,\n                size: 4 + length\n            };\n        }\n    }, {\n        key: 'parseDate',\n        value: function parseDate(arrayBuffer, dataOffset, dataSize) {\n            var v = new DataView(arrayBuffer, dataOffset);\n            var timestamp = v.getFloat64(0);\n            var localTimeOffset = v.getInt16(8);\n            timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n            return {\n                data: new Date(timestamp),\n                size: 8 + 2\n            };\n        }\n    }, {\n        key: 'parseString',\n        value: function parseString(arrayBuffer, dataOffset, dataSize) {\n            var v = new DataView(arrayBuffer, dataOffset);\n            var length = v.getUint16(0);\n            var str = void 0;\n            if (length > 0) {\n                str = (0, _decodeUTF2.default)(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n            } else {\n                str = '';\n            }\n            return {\n                data: str,\n                size: 2 + length\n            };\n        }\n\n        /**\n         * 解析metadata\n         */\n\n    }, {\n        key: 'parseMetadata',\n        value: function parseMetadata(arr) {\n            var name = AMF.parseScript(arr, 0);\n            var value = AMF.parseScript(arr, name.size, arr.length - name.size);\n            var data = {};\n            data[name.data] = value.data;\n            return data;\n        }\n    }, {\n        key: 'parseScript',\n        value: function parseScript(arr, offset, dataSize) {\n            var dataOffset = offset;\n            var uint8 = new Uint8Array(arr);\n            var buffer = uint8.buffer;\n            var dv = new DataView(buffer, 0, dataSize);\n            var value = null;\n            var type = dv.getUint8(dataOffset);\n            dataOffset += 1;\n\n            switch (type) {\n                case 0:\n                    // Number(Double) type\n                    value = dv.getFloat64(dataOffset);\n                    dataOffset += 8;\n                    break;\n                case 1:\n                    {\n                        // Boolean type\n                        var b = dv.getUint8(dataOffset);\n                        value = !!b;\n                        dataOffset += 1;\n                        break;\n                    }\n                case 2:\n                    {\n                        // String type\n                        // dataOffset += 1;\n                        var amfstr = AMF.parseString(buffer, dataOffset);\n                        value = amfstr.data;\n                        dataOffset += amfstr.size;\n                        break;\n                    }\n                case 3:\n                    {\n                        // Object(s) type\n                        value = {};\n                        var terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                        if ((dv.getUint32(dataSize - 4) & 0x00ffffff) === 9) {\n                            terminal = 3;\n                        }\n                        while (dataOffset < dataSize - 4) {\n                            // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                            var amfobj = AMF.parseObject(buffer, dataOffset, dataSize - offset - terminal);\n\n                            if (amfobj.objectEnd) {\n                                break;\n                            }\n                            value[amfobj.data.name] = amfobj.data.value;\n                            // dataOffset += amfobj.size;\n                            dataOffset = amfobj.size;\n                        }\n                        if (dataOffset <= dataSize - 3) {\n                            var marker = v.getUint32(dataOffset - 1) & 0x00ffffff;\n                            if (marker === 9) {\n                                dataOffset += 3;\n                            }\n                        }\n                        break;\n                    }\n                case 8:\n                    {\n                        // ECMA array type (Mixed array)\n                        value = {};\n                        // dataOffset += 1;\n                        dataOffset += 4; // ECMAArrayLength(UI32)\n                        var _terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                        if ((dv.getUint32(dataSize - 4) & 0x00ffffff) === 9) {\n                            _terminal = 3;\n                        }\n                        while (dataOffset < dataSize - 8) {\n                            // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                            var amfvar = AMF.parseVariable(buffer, dataOffset);\n\n                            if (amfvar.objectEnd) {\n                                break;\n                            }\n                            value[amfvar.data.name] = amfvar.data.value;\n                            dataOffset = amfvar.size;\n                        }\n                        if (dataOffset <= dataSize - 3) {\n                            var _marker = dv.getUint32(dataOffset - 1) & 0x00ffffff;\n                            if (_marker === 9) {\n                                dataOffset += 3;\n                            }\n                        }\n                        break;\n                    }\n                case 9:\n                    // ScriptDataObjectEnd\n                    value = undefined;\n                    dataOffset = 1;\n                    objectEnd = true;\n                    break;\n                case 10:\n                    {\n                        // Strict array type\n                        // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                        value = [];\n                        var strictArrayLength = dv.getUint32(dataOffset);\n                        dataOffset += 4;\n                        for (var i = 0; i < strictArrayLength; i++) {\n                            var val = AMF.parseScript(buffer, dataOffset);\n                            value.push(val.data);\n                            dataOffset = val.size;\n                        }\n                        break;\n                    }\n                case 11:\n                    {\n                        // Date type\n                        var date = AMF.parseDate(buffer, dataOffset + 1, dataSize - 1);\n                        value = date.data;\n                        dataOffset += date.size;\n                        break;\n                    }\n                case 12:\n                    {\n                        // Long string type\n                        var amfLongStr = AMF.parseString(buffer, dataOffset + 1, dataSize - 1);\n                        value = amfLongStr.data;\n                        dataOffset += amfLongStr.size;\n                        break;\n                    }\n                default:\n                    // ignore and skip\n                    dataOffset = dataSize;\n                    _log.Log.v(this.tag, 'AMF', 'Unsupported AMF value type ' + type);\n            }\n            return {\n                data: value,\n                size: dataOffset\n            };\n        }\n    }]);\n\n    return AMF;\n}();\n\nexports.default = AMF;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/flv/amf.js?")},"./src/demux/flv/flv-demux.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mp4Generator = __webpack_require__(/*! ../../remux/mp4-generator */ \"./src/remux/mp4-generator.js\");\n\nvar _mp4Generator2 = _interopRequireDefault(_mp4Generator);\n\nvar _flvTag = __webpack_require__(/*! ./flvTag */ \"./src/demux/flv/flvTag.js\");\n\nvar _flvTag2 = _interopRequireDefault(_flvTag);\n\nvar _downloadCache = __webpack_require__(/*! ../../io/download-cache */ \"./src/io/download-cache.js\");\n\nvar _downloadCache2 = _interopRequireDefault(_downloadCache);\n\nvar _amf = __webpack_require__(/*! ./amf */ \"./src/demux/flv/amf.js\");\n\nvar _amf2 = _interopRequireDefault(_amf);\n\nvar _mediaInfo = __webpack_require__(/*! ./media-info */ \"./src/demux/flv/media-info.js\");\n\nvar _mediaInfo2 = _interopRequireDefault(_mediaInfo);\n\nvar _kernelEvents = __webpack_require__(/*! ../../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _log = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.js\");\n\nvar _spsParser = __webpack_require__(/*! ../sps-parser */ \"./src/demux/sps-parser.js\");\n\nvar _spsParser2 = _interopRequireDefault(_spsParser);\n\nvar _adts = __webpack_require__(/*! ../adts */ \"./src/demux/adts.js\");\n\nvar ADTS = _interopRequireWildcard(_adts);\n\nvar _kernelErrors = __webpack_require__(/*! ../../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FLV_HEAD_LEN = 13;\nvar FLV_TAG_HEAD_LEN = 11;\nvar FLV_TAG_SIZE_LEN = 4;\nvar AVC_IDR_CHECK_LEN = 2;\n\nvar FlvDemux = function () {\n    function FlvDemux(observer, remux, config) {\n        _classCallCheck(this, FlvDemux);\n\n        this._mediaInfo = new _mediaInfo2.default();\n        this._requestLen = FLV_HEAD_LEN;\n        this._parseFun = this._parseFlvHead;\n        this._cache = new _downloadCache2.default();\n        this._observer = observer;\n        this._remux = remux;\n        this._config = config;\n        this._needAlignment = !!config.alignBase;\n\n        this._duration = 0;\n        this._naluLengthSize = 4;\n        this._dtsOffset = 0;\n        this._videoTrack = {\n            type: 'video',\n            id: 1,\n            sequenceNumber: 0,\n            samples: [],\n            len: 0,\n            timescale: 90000,\n            inputTimeScale: 90000\n        };\n        this._audioTrack = {\n            type: 'audio',\n            id: 2,\n            sequenceNumber: 0,\n            samples: [],\n            len: 0,\n            timescale: 90000,\n            inputTimeScale: 90000\n        };\n\n        this._firstTag = true;\n\n        this._skipLostFrame = config.skipLostFrame || false;\n\n        this._contiguous = false;\n        this._accurateTimeOffset = true;\n\n        // 视频帧对齐缓存\n        this._syncCache = [];\n        // 缓存长度，缓存长度为fps*5，最低25\n        this._syncCacheMinSize = 25;\n        this._syncCacheSize = 25;\n        this._resetSyncInfo();\n\n        this._firstRemux = true;\n    }\n\n    _createClass(FlvDemux, [{\n        key: 'setFlv',\n        value: function setFlv(uint8, baseTime, contiguous, accurateTimeOffset) {\n            this._cache.pushData(uint8);\n            this._contiguous = contiguous;\n            this._accurateTimeOffset = accurateTimeOffset;\n\n            if (baseTime) {\n                this._dtsOffset = baseTime;\n            }\n            while (this._cache.unreadLen >= this._requestLen) {\n                this._parseFun();\n            }\n\n            this._flushTag();\n        }\n    }, {\n        key: 'seek',\n        value: function seek(ms) {\n            this._dtsOffset = ms || 0;\n            // this._remux.seek(this._dtsOffset, true);\n            // this._remux.insertDiscontinuity();\n            this.flush();\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {}\n    }, {\n        key: 'flush',\n        value: function flush() {\n            this._firstRemux = true;\n            this._requestLen = FLV_TAG_HEAD_LEN;\n            this._parseFun = this._parseFlvTagHead;\n            this._cache.flush();\n            this._videoTrack.samples = [];\n            this._videoTrack.len = 0;\n            this._audioTrack.samples = [];\n            this._audioTrack.len = 0;\n            this._syncCache = [];\n            this._resetSyncInfo();\n        }\n\n        // 设置视频长度\n\n    }, {\n        key: '_parseFlvHead',\n        value: function _parseFlvHead() {\n            var data = this._cache.readData(FLV_HEAD_LEN);\n            if (data[0] !== 0x46 || data[1] !== 0x4c || data[2] !== 0x56 || data[3] !== 0x01) {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: wrong head'\n                });\n            }\n\n            this._mediaInfo.hasAudio = (data[4] & 4) >>> 2 !== 0;\n            this._mediaInfo.hasVideo = (data[4] & 1) !== 0;\n            // TEST:\n            // this._mediaInfo.hasAudio = false;\n            // this._mediaInfo.hasVideo = false;\n\n            this._cache.skip(FLV_HEAD_LEN);\n            this._requestLen = FLV_TAG_HEAD_LEN;\n            this._parseFun = this._parseFlvTagHead;\n        }\n\n        /**\n         * 解析flv tag head\n         */\n\n    }, {\n        key: '_parseFlvTagHead',\n        value: function _parseFlvTagHead() {\n            this._tag = new _flvTag2.default();\n            var data = this._cache.readData(FLV_TAG_HEAD_LEN);\n            // 取出tag类型\n            this._tag.tagType = data[0];\n            // 取出包体大小\n            this._tag.dataSize = ((data[1] & 0xff) << 16) + ((data[2] & 0xff) << 8) + (data[3] & 0xff);\n            // 取出解码时间\n            this._tag.timestamp = ((data[7] & 0xff) << 24) + ((data[4] & 0xff) << 16) + ((data[5] & 0xff) << 8) + (data[6] & 0xff);\n            this._currentTimestamp = this._tag.timestamp;\n            this._cache.skip(FLV_TAG_HEAD_LEN);\n            // 尝试在处理完整个tag之前判断是否为关键帧，用于自适应码率\n            if (this._tag.tagType === 9) {\n                this._parseFun = this._checkVideoTagType;\n                this._requestLen = AVC_IDR_CHECK_LEN;\n            } else {\n                this._parseFun = this._parseFlvTag;\n                this._requestLen = this._tag.dataSize + FLV_TAG_SIZE_LEN;\n            }\n        }\n    }, {\n        key: '_checkVideoTagType',\n        value: function _checkVideoTagType() {\n            var data = this._cache.readData(2);\n            var frameType = (data[0] & 240) >>> 4;\n            var packetType = data[1];\n            // 获取是否是关键帧\n            if (frameType === 1 && packetType === 1) {\n                this._flushTag();\n                this._observer.trigger(_kernelEvents2.default.IDR);\n            }\n\n            this._parseFun = this._parseFlvTag;\n            this._requestLen = this._tag.dataSize + FLV_TAG_SIZE_LEN;\n        }\n    }, {\n        key: '_parseFlvTag',\n        value: function _parseFlvTag() {\n            if (this._firstTag) {\n                this._observer.trigger(_kernelEvents2.default.REPORT, { type: 'demux', ts: Date.now() });\n                this._firstTag = false;\n            }\n            var tag = this._tag;\n            if (tag.tagType === 18 || tag.tagType === 8 || tag.tagType === 9) {\n                tag.body = this._cache.getData(tag.dataSize);\n                this._cache.skip(4); // skip size\n                if (tag.tagType === 9 && this._mediaInfo.hasVideo) {\n                    this._parseVideoData(tag);\n                }\n                if (tag.tagType === 8 && this._mediaInfo.hasAudio) {\n                    this._parseAudioData(tag);\n                }\n                if (tag.tagType === 18) {\n                    this._parseScriptTag(tag);\n                }\n            } else {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: false,\n                    reason: 'Flv: wrong tagType: ' + tag.tagType\n                });\n            }\n            this._requestLen = FLV_TAG_HEAD_LEN;\n            this._parseFun = this._parseFlvTagHead;\n        }\n    }, {\n        key: '_parseScriptTag',\n        value: function _parseScriptTag(tag) {\n            var scriptData = _amf2.default.parseMetadata(tag.body);\n            scriptData.timestamp = this._currentTimestamp || 0;\n\n            if (scriptData.hasOwnProperty('onMetaData')) {\n                this._metadata = scriptData;\n                var onMetaData = this._metadata.onMetaData;\n                this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n                this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n                this._mediaInfo.width = onMetaData.width;\n                this._mediaInfo.height = onMetaData.height;\n                this._mediaInfo.duration = onMetaData.duration;\n                this._duration = this._flvDuration ? this._flvDuration : onMetaData.duration;\n                this._mediaInfo.fps = onMetaData.framerate;\n\n                if (_typeof(onMetaData.keyframes) === 'object') {\n                    // keyframes\n                    this._mediaInfo.hasKeyframesIndex = true;\n                    var keyframes = onMetaData.keyframes;\n                    keyframes.times = onMetaData.times;\n                    keyframes.filepositions = onMetaData.filepositions;\n                    this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n                    onMetaData.keyframes = null; // keyframes has been extracted, remove it\n                } else {\n                    this._mediaInfo.hasKeyframesIndex = false;\n                }\n                _log.Log.i(this.tag, 'Parsed onMetaData');\n            }\n\n            this._observer.trigger(_kernelEvents2.default.SCRIPT_PARSED, scriptData);\n        }\n    }, {\n        key: '_parseVideoData',\n        value: function _parseVideoData(tag) {\n            // 获取 video tag body 第一字节\n            var spec = tag.body[0];\n            // 获取是否是关键帧\n            tag.frameType = (spec & 240) >>> 4;\n            // 获取编码格式\n            var codecId = spec & 15;\n            if (codecId !== 7) {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: Unsupported codec in video frame: ' + codecId\n                });\n                return;\n            }\n\n            // IF CodecID == 7  AVCPacketType\n            // 0 = AVC sequence header\n            // 1 = AVC NALU\n            // 2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)\n            var packetType = tag.body[1];\n            // 3字节\n            // IF AVCPacketType == 1\n            //  Composition time offset\n            // ELSE\n            //  0\n            tag.cts = ((tag.body[2] & 0xff) << 16) + ((tag.body[3] & 0xff) << 8) + (tag.body[4] & 0xff);\n\n            // IF AVCPacketType == 0 AVCDecoderConfigurationRecord（AVC sequence header）\n            // IF AVCPacketType == 1 One or more NALUs (Full frames are required)\n            if (packetType === 0) {\n                this._parseAVCDecoderConfigurationRecord(tag, 5);\n            } else if (packetType === 1) {\n                // One or more Nalus\n                this._parseAVCVideoData(tag, 5);\n            } else if (packetType === 2) {\n                // empty, AVC end of sequence\n            } else {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: Invalid video packet type ' + packetType\n                });\n                return;\n            }\n        }\n\n        /**\n         * AVC 初始化\n         * @param {FlvTag} tag flvtag\n         * @param {number} dataOffset tag body offset\n         */\n\n    }, {\n        key: '_parseAVCDecoderConfigurationRecord',\n        value: function _parseAVCDecoderConfigurationRecord(tag, dataOffset) {\n            var track = this._videoTrack;\n            var arrayBuffer = tag.body.buffer;\n            var dataSize = tag.body.byteLength - dataOffset;\n            var v = new DataView(arrayBuffer, dataOffset, dataSize);\n            var mediaInfo = this._mediaInfo;\n\n            var version = v.getUint8(0); // configurationVersion\n            var avcProfile = v.getUint8(1); // avcProfileIndication\n            // const profileCompatibility = v.getUint8(2); // profile_compatibility\n            // const avcLevel = v.getUint8(3); // AVCLevelIndication\n            if (version !== 1 || avcProfile === 0) {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: Invalid AVCDecoderConfigurationRecord'\n                });\n                return;\n            }\n\n            this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n            if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: Strange NaluLengthSizeMinusOne: ' + (this._naluLengthSize - 1)\n                });\n                return;\n            }\n\n            var spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n            if (spsCount === 0 || spsCount > 1) {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: Invalid H264 SPS count: ' + spsCount\n                });\n                return;\n            }\n\n            var offset = 6;\n            track.sps = [];\n            for (var i = 0; i < spsCount; i++) {\n                var len = v.getUint16(offset); // sequenceParameterSetLength\n                offset += 2;\n\n                if (len === 0) {\n                    continue;\n                }\n\n                // Notice: Nalu without startcode header (00 00 00 01)\n                var sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n                offset += len;\n                track.sps.push(sps);\n                var config = _spsParser2.default.parseSPS(sps);\n                track.width = config.codec_size.width;\n                track.height = config.codec_size.height;\n                track.pixelRatio = [config.sar_ratio.width, config.sar_ratio.height];\n\n                if (config.frame_rate.fixed && config.frame_rate.fps !== 0) {\n                    mediaInfo.fps = config.frame_rate.fps;\n                }\n\n                var codecArray = sps.subarray(1, 4);\n                var codecString = 'avc1.';\n                for (var j = 0; j < 3; j++) {\n                    var h = codecArray[j].toString(16);\n                    if (h.length < 2) {\n                        h = '0' + h;\n                    }\n                    codecString += h;\n                }\n                track.codec = codecString;\n                this._syncCacheSize = Math.max(mediaInfo.fps * 5, this._syncCacheMinSize);\n                this._timeInfo.avcSampleDuration = Math.ceil(1000 / mediaInfo.fps) || 40;\n\n                mediaInfo.videoCodec = codecString;\n                mediaInfo.width = track.width;\n                mediaInfo.height = track.height;\n                mediaInfo.profile = config.profile_string;\n                mediaInfo.level = config.level_string;\n                mediaInfo.chromaFormat = config.chroma_format_string;\n                if (mediaInfo.hasAudio) {\n                    if (mediaInfo.audioCodec) {\n                        mediaInfo.mimeType = 'video/x-flv; codecs=\"' + mediaInfo.videoCodec + ',' + mediaInfo.audioCodec + '\"';\n                    }\n                } else {\n                    mediaInfo.mimeType = 'video/x-flv; codecs=\"' + mediaInfo.videoCodec + '\"';\n                }\n            }\n\n            var ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n            if (ppsCount === 0 || ppsCount > 1) {\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: Invalid H264 PPS count: ' + ppsCount\n                });\n                return;\n            }\n\n            offset++;\n            track.pps = [];\n            for (var _i = 0; _i < ppsCount; _i++) {\n                var _len = v.getUint16(offset); // pictureParameterSetLength\n                offset += 2;\n                var pps = new Uint8Array(arrayBuffer, dataOffset + offset, _len);\n                track.pps.push(pps);\n                if (_len === 0) {\n                    continue;\n                }\n                offset += _len;\n            }\n            _log.Log.v(this.tag, 'Parsed AVCDecoderConfigurationRecord');\n\n            track.duration = this._duration;\n            track.container = 'video/mp4';\n            if (mediaInfo.fps) {\n                track.refSampleDuration = Math.floor(track.timescale / mediaInfo.fps);\n            } else {\n                track.refSampleDuration = Math.floor(track.timescale / 30);\n            }\n            this._onTrackMetadata('video', track);\n        }\n\n        /**\n         * 更新视频帧对齐缓冲区\n         */\n\n    }, {\n        key: '_updateSyncCache',\n        value: function _updateSyncCache() {\n            // 有可供参考的音频数据\n            if (this._syncCache.length > 0) {\n                if (this._timeInfo.aacCurrentDts > this._syncCache[0].tag.timestamp) {\n                    var data = this._syncCache.shift();\n                    this._parseAVCVideoData(data.tag, data.dataOffset, true);\n                    this._updateSyncCache();\n                }\n                // 超出cache上限，不修正时间\n                if (this._syncCache.length > this._syncCacheSize) {\n                    _log.Log.w(this.tag, 'out of sync cache!!');\n                    var _data = this._syncCache.shift();\n                    this._parseAVCVideoData(_data.tag, _data.dataOffset, true);\n                }\n            }\n        }\n\n        /**\n         * 普通的AVC 片段\n         * @param {Flvtag} tag flv tag\n         * @param {number} dataOffset dataOffset\n         * @param {boolean} fromCache fromCache\n         */\n\n    }, {\n        key: '_parseAVCVideoData',\n        value: function _parseAVCVideoData(tag, dataOffset) {\n            var fromCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var arrayBuffer = tag.body.buffer;\n            var dataSize = tag.body.byteLength - dataOffset;\n            var v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n            var units = [];\n            var length = 0;\n\n            var offset = 0;\n            var lengthSize = this._naluLengthSize;\n            var dts = tag.timestamp;\n            var keyframe = tag.frameType === 1; // from FLV Frame Type constants\n            var avcDts = dts;\n            // 清理aac对齐数据\n            for (var i = 0; i < this._timeInfo.aacFixedRecord.length; i++) {\n                if (dts > this._timeInfo.aacFixedRecord[i].ed) {\n                    this._timeInfo.aacFixedRecord.splice(0, i);\n                    break;\n                }\n            }\n\n            // 是否需要对齐，通过pts差计算\n            if (this._timeInfo.avcLastDemuxedDts && this._skipLostFrame && this._mediaInfo.hasAudio) {\n                // 帧间距增加时尝试对齐\n                if (avcDts - this._timeInfo.avcLastDemuxedDts > this._timeInfo.avcSampleDuration * 2) {\n                    var fixByAudio = false;\n                    // 尝试利用acc的时间修正记录this._timeInfo.aacFixedRecord为参照修正视频时间，进行对齐\n                    for (var _i2 = 0; _i2 < this._timeInfo.aacFixedRecord.length; _i2++) {\n                        if (avcDts < this._timeInfo.aacFixedRecord[_i2].ed) {\n                            avcDts = avcDts - this._timeInfo.aacFixedRecord[_i2].fix;\n                            fixByAudio = true;\n\n                            // 修正是否在范围内\n                            if (this._timeInfo.aacFixedRecord[_i2].ed === Number.POSITIVE_INFINITY && dts > this._timeInfo.aacCurrentDts) {\n                                avcDts = dts;\n                                fixByAudio = false;\n                            }\n                            break;\n                        }\n                    }\n\n                    // 缓存过的数据不进行二次缓存\n                    if (!fromCache) {\n                        // 无法参照音频时间修正时，加入cache，等待音频参考时间||后续数据需要等待cache消耗完\n                        if (!fixByAudio && dts > this._timeInfo.aacCurrentDts || this._syncCache.length > 0) {\n                            this._syncCache.push({\n                                tag: tag,\n                                dataOffset: dataOffset\n                            });\n                            this._updateSyncCache();\n                            return;\n                        }\n                    }\n                }\n            }\n            // 处理Non-monotonous DTS及丢帧时间修正后可能出现的时间重叠，加速播放\n            if (avcDts <= this._timeInfo.avcLastDemuxedDts) {\n                avcDts = this._timeInfo.avcLastDemuxedDts + 1;\n            }\n            var avcPts = avcDts + tag.cts;\n            while (offset < dataSize) {\n                if (offset + 4 >= dataSize) {\n                    _log.Log.v(this.tag, 'Malformed Nalu near timestamp ' + dts + ', offset = ' + offset + ', dataSize = ' + dataSize);\n                    break; // data not enough for next Nalu\n                }\n                // Nalu with length-header (AVC1)\n                var naluSize = v.getUint32(offset); // Big-Endian read\n                if (lengthSize === 3) {\n                    naluSize >>>= 8;\n                }\n                if (naluSize > dataSize - lengthSize) {\n                    _log.Log.v(this.tag, 'Malformed Nalus near timestamp ' + dts + ', NaluSize > DataSize!');\n                    return;\n                }\n                var unitType = v.getUint8(offset + lengthSize) & 0x1f;\n                if (unitType === 5) {\n                    keyframe = true;\n                }\n\n                var data = new Uint8Array(arrayBuffer, dataOffset + offset + 4, lengthSize + naluSize - 4);\n                var unit = { type: unitType, data: data };\n                units.push(unit);\n                length += data.byteLength;\n                offset += lengthSize + naluSize;\n            }\n\n            if (units.length) {\n                var track = this._videoTrack;\n                var avcSample = {\n                    units: units,\n                    length: length,\n                    dts: avcDts * 90,\n                    cts: tag.cts * 90,\n                    pts: avcPts * 90,\n                    streamDts: dts,\n                    key: keyframe\n                };\n                track.samples.push(avcSample);\n                track.len += length;\n            }\n            this._timeInfo.avcLastDemuxedDts = avcDts;\n        }\n    }, {\n        key: '_parseAudioData',\n        value: function _parseAudioData(tag) {\n            var dataSize = tag.body.byteLength;\n            var timeInfo = this._timeInfo;\n            if (dataSize <= 1) {\n                _log.Log.v(this.tag, 'Flv: Invalid audio packet, missing SoundData payload!');\n                return;\n            }\n            var track = this._audioTrack;\n\n            // if (!meta || !meta.codec) {\n            //     // initial metadata\n            //     meta = this._audioMetadata = {};\n            //     meta.type = 'audio';\n            //     meta.id = track.id;\n            //     meta.duration = this._duration;\n\n            //     const v = new DataView(arrayBuffer, 0, dataSize);\n            //     const soundSpec = v.getUint8(0);\n            //     const soundFormat = soundSpec >>> 4;\n            //     if (soundFormat !== 10) {\n            //         // AAC\n            //         // TODO: support MP3 audio codec\n            //         this._onError(ERRORNO.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n            //         return;\n            //     }\n\n            //     let soundRate = 0;\n            //     const soundRateIndex = (soundSpec & 12) >>> 2;\n            //     const soundRateTable = [5500, 11025, 22050, 44100, 48000];\n\n            //     if (soundRateIndex < soundRateTable.length) {\n            //         soundRate = soundRateTable[soundRateIndex];\n            //     } else {\n            //         this._onError(ERRORNO.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n            //         return;\n            //     }\n\n            //     const soundType = soundSpec & 1;\n            //     meta.audioSampleRate = soundRate;\n            //     meta.channelCount = soundType === 0 ? 1 : 2;\n            //     // TODO:\n            //     meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n            //     meta.codec = 'mp4a.40.5';\n            // }\n            var packetType = tag.body[1];\n\n            if (packetType === 0) {\n                if (tag.body.byteLength < 4) {\n                    return;\n                }\n                // ADTS.initTrackConfig(meta, this._observer, tag.body, 0, null, 'flv');\n                ADTS.initTrackConfig(track, this._observer, tag.body, 0, null, 'flv');\n                track.isAAC = true;\n                track.duration = this._duration;\n                track.timescale = track.samplerate;\n                // meta.audioSampleRate = meta.samplerate;\n\n                var mediaInfo = this._mediaInfo;\n                mediaInfo.audioCodec = track.codec;\n                mediaInfo.audioSampleRate = track.samplerate;\n                mediaInfo.audioChannelCount = track.channelCount;\n                this._onTrackMetadata('audio', track);\n                return;\n            } else if (packetType === 1) {\n                var aacData = tag.body.subarray(2);\n                // AAC raw frame data\n                var dts = tag.timestamp;\n                if (!timeInfo.aacFirstDts) {\n                    timeInfo.aacFirstDts = dts;\n                }\n                // 通过时间计算的dts与通过帧长度计算的dts比对，判断是否发生了跳帧\n                var dtsDiff = dts - Math.floor(timeInfo.aacFirstDts + timeInfo.aacCurrentDtsOffset) - timeInfo.aacCurrentFixedLen;\n                if (dtsDiff > Math.max(timeInfo.aacFrameLen - 1, 1)) {\n                    timeInfo.aacCurrentFixedLen += dtsDiff;\n                    // 闭合上个跳帧范围记录\n                    if (timeInfo.aacFixedRecord.length) {\n                        timeInfo.aacFixedRecord[timeInfo.aacFixedRecord.length - 1].ed = dts - dtsDiff;\n                    }\n                    // 需要修正的时间范围:st到ed范围内的时间修正fix的长度\n                    timeInfo.aacFixedRecord.push({\n                        st: dts,\n                        fix: timeInfo.aacCurrentFixedLen,\n                        ed: Number.POSITIVE_INFINITY\n                    });\n                    this._observer.trigger(_kernelEvents2.default.LOST_FRAMES, { drop: dtsDiff, fix: timeInfo.aacCurrentFixedLen });\n                    _log.Log.i(this.tag, 'lost aac frame. aac dts diff:', dtsDiff, timeInfo.aacCurrentFixedLen);\n                }\n                // aac帧长度\n                timeInfo.aacFrameLen = 1024 * 1000 / track.samplerate;\n                // 通过aac帧长度累加计算dts\n                var aacDts = dts;\n                if (this._skipLostFrame) {\n                    aacDts = Math.floor(timeInfo.aacFirstDts + timeInfo.aacCurrentDtsOffset);\n                }\n                var sampleDts = aacDts * track.inputTimeScale / 1000;\n                var aacSample = {\n                    unit: aacData,\n                    dts: sampleDts,\n                    pts: sampleDts,\n                    streamDts: dts\n                };\n                timeInfo.aacCurrentDtsOffset += timeInfo.aacFrameLen;\n                timeInfo.aacCurrentDts = dts;\n                this._updateSyncCache();\n                track.samples.push(aacSample);\n                track.len += aacData.length;\n            } else {\n                _log.Log.v(this.tag, 'Flv: Unsupported AAC data type ' + packetType);\n            }\n        }\n\n        /**\n         * 重置音视频对齐信息\n         */\n\n    }, {\n        key: '_resetSyncInfo',\n        value: function _resetSyncInfo() {\n            // 时间戳修正\n            this._timeInfo = {\n                // aac第一个帧的dts\n                aacFirstDts: 0,\n                // aac当前处理帧帧相对第一个帧dts的偏移量\n                aacCurrentDtsOffset: 0,\n                // aac当前处理帧需要修正时长\n                aacCurrentFixedLen: 0,\n                // aac dts修正记录\n                aacFixedRecord: [],\n                aacFrameLen: 0,\n                aacCurrentDts: 0,\n                avcSampleDuration: 40,\n                avcLastDemuxedDts: 0\n            };\n        }\n\n        /**\n         *\n         * 音频和视频的初始化tag\n         *\n         * @param {any} type type\n         * @param {any} meta meta\n         *\n         * @memberof flv2fmp4\n         */\n\n    }, {\n        key: '_onTrackMetadata',\n        value: function _onTrackMetadata(type, meta) {\n            var videoMoov = void 0,\n                audioMoov = void 0;\n            var initSegments = [];\n            var info = this._mediaInfo;\n            var mediaInfo = {\n                width: info.width,\n                height: info.height,\n                hasAudio: info.hasAudio,\n                audioCodec: info.audioCodec,\n                audioSampleRate: info.audioSampleRate,\n                hasVideo: info.hasVideo,\n                videoCodec: info.videoCodec,\n                fps: info.fps,\n                chromaFormat: info.chromaFormat,\n                profile: info.profile\n            };\n            this._observer.trigger(_kernelEvents2.default.MEDIA_INFO, mediaInfo);\n\n            switch (type) {\n                case 'video':\n                    this._remux._videoMeta = meta;\n                    videoMoov = _mp4Generator2.default.initSegment([meta]);\n                    initSegments.push({ type: 'video', data: videoMoov });\n                    break;\n                case 'audio':\n                    this._remux._audioMeta = meta;\n                    audioMoov = _mp4Generator2.default.initSegment([meta]);\n                    initSegments.push({ type: 'audio', data: audioMoov });\n                    break;\n            }\n            this._flushTag();\n            this._observer.trigger(_kernelEvents2.default.PARSING_INIT_SEGMENT, initSegments);\n        }\n    }, {\n        key: '_flushTag',\n        value: function _flushTag() {\n            var audiotrack = this._audioTrack;\n            var videotrack = this._videoTrack;\n            var mediaInfo = this._mediaInfo;\n\n            if (mediaInfo.hasVideo && videotrack.samples.length < 5) {\n                return;\n            }\n\n            if (audiotrack.samples.length === 0 && videotrack.samples.length === 0) {\n                return;\n            }\n\n            if (this._firstRemux && mediaInfo.hasAudio && mediaInfo.hasVideo && (audiotrack.samples.length === 0 || videotrack.samples.length === 0)) {\n                return;\n            }\n            this._firstRemux = false;\n\n            if (this._needAlignment) {\n                this._dtsOffset = this._config.alignBase / 1000;\n                this._needAlignment = false;\n            }\n            try {\n                this._remux.remux(audiotrack, videotrack, this._dtsOffset, this._contiguous, this._accurateTimeOffset);\n            } catch (error) {\n                _log.Log.v(this.tag, error);\n                this._observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.REMUX_ERROR,\n                    fatal: true,\n                    reason: error.message\n                });\n            }\n        }\n    }, {\n        key: 'duration',\n        set: function set(value) {\n            this._flvDuration = value / 1000;\n            this._duration = this._duration | this._flvDuration;\n        }\n    }, {\n        key: 'mediaInfo',\n        get: function get() {\n            return this._mediaInfo;\n        }\n    }]);\n\n    return FlvDemux;\n}();\n\nexports.default = FlvDemux;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/flv/flv-demux.js?")},"./src/demux/flv/flv.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _flvDemux = __webpack_require__(/*! ./flv-demux */ \"./src/demux/flv/flv-demux.js\");\n\nvar _flvDemux2 = _interopRequireDefault(_flvDemux);\n\nvar _mp4Remuxer = __webpack_require__(/*! ../../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.js\");\n\nvar _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);\n\nvar _ioLoader = __webpack_require__(/*! ../../io/io-loader */ \"./src/io/io-loader.js\");\n\nvar _ioLoader2 = _interopRequireDefault(_ioLoader);\n\nvar _kernelEvents = __webpack_require__(/*! ../../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _reportTypes = __webpack_require__(/*! ../../core/report-types */ \"./src/core/report-types.js\");\n\nvar _kernelErrors = __webpack_require__(/*! ../../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Flv = function () {\n    function Flv(observer, config) {\n        var _this = this;\n\n        _classCallCheck(this, Flv);\n\n        this._observer = observer;\n        this._config = config;\n\n        this._loaderCallbacks = {\n            onProgress: this._onProgress.bind(this),\n            onError: this._onLoaderError.bind(this),\n            onEnd: this._onLoaderEnd.bind(this),\n            onInfo: this._onInfo.bind(this)\n        };\n\n        observer.on(_kernelEvents2.default.PARSING_DATA, function () {\n            _this._contiguous = true;\n            _this._switchStream = false;\n            _this._seek = false;\n        });\n\n        this._baseTime = config.startFromKeyframePoint;\n\n        this._contiguous = false;\n        this._discontinuity = false;\n    }\n\n    _createClass(Flv, [{\n        key: 'init',\n        value: function init() {\n            var config = this._config,\n                observer = this._observer;\n\n            var demuxConf = {\n                skipLostFrame: config.skipLostFrame,\n                alignBase: config.alignBase,\n                stretchShortVideoTrack: false,\n                maxBufferHole: 0.5,\n                maxAudioFramesDrift: 1, // used by mp4-remuxer\n                forceKeyFrameOnDiscontinuity: true // used by ts-demuxer\n            };\n            var remuxer = this._remuxer = new _mp4Remuxer2.default(observer, demuxConf, { mp4: true }, navigator.vendor);\n            this._switchStream = !!config.alignBase;\n            var demuxer = this._demuxer = new _flvDemux2.default(observer, remuxer, demuxConf);\n            demuxer.duration = config.duration || 0;\n        }\n    }, {\n        key: 'loadSource',\n        value: function loadSource() {\n            if (!this._loader) {\n                this._loader = new _ioLoader2.default(this._config);\n            }\n            this._loader.open(this._loaderCallbacks);\n        }\n    }, {\n        key: 'seek',\n        value: function seek(keyframe) {\n            this._seek = true;\n            this._contiguous = false;\n            this._loader.seek(keyframe.keyframePoint, keyframe.keyframetime);\n            this._demuxer.flush();\n            this._remuxer.resetInitSegment();\n            this._remuxer.resetTimeStamp();\n        }\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this._loader.pause();\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this._loader.resume();\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this._loader) {\n                this._loader.destroy();\n                this._loader = null;\n            }\n            if (this._demuxer) {\n                this._demuxer = null;\n            }\n            if (this._remuxer) {\n                this._remuxer = null;\n            }\n        }\n    }, {\n        key: '_discontinuityCallback',\n        value: function _discontinuityCallback(baseTime) {\n            this._baseTime = baseTime;\n            this._discontinuity = true;\n            this._demuxer.flush();\n            this._remuxer.resetInitSegment();\n            this._remuxer.resetTimeStamp();\n        }\n    }, {\n        key: '_onProgress',\n        value: function _onProgress(context, data, keyframePoint) {\n            var demuxer = this._demuxer;\n            var info = {\n                type: _reportTypes.REPORT_TYPES.LOADER_CHUNK_ARRIVAL,\n                byteLength: data.byteLength,\n                ts: context.ts\n            };\n            this._observer.trigger(_kernelEvents2.default.REPORT, info);\n\n            if (typeof keyframePoint !== 'undefined') {\n                this._baseTime = keyframePoint;\n                this._contiguous = false;\n                this._demuxer.flush();\n            }\n\n            var accurateTimeOffset = !(this._switchStream || this._seek);\n            demuxer.setFlv(data, (this._baseTime || 0) / 1000, this._contiguous, accurateTimeOffset);\n        }\n    }, {\n        key: '_onInfo',\n        value: function _onInfo(handle) {\n            if (handle.type === 'loadInfo') {\n                this._observer.trigger(_kernelEvents2.default.REPORT, handle.data);\n            } else if (handle.type === 'discontinuity') {\n                this._discontinuityCallback(handle.data);\n            }\n        }\n    }, {\n        key: '_onLoaderError',\n        value: function _onLoaderError(context, handle) {\n            var errInfo = {\n                type: _kernelErrors.ErrorTypes.NETWORK_ERROR,\n                details: handle.text === 'timeout' ? _kernelErrors.ErrorDetails.LOAD_TIMEOUT : _kernelErrors.ErrorDetails.LOAD_ERROR,\n                fatal: true,\n                reason: handle.text,\n                statusCode: handle.code,\n                url: context.src\n            };\n            self.postMessage({ event: _kernelEvents2.default.ERROR, data: errInfo });\n        }\n    }, {\n        key: '_onLoaderEnd',\n        value: function _onLoaderEnd() {\n            this._observer.trigger(_kernelEvents2.default.END);\n        }\n    }]);\n\n    return Flv;\n}();\n\nexports.default = Flv;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/flv/flv.js?")},"./src/demux/flv/flvTag.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/* eslint-disable */\nvar FlvTag = function FlvTag() {\n    _classCallCheck(this, FlvTag);\n\n    this.tagType = -1;\n    this.dataSize = -1;\n    this.timestamp = -1;\n    this.body = -1;\n    this.size = -1;\n};\n\nexports.default = FlvTag;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/flv/flvTag.js?')},"./src/demux/flv/media-info.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nvar MediaInfo = function MediaInfo() {\n    _classCallCheck(this, MediaInfo);\n\n    this.mimeType = null;\n    this.duration = null;\n\n    this.hasAudio = null;\n    this.hasVideo = null;\n    this.audioCodec = null;\n    this.videoCodec = null;\n    this.audioDataRate = null;\n    this.videoDataRate = null;\n\n    this.audioSampleRate = null;\n    this.audioChannelCount = null;\n\n    this.width = null;\n    this.height = null;\n    this.fps = null;\n    this.profile = null;\n    this.level = null;\n    this.chromaFormat = null;\n    this.sarNum = null;\n    this.sarDen = null;\n\n    this.metadata = null;\n    this.segments = null; // MediaInfo[]\n    this.segmentCount = null;\n    this.hasKeyframesIndex = null;\n    this.keyframesIndex = null;\n};\n\nexports.default = MediaInfo;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/flv/media-info.js?')},"./src/demux/hls/hls.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n// import MP4Demuxer from '../hls/demux/mp4demuxer';\n// import PassThroughRemuxer from '../hls/remux/passthrough-remuxer';\n\n\nvar _m3u = __webpack_require__(/*! ./m3u8 */ \"./src/demux/hls/m3u8.js\");\n\nvar _m3u2 = _interopRequireDefault(_m3u);\n\nvar _kernelEvents = __webpack_require__(/*! ../../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _tsdemuxer = __webpack_require__(/*! ./tsdemuxer */ \"./src/demux/hls/tsdemuxer.js\");\n\nvar _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);\n\nvar _mp4Remuxer = __webpack_require__(/*! ../../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.js\");\n\nvar _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);\n\nvar _reportTypes = __webpack_require__(/*! ../../core/report-types */ \"./src/core/report-types.js\");\n\nvar _kernelErrors = __webpack_require__(/*! ../../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nvar _downloadCache = __webpack_require__(/*! ../../io/download-cache */ \"./src/io/download-cache.js\");\n\nvar _downloadCache2 = _interopRequireDefault(_downloadCache);\n\nvar _fetch = __webpack_require__(/*! ../../io/fetch */ \"./src/io/fetch.js\");\n\nvar _fetch2 = _interopRequireDefault(_fetch);\n\nvar _xhrRange = __webpack_require__(/*! ../../io/xhr-range */ \"./src/io/xhr-range.js\");\n\nvar _xhrRange2 = _interopRequireDefault(_xhrRange);\n\nvar _xhrMozChunk = __webpack_require__(/*! ../../io/xhr-moz-chunk */ \"./src/io/xhr-moz-chunk.js\");\n\nvar _xhrMozChunk2 = _interopRequireDefault(_xhrMozChunk);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HLS = function () {\n    function HLS(observer, config, typeSupported) {\n        _classCallCheck(this, HLS);\n\n        this.tag = 'TransmuxerHls';\n        this._observer = observer;\n        this._config = config;\n        this._selectLoader();\n\n        this._typeSupported = typeSupported;\n\n        this._demuxConfig = {\n            maxBufferHole: 0.5,\n            stretchShortVideoTrack: false, // used by mp4-remuxer\n            maxAudioFramesDrift: 1, // used by mp4-remuxer\n            forceKeyFrameOnDiscontinuity: false // used by ts-demuxer\n        };\n\n        this.vendor = navigator.vendor;\n\n        this._frag = null;\n        this._totalduration = 0;\n\n        this._cache = new _downloadCache2.default();\n        this._progressCount = 0;\n\n        this.MUX_MIN_LEN = 188 * 512;\n    }\n\n    _createClass(HLS, [{\n        key: 'init',\n        value: function init() {\n            var _this = this;\n\n            this._m3u8 = new _m3u2.default(this._config);\n            this._m3u8.on(_kernelEvents2.default.MANIFEST_PARSED, this._onManifest.bind(this));\n            this._m3u8.on(_kernelEvents2.default.HLS_FRAG_LOAD_PROGRESS, this._onFragProgress.bind(this));\n            this._m3u8.on(_kernelEvents2.default.HLS_FRAG_LOADED, this._onFragLoaded.bind(this));\n            this._m3u8.on(_kernelEvents2.default.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n            this._m3u8.on(_kernelEvents2.default.LEVEL_UPDATED, this._onLevelUpdated.bind(this));\n            this._m3u8.on(_kernelEvents2.default.LEVEL_LOADED, this._onLevelLoaded.bind(this));\n            this._m3u8.on(_kernelEvents2.default.ERROR, function (data) {\n                _this._observer.trigger(_kernelEvents2.default.ERROR, data);\n            });\n            this._m3u8.on(_kernelEvents2.default.END, function () {\n                _this._observer.trigger(_kernelEvents2.default.END);\n            });\n            this._m3u8.init();\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            var m3u8 = this._m3u8;\n            if (m3u8) {\n                m3u8.removeAllListeners();\n                m3u8.destroy();\n                this._m3u8 = null;\n            }\n\n            var demuxer = this._demuxer;\n            if (demuxer) {\n                demuxer.destroy();\n                this._demuxer = null;\n            }\n        }\n    }, {\n        key: 'loadSource',\n        value: function loadSource() {\n            this._m3u8.loadSource();\n        }\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this._paused = true;\n            this._m3u8.pause();\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this._paused = false;\n            this._m3u8.resume();\n        }\n    }, {\n        key: 'seek',\n        value: function seek(time) {\n            if (this._m3u8) {\n                this._m3u8.seek(time);\n            }\n            this._seek = true;\n\n            this._reset();\n        }\n    }, {\n        key: 'getStreamTime',\n        value: function getStreamTime() {}\n    }, {\n        key: 'getBitrates',\n        value: function getBitrates() {\n            if (this._m3u8) {\n                return this._m3u8.getBitrates();\n            }\n            return [];\n        }\n    }, {\n        key: 'selectBitrate',\n        value: function selectBitrate(value, currentTime) {\n            if (this._m3u8) {\n                this._m3u8.selectBitrate(value, currentTime);\n            }\n            this._frag = null;\n            this._seek = true;\n            this._reset();\n        }\n    }, {\n        key: '_reset',\n        value: function _reset() {\n            this._cache.flush();\n            this._progressCount = 0;\n            this._paused = false;\n\n            this._demuxer.reset();\n            this._remuxer.resetInitSegment();\n            this._remuxer.resetTimeStamp();\n        }\n    }, {\n        key: '_getFragsInfo',\n        value: function _getFragsInfo() {\n            if (this._m3u8 && this._m3u8.currentLevel && this._m3u8.currentLevel.details) {\n                var fragsInfo = [];\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this._m3u8.currentLevel.details.fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var frag = _step.value;\n\n                        fragsInfo.push({ start: frag.start, url: frag.url });\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                return fragsInfo;\n            }\n            return null;\n        }\n    }, {\n        key: '_onManifest',\n        value: function _onManifest(data) {\n            this._observer.trigger(_kernelEvents2.default.MANIFEST_PARSED, data);\n        }\n    }, {\n        key: '_onFragProgress',\n        value: function _onFragProgress(data) {\n            if (this._config.hlsStreamingMux) {\n                var info = {\n                    type: _reportTypes.REPORT_TYPES.LOADER_CHUNK_ARRIVAL,\n                    byteLength: data.data.byteLength,\n                    ts: Date.now()\n                };\n                this._observer.trigger('report', info);\n\n                var cache = this._cache;\n                cache.pushData(data.data);\n                var len = Math.floor(cache.unreadLen / 188) * 188 - this.MUX_MIN_LEN;\n\n                var frag = data.context.frag;\n                var lastFrag = this._frag;\n                var trackSwitch = !(lastFrag && frag.level === lastFrag.level);\n\n                this._timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;\n                this._discontinuity = (!(lastFrag && frag.cc === lastFrag.cc) || trackSwitch) && this._progressCount === 0;\n                var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;\n                this._contiguous = !trackSwitch && nextSN || this._progressCount > 0;\n                // 单次处理数据需要大于MUX_MIN_LEN\n                if (len < this.MUX_MIN_LEN || this._paused) {\n                    return;\n                }\n                var demuxData = cache.getData(len);\n                this._push(demuxData, this._timeOffset, this._contiguous, this._discontinuity, !this._seek);\n                this._progressCount++;\n            }\n        }\n    }, {\n        key: '_onFragLoaded',\n        value: function _onFragLoaded(data) {\n            if (this._config.hlsStreamingMux) {\n                if (this._progressCount > 0) {\n                    this._discontinuity = false;\n                    this._contiguous = true;\n                }\n                this._progressCount = 0;\n                var cache = this._cache;\n                var len = Math.floor(cache.unreadLen / 188) * 188;\n                if (!this._paused) {\n                    if (len) {\n                        var demuxData = cache.getData(len);\n                        this._push(demuxData, this._timeOffset, this._contiguous, this._discontinuity, !this._seek);\n                    }\n                    cache.flush();\n                    this._demuxer.flush();\n                }\n                this._frag = data.context.frag;\n            } else {\n                var info = {\n                    type: _reportTypes.REPORT_TYPES.LOADER_CHUNK_ARRIVAL,\n                    byteLength: data.data.byteLength,\n                    ts: Date.now()\n                };\n                this._observer.trigger('report', info);\n                var frag = data.context.frag;\n                var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;\n                var lastFrag = this._frag;\n                var trackSwitch = !(lastFrag && frag.level === lastFrag.level);\n                var discontinuity = !(lastFrag && frag.cc === lastFrag.cc) || trackSwitch;\n                var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;\n                var contiguous = !trackSwitch && nextSN;\n                this._push(new Uint8Array(data.data), timeOffset, contiguous, discontinuity, !this._seek);\n                this._frag = frag;\n            }\n        }\n    }, {\n        key: '_onLevelSwitched',\n        value: function _onLevelSwitched() {\n            this._observer.trigger(_kernelEvents2.default.LEVEL_SWITCHED, {\n                bitrate: this._m3u8.currentLevel.bitrate,\n                smooth: false,\n                level: this._m3u8.currentLevel\n            });\n        }\n    }, {\n        key: '_onLevelUpdated',\n        value: function _onLevelUpdated(data) {\n            this._totalduration = data.details.totalduration;\n            this._observer.trigger(_kernelEvents2.default.LEVEL_UPDATED, this._getFragsInfo());\n        }\n    }, {\n        key: '_onLevelLoaded',\n        value: function _onLevelLoaded(data) {\n            this._observer.trigger(_kernelEvents2.default.LEVEL_LOADED, data);\n        }\n    }, {\n        key: '_push',\n        value: function _push(data, timeOffset, contiguous, discontinuity, accurateTimeOffset) {\n            this._seek = false;\n            var demuxer = this._demuxer;\n            if (!demuxer || discontinuity && !this.probe(data)) {\n                var observer = this._observer;\n                var typeSupported = this._typeSupported;\n                var config = this._demuxConfig;\n                // probing order is TS/MP4\n                var muxConfig = [{ Demux: _tsdemuxer2.default, Remux: _mp4Remuxer2.default }];\n\n                // probe for content type\n                for (var i = 0, len = muxConfig.length; i < len; i++) {\n                    var mux = muxConfig[i];\n                    var probe = mux.Demux.probe;\n                    if (probe(data)) {\n                        var _remuxer = this._remuxer = new mux.Remux(observer, config, typeSupported, this.vendor);\n                        demuxer = new mux.Demux(observer, _remuxer, config, typeSupported);\n                        this.probe = probe;\n                        break;\n                    }\n                }\n                if (!demuxer) {\n                    this._observer.trigger(_kernelEvents2.default.ERROR, {\n                        type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                        details: _kernelErrors.ErrorDetails.PARSING_ERROR,\n                        fatal: true,\n                        reason: 'no demux matching with content found'\n                    });\n                    return;\n                }\n                this._demuxer = demuxer;\n            }\n            var remuxer = this._remuxer;\n\n            if (discontinuity) {\n                demuxer.resetInitSegment(null, null, null, this._totalduration);\n                demuxer.resetTimeStamp();\n                remuxer.resetInitSegment();\n                remuxer.resetTimeStamp();\n            }\n            demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);\n        }\n    }, {\n        key: '_selectLoader',\n        value: function _selectLoader() {\n            var config = this._config;\n            if (this._config.hlsStreamingMux) {\n                if (_fetch2.default.isSupport()) {\n                    config.fragLoader = _fetch2.default;\n                } else if (_xhrMozChunk2.default.isSupport()) {\n                    config.fragLoader = _xhrMozChunk2.default;\n                } else {\n                    config.fragLoader = _xhrRange2.default;\n                    this._config.hlsStreamingMux = false;\n                }\n            } else {\n                config.fragLoader = _xhrRange2.default;\n            }\n            config.pLoader = _xhrRange2.default;\n        }\n    }]);\n\n    return HLS;\n}();\n\nexports.default = HLS;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/hls.js?")},"./src/demux/hls/loader/fragment.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _urlToolkit = __webpack_require__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nvar _levelKey = __webpack_require__(/*! ./level-key */ \"./src/demux/hls/loader/level-key.js\");\n\nvar _levelKey2 = _interopRequireDefault(_levelKey);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Fragment = function () {\n    function Fragment() {\n        var _elementaryStreams;\n\n        _classCallCheck(this, Fragment);\n\n        this._url = null;\n        this._byteRange = null;\n        this._decryptdata = null;\n        this.tagList = [];\n\n        // Holds the types of data this fragment supports\n        this._elementaryStreams = (_elementaryStreams = {}, _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.AUDIO, false), _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.VIDEO, false), _elementaryStreams);\n    }\n\n    /**\n     * `type` property for this._elementaryStreams\n     *\n     * @enum {string}\n     */\n\n\n    _createClass(Fragment, [{\n        key: 'addElementaryStream',\n\n\n        /**\n         * @param {ElementaryStreamType} type ElementaryStreamType\n         */\n        value: function addElementaryStream(type) {\n            this._elementaryStreams[type] = true;\n        }\n\n        /**\n         * @param {ElementaryStreamType} type ElementaryStreamType\n         * @returns {boolean} hasElementaryStream\n         */\n\n    }, {\n        key: 'hasElementaryStream',\n        value: function hasElementaryStream(type) {\n            return this._elementaryStreams[type] === true;\n        }\n\n        /**\n         * Utility method for parseLevelPlaylist to create an initialization vector for a given segment\n         * @param {number} segmentNumber segmentNumber\n         * @returns {Uint8Array} InitializationVector\n         */\n\n    }, {\n        key: 'createInitializationVector',\n        value: function createInitializationVector(segmentNumber) {\n            var uint8View = new Uint8Array(16);\n\n            for (var i = 12; i < 16; i++) {\n                uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n            }\n\n            return uint8View;\n        }\n\n        /**\n         * Utility method for parseLevelPlaylist to get a fragment's decryption data\n         * from the currently parsed encryption key data\n         * @param {LevelKey} levelkey - a playlist's encryption info\n         * @param {number }segmentNumber - the fragment's segment number\n         * @returns {*} - an object to be applied as a fragment's decryptdata\n         */\n\n    }, {\n        key: 'fragmentDecryptdataFromLevelkey',\n        value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {\n            var decryptdata = levelkey;\n\n            if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {\n                decryptdata = new _levelKey2.default();\n                decryptdata.method = levelkey.method;\n                decryptdata.baseuri = levelkey.baseuri;\n                decryptdata.reluri = levelkey.reluri;\n                decryptdata.iv = this.createInitializationVector(segmentNumber);\n            }\n\n            return decryptdata;\n        }\n    }, {\n        key: 'url',\n        get: function get() {\n            if (!this._url && this.relurl) {\n                this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });\n            }\n\n            return this._url;\n        },\n        set: function set(value) {\n            this._url = value;\n        }\n    }, {\n        key: 'programDateTime',\n        get: function get() {\n            if (!this._programDateTime && this.rawProgramDateTime) {\n                this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));\n            }\n\n            return this._programDateTime;\n        }\n    }, {\n        key: 'byteRange',\n        get: function get() {\n            if (!this._byteRange && !this.rawByteRange) {\n                return [];\n            }\n\n            if (this._byteRange) {\n                return this._byteRange;\n            }\n\n            var byteRange = [];\n            if (this.rawByteRange) {\n                var params = this.rawByteRange.split('@', 2);\n                if (params.length === 1) {\n                    var lastByteRangeEndOffset = this.lastByteRangeEndOffset;\n                    byteRange[0] = lastByteRangeEndOffset || 0;\n                } else {\n                    byteRange[0] = parseInt(params[1], 10);\n                }\n                byteRange[1] = parseInt(params[0], 10) + byteRange[0];\n                this._byteRange = byteRange;\n            }\n            return byteRange;\n        }\n\n        /**\n         * @type {number}\n         */\n\n    }, {\n        key: 'byteRangeStartOffset',\n        get: function get() {\n            return this.byteRange[0];\n        }\n    }, {\n        key: 'byteRangeEndOffset',\n        get: function get() {\n            return this.byteRange[1];\n        }\n    }, {\n        key: 'decryptdata',\n        get: function get() {\n            if (!this._decryptdata) {\n                this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);\n            }\n\n            return this._decryptdata;\n        }\n    }, {\n        key: 'encrypted',\n        get: function get() {\n            return !!(this.decryptdata && this.decryptdata.uri !== null && this.decryptdata.key === null);\n        }\n    }], [{\n        key: 'ElementaryStreamTypes',\n        get: function get() {\n            return {\n                AUDIO: 'audio',\n                VIDEO: 'video'\n            };\n        }\n    }]);\n\n    return Fragment;\n}();\n\nexports.default = Fragment;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/loader/fragment.js?")},"./src/demux/hls/loader/level-key.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _urlToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar LevelKey = function () {\n    function LevelKey() {\n        _classCallCheck(this, LevelKey);\n\n        this.method = null;\n        this.key = null;\n        this.iv = null;\n        this._uri = null;\n    }\n\n    _createClass(LevelKey, [{\n        key: \'uri\',\n        get: function get() {\n            if (!this._uri && this.reluri) {\n                this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });\n            }\n\n            return this._uri;\n        }\n    }]);\n\n    return LevelKey;\n}();\n\nexports.default = LevelKey;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/loader/level-key.js?')},"./src/demux/hls/loader/m3u8-parser.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _urlToolkit = __webpack_require__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nvar _fragment = __webpack_require__(/*! ./fragment */ \"./src/demux/hls/loader/fragment.js\");\n\nvar _fragment2 = _interopRequireDefault(_fragment);\n\nvar _levelKey = __webpack_require__(/*! ./level-key */ \"./src/demux/hls/loader/level-key.js\");\n\nvar _levelKey2 = _interopRequireDefault(_levelKey);\n\nvar _attrList = __webpack_require__(/*! ../../../utils/attr-list */ \"./src/utils/attr-list.js\");\n\nvar _attrList2 = _interopRequireDefault(_attrList);\n\nvar _log = __webpack_require__(/*! ../../../utils/log */ \"./src/utils/log.js\");\n\nvar _codecs = __webpack_require__(/*! ../../../utils/codecs */ \"./src/utils/codecs.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * M3U8 parser\n * @module\n */\n\n// https://regex101.com is your friend\nvar MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g;\nvar MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\n\nvar LEVEL_PLAYLIST_REGEX_FAST = new RegExp([\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, /|(?!#)(\\S+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)\n/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)\n/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec\n/|#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join(''), 'g');\n\nvar LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\\d+))|(?:#EXT-X-(TARGETDURATION): *(\\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\\r?\\n?/; // eslint-disable-line\n\nvar MP4_REGEX_SUFFIX = /\\.(mp4|m4s|m4v|m4a)$/i;\n\nvar M3U8Parser = function () {\n    function M3U8Parser() {\n        _classCallCheck(this, M3U8Parser);\n    }\n\n    _createClass(M3U8Parser, null, [{\n        key: 'findGroup',\n        value: function findGroup(groups, mediaGroupId) {\n            if (!groups) {\n                return null;\n            }\n\n            var matchingGroup = null;\n\n            for (var i = 0; i < groups.length; i++) {\n                var group = groups[i];\n                if (group.id === mediaGroupId) {\n                    matchingGroup = group;\n                }\n            }\n\n            return matchingGroup;\n        }\n    }, {\n        key: 'convertAVC1ToAVCOTI',\n        value: function convertAVC1ToAVCOTI(codec) {\n            var result = void 0;\n            var avcdata = codec.split('.');\n            if (avcdata.length > 2) {\n                result = avcdata.shift() + '.';\n                result += parseInt(avcdata.shift(), 10).toString(16);\n                result += ('000' + parseInt(avcdata.shift(), 10).toString(16)).substr(-4);\n            } else {\n                result = codec;\n            }\n            return result;\n        }\n    }, {\n        key: 'resolve',\n        value: function resolve(url, baseUrl) {\n            return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });\n        }\n    }, {\n        key: 'parseMasterPlaylist',\n        value: function parseMasterPlaylist(string, baseurl) {\n            var levels = [];\n            var result = void 0;\n            MASTER_PLAYLIST_REGEX.lastIndex = 0;\n\n            function setCodecs(codecs, level) {\n                ['video', 'audio'].forEach(function (type) {\n                    var filtered = codecs.filter(function (codec) {\n                        return (0, _codecs.isCodecType)(codec, type);\n                    });\n                    if (filtered.length) {\n                        var preferred = filtered.filter(function (codec) {\n                            return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n                        });\n                        level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];\n\n                        // remove from list\n                        codecs = codecs.filter(function (codec) {\n                            return filtered.indexOf(codec) === -1;\n                        });\n                    }\n                });\n\n                level.unknownCodecs = codecs;\n            }\n\n            while ((result = MASTER_PLAYLIST_REGEX.exec(string)) !== null) {\n                var level = {};\n\n                var attrs = level.attrs = new _attrList2.default(result[1]);\n                level.url = M3U8Parser.resolve(result[2], baseurl);\n\n                var resolution = attrs.decimalResolution('RESOLUTION');\n                if (resolution) {\n                    level.width = resolution.width;\n                    level.height = resolution.height;\n                }\n                level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');\n                level.name = attrs.NAME;\n\n                setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);\n\n                if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n                    level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n                }\n\n                levels.push(level);\n            }\n            return levels;\n        }\n    }, {\n        key: 'parseMasterPlaylistMedia',\n        value: function parseMasterPlaylistMedia(string, baseurl, type) {\n            var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n            var result = void 0;\n            var medias = [];\n            var id = 0;\n            MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n            while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n                var media = {};\n                var attrs = new _attrList2.default(result[1]);\n                if (attrs.TYPE === type) {\n                    media.groupId = attrs['GROUP-ID'];\n                    media.name = attrs.NAME;\n                    media.type = type;\n                    media.default = attrs.DEFAULT === 'YES';\n                    media.autoselect = attrs.AUTOSELECT === 'YES';\n                    media.forced = attrs.FORCED === 'YES';\n                    if (attrs.URI) {\n                        media.url = M3U8Parser.resolve(attrs.URI, baseurl);\n                    }\n\n                    media.lang = attrs.LANGUAGE;\n                    if (!media.name) {\n                        media.name = media.lang;\n                    }\n\n                    if (audioGroups.length) {\n                        var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);\n                        media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;\n                    }\n                    media.id = id++;\n                    medias.push(media);\n                }\n            }\n            return medias;\n        }\n    }, {\n        key: 'parseLevelPlaylist',\n        value: function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {\n            var currentSN = 0,\n                totalduration = 0,\n                levelkey = new _levelKey2.default(),\n                cc = 0,\n                prevFrag = null,\n                frag = new _fragment2.default(),\n                result = void 0,\n                i = void 0;\n            var level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 };\n\n            LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n\n            while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n                var duration = result[1];\n                if (duration) {\n                    // INF\n                    frag.duration = parseFloat(duration);\n                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                    var title = (' ' + result[2]).slice(1);\n                    frag.title = title || null;\n                    frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n                } else if (result[3]) {\n                    // url\n                    if (!isNaN(frag.duration)) {\n                        var sn = currentSN++;\n                        frag.type = type;\n                        frag.start = totalduration;\n                        frag.levelkey = levelkey;\n                        frag.sn = sn;\n                        frag.level = id;\n                        frag.cc = cc;\n                        frag.urlId = levelUrlId;\n                        frag.baseurl = baseurl;\n                        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                        frag.relurl = (' ' + result[3]).slice(1);\n\n                        if (level.programDateTime) {\n                            if (prevFrag) {\n                                if (frag.rawProgramDateTime) {\n                                    // PDT discontinuity found\n                                    frag.pdt = Date.parse(frag.rawProgramDateTime);\n                                } else {\n                                    // Contiguous fragment\n                                    frag.pdt = prevFrag.pdt + prevFrag.duration * 1000;\n                                }\n                            } else {\n                                // First fragment\n                                frag.pdt = Date.parse(level.programDateTime);\n                            }\n                            frag.endPdt = frag.pdt + frag.duration * 1000;\n                        }\n\n                        level.fragments.push(frag);\n                        prevFrag = frag;\n                        totalduration += frag.duration;\n\n                        frag = new _fragment2.default();\n                    }\n                } else if (result[4]) {\n                    // X-BYTERANGE\n                    frag.rawByteRange = (' ' + result[4]).slice(1);\n                    if (prevFrag) {\n                        var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;\n                        if (lastByteRangeEndOffset) {\n                            frag.lastByteRangeEndOffset = lastByteRangeEndOffset;\n                        }\n                    }\n                } else if (result[5]) {\n                    // PROGRAM-DATE-TIME\n                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                    frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n                    frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n                    if (typeof level.programDateTime === 'undefined') {\n                        level.programDateTime = new Date(new Date(Date.parse(result[5])) - 1000 * totalduration);\n                    }\n                } else {\n                    result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n                    for (i = 1; i < result.length; i++) {\n                        if (typeof result[i] !== 'undefined') {\n                            break;\n                        }\n                    }\n\n                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                    var value1 = (' ' + result[i + 1]).slice(1);\n                    var value2 = (' ' + result[i + 2]).slice(1);\n\n                    switch (result[i]) {\n                        case '#':\n                            frag.tagList.push(value2 ? [value1, value2] : [value1]);\n                            break;\n                        case 'PLAYLIST-TYPE':\n                            level.type = value1.toUpperCase();\n                            break;\n                        case 'MEDIA-SEQUENCE':\n                            currentSN = level.startSN = parseInt(value1, 10);\n                            break;\n                        case 'TARGETDURATION':\n                            level.targetduration = parseFloat(value1);\n                            break;\n                        case 'VERSION':\n                            level.version = parseInt(value1, 10);\n                            break;\n                        case 'EXTM3U':\n                            break;\n                        case 'ENDLIST':\n                            level.live = false;\n                            break;\n                        case 'DIS':\n                            cc++;\n                            frag.tagList.push(['DIS']);\n                            break;\n                        case 'DISCONTINUITY-SEQ':\n                            cc = parseInt(value1, 10);\n                            break;\n                        case 'KEY':\n                            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4\n                            {\n                                var decryptparams = value1;\n                                var keyAttrs = new _attrList2.default(decryptparams);\n                                var decryptmethod = keyAttrs.enumeratedString('METHOD'),\n                                    decrypturi = keyAttrs.URI,\n                                    decryptiv = keyAttrs.hexadecimalInteger('IV');\n                                if (decryptmethod) {\n                                    levelkey = new _levelKey2.default();\n                                    if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {\n                                        levelkey.method = decryptmethod;\n                                        // URI to get the key\n                                        levelkey.baseuri = baseurl;\n                                        levelkey.reluri = decrypturi;\n                                        levelkey.key = null;\n                                        // Initialization Vector (IV)\n                                        levelkey.iv = decryptiv;\n                                    }\n                                }\n                            }\n                            break;\n                        case 'START':\n                            {\n                                var startParams = value1;\n                                var startAttrs = new _attrList2.default(startParams);\n                                var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n                                // TIME-OFFSET can be 0\n                                if (!isNaN(startTimeOffset)) {\n                                    level.startTimeOffset = startTimeOffset;\n                                }\n                            }\n                            break;\n                        case 'MAP':\n                            {\n                                var mapAttrs = new _attrList2.default(value1);\n                                frag.relurl = mapAttrs.URI;\n                                frag.rawByteRange = mapAttrs.BYTERANGE;\n                                frag.baseurl = baseurl;\n                                frag.level = id;\n                                frag.type = type;\n                                frag.sn = 'initSegment';\n                                level.initSegment = frag;\n                                frag = new _fragment2.default();\n                            }\n                            break;\n                        default:\n                            _log.Log.w('line parsed but not handled: ' + result);\n                            break;\n                    }\n                }\n            }\n            frag = prevFrag;\n            // logger.log('found ' + level.fragments.length + ' fragments');\n            if (frag && !frag.relurl) {\n                level.fragments.pop();\n                totalduration -= frag.duration;\n            }\n            level.totalduration = totalduration;\n            level.averagetargetduration = totalduration / level.fragments.length;\n            level.endSN = currentSN - 1;\n            level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;\n            level.endCC = cc;\n\n            if (!level.initSegment && level.fragments.length) {\n                // this is a bit lurky but HLS really has no other way to tell us\n                // if the fragments are TS or MP4, except if we download them :/\n                // but this is to be able to handle SIDX.\n                if (level.fragments.every(function (frag) {\n                    return MP4_REGEX_SUFFIX.test(frag.relurl);\n                })) {\n                    logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');\n\n                    frag = new _fragment2.default();\n                    frag.relurl = level.fragments[0].relurl;\n                    frag.baseurl = baseurl;\n                    frag.level = id;\n                    frag.type = type;\n                    frag.sn = 'initSegment';\n\n                    level.initSegment = frag;\n                    level.needSidxRanges = true;\n                }\n            }\n\n            return level;\n        }\n    }]);\n\n    return M3U8Parser;\n}();\n\nexports.default = M3U8Parser;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/loader/m3u8-parser.js?")},"./src/demux/hls/loader/playlist-loader.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _kernelEvents = __webpack_require__(/*! ../../../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _kernelErrors = __webpack_require__(/*! ../../../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nvar _log = __webpack_require__(/*! ../../../utils/log */ \"./src/utils/log.js\");\n\nvar _m3u8Parser = __webpack_require__(/*! ./m3u8-parser */ \"./src/demux/hls/loader/m3u8-parser.js\");\n\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * PlaylistLoader - delegate for media manifest/playlist loading tasks.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Takes care of parsing media to internal data-models.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Once loaded, dispatches events with parsed data-models of manifest/levels/audio tracks.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Uses loader(s) set in config to do actual internal loading of resource tasks.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n// import MP4Demuxer from '../demux/mp4demuxer';\n\n\n/**\n * `type` property values for this loaders' context object\n * @enum\n *\n */\nvar ContextType = {\n    MANIFEST: 'manifest',\n    LEVEL: 'level'\n};\n\n/**\n * @enum {string}\n */\nvar LevelType = {\n    MAIN: 'main'\n};\n\n/**\n * @constructor\n */\n\nvar PlaylistLoader = function (_Events) {\n    _inherits(PlaylistLoader, _Events);\n\n    /**\n     * @constructs\n     */\n    function PlaylistLoader(config) {\n        _classCallCheck(this, PlaylistLoader);\n\n        var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this));\n\n        _this.tag = 'PlaylistLoader';\n        _this._config = config;\n        _this.loaders = {};\n        return _this;\n    }\n\n    _createClass(PlaylistLoader, [{\n        key: 'createInternalLoader',\n\n\n        /**\n         * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n         * Default loader is XHRLoader (see utils)\n         * @param {object} context context\n         * @returns {XHRLoader} or other compatible configured overload\n         */\n        value: function createInternalLoader(context) {\n            var PLoader = this._config.pLoader;\n            var Loader = this._config.loader;\n            var InternalLoader = PLoader || Loader;\n            var loader = new InternalLoader(this._config);\n\n            context.loader = loader;\n            this.loaders[context.type] = loader;\n\n            return loader;\n        }\n    }, {\n        key: 'getInternalLoader',\n        value: function getInternalLoader(context) {\n            return this.loaders[context.type];\n        }\n    }, {\n        key: 'resetInternalLoader',\n        value: function resetInternalLoader(contextType) {\n            if (this.loaders[contextType]) {\n                delete this.loaders[contextType];\n            }\n        }\n\n        /**\n         * Call `destroy` on all internal loader instances mapped (one per context type)\n         */\n\n    }, {\n        key: 'destroyInternalLoaders',\n        value: function destroyInternalLoaders() {\n            for (var contextType in this.loaders) {\n                var loader = this.loaders[contextType];\n                if (loader) {\n                    loader.destroy();\n                }\n\n                this.resetInternalLoader(contextType);\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.destroyInternalLoaders();\n        }\n    }, {\n        key: 'loadManifest',\n        value: function loadManifest(data) {\n            this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });\n        }\n    }, {\n        key: 'loadLevel',\n        value: function loadLevel(data) {\n            this.load(data.url, { type: ContextType.LEVEL, level: data.level, id: data.id });\n        }\n    }, {\n        key: 'load',\n        value: function load(url, context) {\n            _log.Log.d(this.tag, 'Loading playlist of type ' + context.type + ', level: ' + context.level + ', id: ' + context.id);\n\n            // Check if a loader for this context already exists\n            var loader = this.getInternalLoader(context);\n            if (loader) {\n                var loaderContext = loader.context;\n                if (loaderContext && loaderContext.url === url) {\n                    // same URL can't overlap\n                    _log.Log.i(this.tag, 'playlist request ongoing');\n                    return false;\n                }\n                _log.Log.w(this.tag, 'aborting previous loader for type: ' + context.type);\n                loader.abort();\n            }\n\n            var maxRetry = void 0,\n                timeout = void 0,\n                retryDelay = void 0,\n                maxRetryDelay = void 0;\n\n            // apply different configs for retries depending on\n            // context (manifest, level, audio/subs playlist)\n            switch (context.type) {\n                case ContextType.MANIFEST:\n                    maxRetry = this._config.manifestLoadingMaxRetry;\n                    timeout = this._config.manifestLoadingTimeOut;\n                    retryDelay = this._config.manifestLoadingRetryDelay;\n                    maxRetryDelay = this._config.manifestLoadingMaxRetryTimeout;\n                    break;\n                // TODO:level error retry\n                /*\n                case ContextType.LEVEL:\n                    // Disable internal loader retry logic, since we are managing retries in Level Controller\n                    maxRetry = 0;\n                    timeout = this._config.levelLoadingTimeOut;\n                    // it should not use level retry config\n                    break;\n                    */\n                default:\n                    maxRetry = this._config.levelLoadingMaxRetry;\n                    timeout = this._config.levelLoadingTimeOut;\n                    retryDelay = this._config.levelLoadingRetryDelay;\n                    maxRetryDelay = this._config.levelLoadingMaxRetryTimeout;\n                    break;\n            }\n\n            loader = this.createInternalLoader(context);\n\n            context.src = url;\n            context.responseType = context.responseType || 'text';\n\n            var loaderConfig = {\n                timeout: timeout,\n                maxRetry: maxRetry,\n                retryDelay: retryDelay,\n                maxRetryDelay: maxRetryDelay,\n                credentials: this._config.credentials\n            };\n\n            var loaderCallbacks = {\n                onEnd: this.loadsuccess.bind(this),\n                onError: this.loaderror.bind(this)\n            };\n\n            _log.Log.d(this.tag, 'Calling internal loader delegate for URL: ' + url);\n            loader.open(context, loaderCallbacks, loaderConfig);\n\n            return true;\n        }\n    }, {\n        key: 'loadsuccess',\n        value: function loadsuccess(context, response, stats) {\n            var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n            // if (context.isSidxRequest) {\n            //     this._handleSidxRequest(response, context);\n            //     this._handlePlaylistLoaded(response, context, networkDetails);\n            //     return;\n            // }\n\n            this.resetInternalLoader(context.type);\n\n            var string = response;\n\n            // Validate if it is an M3U8 at all\n            if (string.indexOf('#EXTM3U') !== 0) {\n                this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);\n                return;\n            }\n\n            // Check if chunk-list or master. handle empty chunk list case\n            // (first EXTINF not signaled, but TARGETDURATION present)\n            if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {\n                this._handleTrackOrLevelPlaylist(context, response, stats, networkDetails);\n            } else {\n                this._handleMasterPlaylist(context, response, stats, networkDetails);\n            }\n        }\n    }, {\n        key: 'loaderror',\n        value: function loaderror(context) {\n            var networkDetails = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            this._handleNetworkError(context, networkDetails);\n        }\n    }, {\n        key: '_handleMasterPlaylist',\n        value: function _handleMasterPlaylist(context, response, stats, networkDetails) {\n            var string = response;\n\n            var url = context.responseUrl;\n\n            var levels = _m3u8Parser2.default.parseMasterPlaylist(string, url);\n            if (!levels.length) {\n                this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);\n                return;\n            }\n\n            // multi level playlist, parse level info\n\n            var audioGroups = levels.map(function (level) {\n                return {\n                    id: level.attrs.AUDIO,\n                    codec: level.audioCodec\n                };\n            });\n\n            var audioTracks = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);\n\n            if (audioTracks.length) {\n                // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n                var embeddedAudioFound = false;\n                audioTracks.forEach(function (audioTrack) {\n                    if (!audioTrack.url) {\n                        embeddedAudioFound = true;\n                    }\n                });\n\n                // if no embedded audio track defined, but audio codec signaled in quality level,\n                // we need to signal this main audio track this could happen with playlists with\n                // alt audio rendition in which quality levels (main)\n                // contains both audio+video. but with mixed audio track not signaled\n                if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n                    _log.Log.v(this.tag, 'audio codec signaled in quality level, but no embedded audio track signaled, create one');\n                    audioTracks.unshift({\n                        type: 'main',\n                        name: 'main'\n                    });\n                }\n            }\n\n            this.emit(_kernelEvents2.default.HLS_MANIFEST_LOADED, {\n                levels: levels,\n                audioTracks: audioTracks,\n                url: url,\n                stats: stats,\n                networkDetails: networkDetails\n            });\n        }\n    }, {\n        key: '_handleTrackOrLevelPlaylist',\n        value: function _handleTrackOrLevelPlaylist(context, response, stats, networkDetails) {\n            var id = context.id,\n                level = context.level,\n                type = context.type;\n\n\n            var url = context.responseUrl;\n\n            var levelUrlId = isNaN(id) ? 0 : id;\n            var levelId = isNaN(level) ? levelUrlId : level; // level -> id -> 0\n            var levelType = PlaylistLoader.mapContextToLevelType(context);\n\n            var levelDetails = _m3u8Parser2.default.parseLevelPlaylist(response, url, levelId, levelType, levelUrlId);\n\n            // We have done our first request (Manifest-type) and receive\n            // not a master playlist but a chunk-list (track/level)\n            // We fire the manifest-loaded event anyway with the parsed level-details\n            // by creating a single-level structure for it.\n            if (type === ContextType.MANIFEST) {\n                var singleLevel = {\n                    url: url,\n                    details: levelDetails\n                };\n\n                this.emit(_kernelEvents2.default.HLS_MANIFEST_LOADED, {\n                    levels: [singleLevel],\n                    singleLevel: true,\n                    url: url,\n                    stats: stats,\n                    networkDetails: networkDetails\n                });\n            }\n\n            // extend the context with the new levelDetails property\n            context.levelDetails = levelDetails;\n\n            this._handlePlaylistLoaded(context, response, stats, networkDetails);\n        }\n\n        // _handleSidxRequest(response, context) {\n        //     const sidxInfo = MP4Demuxer.parseSegmentIndex(new Uint8Array(response));\n        //     sidxInfo.references.forEach((segmentRef, index) => {\n        //         const segRefInfo = segmentRef.info;\n        //         const frag = context.levelDetails.fragments[index];\n\n        //         if (frag.byteRange.length === 0) {\n        //             frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);\n        //         }\n        //     });\n\n        //     context.levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';\n        // }\n\n    }, {\n        key: '_handleManifestParsingError',\n        value: function _handleManifestParsingError(response, context, reason, networkDetails) {\n            this.emit(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.NETWORK_ERROR,\n                details: _kernelErrors.ErrorDetails.HLS_MANIFEST_PARSING_ERROR,\n                fatal: true,\n                url: response.url,\n                reason: reason,\n                statusCode: networkDetails.code\n            });\n        }\n    }, {\n        key: '_handleNetworkError',\n        value: function _handleNetworkError(context, networkDetails) {\n            var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            _log.Log.i(this.tag, 'A network error occured while loading a ' + context.type + '-type playlist');\n\n            var details = void 0;\n            var fatal = void 0;\n\n            var loader = this.getInternalLoader(context);\n\n            switch (context.type) {\n                case ContextType.MANIFEST:\n                    details = timeout ? _kernelErrors.ErrorDetails.HLS_MANIFEST_LOAD_TIMEOUT : _kernelErrors.ErrorDetails.HLS_MANIFEST_LOAD_ERROR;\n                    fatal = true;\n                    break;\n                case ContextType.LEVEL:\n                    details = timeout ? _kernelErrors.ErrorDetails.HLS_LEVEL_LOAD_TIMEOUT : _kernelErrors.ErrorDetails.HLS_LEVEL_LOAD_ERROR;\n                    fatal = false;\n                    break;\n                default:\n                    // details = ...?\n                    fatal = false;\n            }\n\n            if (loader) {\n                loader.abort();\n                this.resetInternalLoader(context.type);\n            }\n\n            this.emit(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.NETWORK_ERROR,\n                details: details,\n                fatal: fatal,\n                url: context.src,\n                reason: networkDetails.text,\n                statusCode: networkDetails.code\n            });\n        }\n    }, {\n        key: '_handlePlaylistLoaded',\n        value: function _handlePlaylistLoaded(context, response, stats, networkDetails) {\n            var type = context.type,\n                level = context.level,\n                id = context.id,\n                levelDetails = context.levelDetails;\n\n\n            if (!levelDetails.targetduration) {\n                this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);\n                return;\n            }\n\n            var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);\n            if (canHaveLevels) {\n                this.emit(_kernelEvents2.default.LEVEL_LOADED, {\n                    details: levelDetails,\n                    level: level || 0,\n                    id: id || 0,\n                    stats: stats,\n                    networkDetails: networkDetails\n                });\n            }\n        }\n    }], [{\n        key: 'canHaveQualityLevels',\n\n\n        /**\n         * @param {ContextType} type ContextType\n         * @returns {boolean} canHaveQualityLevels\n         */\n        value: function canHaveQualityLevels(type) {\n            return true;\n        }\n\n        /**\n         * Map context.type to LevelType\n         * @param {{type: ContextType}} context ContextType\n         * @returns {LevelType} mapContextToLevelType\n         */\n\n    }, {\n        key: 'mapContextToLevelType',\n        value: function mapContextToLevelType(context) {\n            var type = context.type;\n\n\n            switch (type) {\n                case ContextType.AUDIO_TRACK:\n                    return LevelType.AUDIO;\n                default:\n                    return LevelType.MAIN;\n            }\n        }\n    }, {\n        key: 'ContextType',\n        get: function get() {\n            return ContextType;\n        }\n    }, {\n        key: 'LevelType',\n        get: function get() {\n            return LevelType;\n        }\n    }]);\n\n    return PlaylistLoader;\n}(_events2.default);\n\nexports.default = PlaylistLoader;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/loader/playlist-loader.js?")},"./src/demux/hls/m3u8.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _playlistLoader = __webpack_require__(/*! ./loader/playlist-loader */ \"./src/demux/hls/loader/playlist-loader.js\");\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar _kernelEvents = __webpack_require__(/*! ../../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _log = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.js\");\n\nvar _kernelErrors = __webpack_require__(/*! ../../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nvar _urlToolkit = __webpack_require__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar M3U8 = function (_Events) {\n    _inherits(M3U8, _Events);\n\n    function M3U8(config) {\n        _classCallCheck(this, M3U8);\n\n        var _this = _possibleConstructorReturn(this, (M3U8.__proto__ || Object.getPrototypeOf(M3U8)).call(this));\n\n        _this.tag = 'HLS';\n        _this._initConfig(config);\n        _this._manifest = null;\n\n        _this._fragPos = 0;\n\n        _this._fragCallback = {\n            onProgress: _this._onProgress.bind(_this),\n            onEnd: _this._onEnd.bind(_this),\n            onError: _this._onError.bind(_this),\n            onInfo: _this._onInfo.bind(_this)\n        };\n        _this._canload = false;\n        _this._canloadFrag = false;\n\n        _this._firstLevel = 0;\n        _this._currentLevelIndex = 0;\n        _this._startTime = config.startFrom / 1000 || null;\n        return _this;\n    }\n\n    _createClass(M3U8, [{\n        key: 'init',\n        value: function init() {\n            var _this2 = this;\n\n            this._playlistLoader = new _playlistLoader2.default(this._config);\n            this._playlistLoader.on(_kernelEvents2.default.HLS_MANIFEST_LOADED, this._onManifestLoaded.bind(this));\n            this._playlistLoader.on(_kernelEvents2.default.LEVEL_LOADED, this._onLevelLoaded.bind(this));\n            this._playlistLoader.on(_kernelEvents2.default.ERROR, function (data) {\n                _this2.emit(_kernelEvents2.default.ERROR, data);\n            });\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._canload = this._canloadFrag = false;\n            var loader = this._fragLoader;\n            if (loader) {\n                loader.destroy();\n                this._fragLoader = null;\n            }\n\n            if (this._playlistLoader) {\n                this._playlistLoader.removeAllListeners();\n                this._playlistLoader.destroy();\n                this._playlistLoader = null;\n            }\n        }\n    }, {\n        key: 'loadSource',\n        value: function loadSource() {\n            var data = { url: this._config.url };\n            this._canload = true;\n            this._canloadFrag = true;\n            this._playlistLoader.loadManifest(data);\n        }\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this._canloadFrag = false;\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this._canloadFrag = true;\n            this._checkloadFrag();\n        }\n    }, {\n        key: 'seek',\n        value: function seek(time) {\n            var level = this.currentLevel;\n            this._canloadFrag = true;\n            if (level && level.details) {\n                if (this._fragLoader) {\n                    this._fragLoader.destroy();\n                    this._fragLoader = null;\n                }\n                this._fragPos = this._getFragIndexByTime(time);\n                var frag = this.currentLevel.details.fragments[this._fragPos];\n                this._checkloadFrag();\n                this._startTime = null;\n                return frag.start;\n            }\n            this._startTime = time;\n            return 0;\n        }\n    }, {\n        key: 'getBitrates',\n        value: function getBitrates() {\n            var bitrates = [];\n            if (this._levels) {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this._levels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var level = _step.value;\n\n                        bitrates.push(level.bitrate);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            }\n            return bitrates;\n        }\n    }, {\n        key: 'selectBitrate',\n        value: function selectBitrate(bitrate, currentTime) {\n            var bitrates = this.getBitrates();\n            var levelIndex = bitrates.indexOf(bitrate);\n            if (levelIndex !== -1) {\n                if (this._fragLoader) {\n                    this._fragLoader.destroy();\n                    this._fragLoader = null;\n                }\n                this._clearTimer();\n                this._currentLevelIndex = levelIndex;\n                if (!this.currentLevel || !this.currentLevel.details || this.currentLevel.details.live) {\n                    this._loadLevel();\n                }\n                this.seek(currentTime);\n                this.emit(_kernelEvents2.default.LEVEL_SWITCHED);\n            }\n        }\n    }, {\n        key: '_getFragByTime',\n        value: function _getFragByTime(time) {\n            var fragments = this.currentLevel.details.fragments;\n            return fragments[this._getFragIndexByTime(time)];\n        }\n    }, {\n        key: '_getFragIndexByTime',\n        value: function _getFragIndexByTime(time) {\n            var details = this.currentLevel.details;\n            if (details) {\n                for (var i = details.fragments.length - 1; i >= 0; i--) {\n                    if (details.fragments[i].start <= time) {\n                        return i;\n                    }\n                }\n            }\n            return 0;\n        }\n    }, {\n        key: '_onManifestLoaded',\n        value: function _onManifestLoaded(data) {\n            _log.Log.v(this.tag, '_onManifestLoaded', data);\n\n            var levels = [];\n            var bitrateStart = void 0;\n            var levelSet = {};\n            var levelFromSet = null;\n            var videoCodecFound = false;\n            var audioCodecFound = false;\n            var chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());\n\n            // regroup redundant levels together\n            data.levels.forEach(function (level) {\n                level.loadError = 0;\n                level.fragmentError = false;\n\n                videoCodecFound = videoCodecFound || !!level.videoCodec;\n                audioCodecFound = audioCodecFound || !!level.audioCodec || !!(level.attrs && level.attrs.AUDIO);\n\n                if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {\n                    level.audioCodec = undefined;\n                }\n\n                levelFromSet = levelSet[level.bitrate];\n\n                if (!levelFromSet) {\n                    level.url = [level.url];\n                    level.urlId = 0;\n                    levelSet[level.bitrate] = level;\n                    levels.push(level);\n                } else {\n                    levelFromSet.url.push(level.url);\n                }\n            });\n\n            if (videoCodecFound && audioCodecFound) {\n                levels = levels.filter(function (_ref) {\n                    var videoCodec = _ref.videoCodec;\n                    return !!videoCodec;\n                });\n            }\n\n            // only keep levels with supported audio/video codecsag\n            // TODO: codec\n            // levels = levels.filter(({ audioCodec, videoCodec }) => {\n            // return (\n            //     (!audioCodec || isCodecSupportedInMp4(audioCodec))\n            //         && (!videoCodec || isCodecSupportedInMp4(videoCodec))\n            // );\n            // });\n\n            if (levels.length > 0) {\n                if (typeof this._config.bitrateStart === 'undefined') {\n                    // start bitrate is the first bitrate of the manifest\n                    bitrateStart = this._config.bitrateStart || levels[0].bitrate;\n                    levels = levels.sort(function (a, b) {\n                        return a.bitrate - b.bitrate;\n                    });\n                } else {\n                    // sort level on bitrate\n                    levels = levels.sort(function (a, b) {\n                        return a.bitrate - b.bitrate;\n                    });\n                    bitrateStart = this._config.bitrateStart || levels[0].bitrate;\n                }\n                this._levels = levels;\n                // find index of first level in sorted levels\n                for (var i = levels.length - 1; i >= 0; i--) {\n                    if (levels[i].bitrate <= bitrateStart) {\n                        this._firstLevel = i;\n                        this._currentLevelIndex = this._firstLevel;\n                        _log.Log.v('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);\n                        break;\n                    }\n                }\n                this.emit(_kernelEvents2.default.MANIFEST_PARSED, { bitrates: this.getBitrates(), bitrate: this.currentLevel.bitrate });\n                if (this._levels[this._currentLevelIndex].details) {\n                    this._levelUpdated();\n                } else {\n                    this._loadLevel();\n                }\n            } else {\n                this.emit(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                    details: _kernelErrors.ErrorDetails.HLS_MANIFEST_PARSING_ERROR,\n                    fatal: true,\n                    reason: 'manifest parsing error'\n                });\n            }\n        }\n    }, {\n        key: '_onLevelLoaded',\n        value: function _onLevelLoaded(data) {\n            var _this3 = this;\n\n            var levelId = data.level;\n            // only process level loaded events matching with expected level\n            if (levelId !== this._currentLevelIndex) {\n                return;\n            }\n\n            var curLevel = this._levels[levelId];\n            // reset level load error counter on successful level loaded only if there is no issues with fragments\n            if (!curLevel.fragmentError) {\n                curLevel.loadError = 0;\n                this.levelRetryCount = 0;\n            }\n            var newDetails = data.details;\n            // if current playlist is a live playlist, arm a timer to reload it\n            if (newDetails.live) {\n                var targetdurationMs = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration);\n                var reloadInterval = targetdurationMs;\n                var curDetails = curLevel.details;\n                if (curDetails && newDetails.endSN === curDetails.endSN) {\n                    reloadInterval /= 2;\n                    _log.Log.v('same live playlist, reload twice faster');\n                } else {\n                    this._mergeDetails(curDetails, newDetails);\n                    this._levelUpdated();\n                }\n                this._checkloadFrag();\n                reloadInterval -= performance.now() - data.stats.trequest;\n                reloadInterval = Math.max(targetdurationMs / 2, Math.round(reloadInterval));\n                _log.Log.v('live playlist, reload in ' + Math.round(reloadInterval) + ' ms');\n                this._timer = setTimeout(function () {\n                    return _this3._loadLevel();\n                }, reloadInterval);\n            } else {\n                this._clearTimer();\n                if (curLevel.details) {\n                    this._mergeDetails(curLevel.details, newDetails);\n                } else {\n                    curLevel.details = newDetails;\n                }\n                this._levelUpdated();\n                this._checkloadFrag();\n            }\n            this.emit(_kernelEvents2.default.LEVEL_LOADED, { bitrate: this.currentLevel.bitrate });\n        }\n    }, {\n        key: '_levelUpdated',\n        value: function _levelUpdated() {\n            if (this._startTime) {\n                this.seek(this._startTime);\n            }\n            this.emit(_kernelEvents2.default.LEVEL_UPDATED, {\n                details: this._levels[this._currentLevelIndex].details,\n                level: this._currentLevelIndex\n            });\n        }\n    }, {\n        key: '_mergeDetails',\n        value: function _mergeDetails(oldDetails, newDetails) {\n            if (oldDetails.endSN >= newDetails.endSN) {\n                return;\n            }\n            // const duration = oldDetails.totalduration;\n            for (var i = 0; i < newDetails.fragments.length; i++) {\n                if (newDetails.fragments[i].sn > oldDetails.endSN) {\n                    var frag = newDetails.fragments[i];\n                    frag.start = oldDetails.totalduration;\n                    oldDetails.totalduration += frag.duration;\n                    oldDetails.fragments.push(newDetails.fragments[i]);\n                }\n            }\n            oldDetails.endSN = newDetails.endSN;\n            oldDetails.endCC = newDetails.endCC;\n            oldDetails.averagetargetduration = oldDetails.totalduration / oldDetails.fragments.length;\n        }\n    }, {\n        key: '_loadLevel',\n        value: function _loadLevel() {\n            _log.Log.v('call to loadLevel');\n            if (this._currentLevelIndex !== null && this._canload) {\n                var levelObject = this._levels[this._currentLevelIndex];\n\n                if ((typeof levelObject === 'undefined' ? 'undefined' : _typeof(levelObject)) === 'object' && levelObject.url.length > 0) {\n                    var level = this._currentLevelIndex;\n                    var id = levelObject.urlId;\n                    var url = levelObject.url[id];\n                    this._playlistLoader.loadLevel({ url: url, level: level, id: id });\n                }\n            }\n        }\n    }, {\n        key: '_clearTimer',\n        value: function _clearTimer() {\n            if (this._timer !== null) {\n                clearTimeout(this._timer);\n                this._timer = null;\n            }\n        }\n    }, {\n        key: '_selectLevel',\n        value: function _selectLevel() {\n            this._currentLevelIndex = 0;\n        }\n    }, {\n        key: '_checkloadFrag',\n        value: function _checkloadFrag() {\n            if (this._canloadFrag && !this._fragLoader) {\n                var frag = this._nextFragment();\n                var levelObject = this._levels[this._currentLevelIndex];\n                if (frag) {\n                    this._loadFrag(frag);\n                } else if (levelObject.details && !levelObject.details.live) {\n                    this.emit(_kernelEvents2.default.END);\n                }\n            }\n        }\n    }, {\n        key: '_loadFrag',\n        value: function _loadFrag(frag) {\n            if (frag) {\n                var streaming = this._config.hlsStreamingMux;\n                var Loader = this._config.fragLoader;\n                var context = { src: frag.url, responseType: 'arraybuffer', progress: streaming, frag: frag };\n                this._fragLoader = new Loader();\n                this._fragLoader.open(context, this._fragCallback, this._fragLoadConfig);\n            }\n        }\n    }, {\n        key: '_nextFragment',\n        value: function _nextFragment() {\n            var levelObject = this._levels[this._currentLevelIndex];\n            if (levelObject && levelObject.details && levelObject.details.fragments.length > this._fragPos) {\n                var frag = levelObject.details.fragments[this._fragPos];\n                this._fragPos++;\n                return frag;\n            }\n            return null;\n        }\n    }, {\n        key: '_onProgress',\n        value: function _onProgress(context, data, stats) {\n            this.emit(_kernelEvents2.default.HLS_FRAG_LOAD_PROGRESS, { context: context, data: data, stats: stats });\n        }\n    }, {\n        key: '_onEnd',\n        value: function _onEnd(context, data, stats) {\n            this._fragLoader = null;\n            this.emit(_kernelEvents2.default.HLS_FRAG_LOADED, { context: context, data: data, stats: stats });\n            this._checkloadFrag();\n        }\n    }, {\n        key: '_onError',\n        value: function _onError(context, handle) {\n            this.emit(_kernelEvents2.default.ERROR, {\n                type: _kernelErrors.ErrorTypes.NETWORK_ERROR,\n                details: handle.text === 'timeout' ? _kernelErrors.ErrorDetails.LOAD_TIMEOUT : _kernelErrors.ErrorDetails.LOAD_ERROR,\n                fatal: true,\n                reason: handle.text,\n                statusCode: handle.code,\n                url: context.src\n            });\n        }\n    }, {\n        key: '_onInfo',\n        value: function _onInfo() {}\n    }, {\n        key: '_initConfig',\n        value: function _initConfig(config) {\n            this._config = {};\n            this._config.pLoader = config.pLoader;\n            this._config.loader = config.pLoader;\n            this._config.fragLoader = config.fragLoader;\n\n            this._config.manifestLoadingMaxRetry = 3;\n            this._config.manifestLoadingTimeOut = 6000;\n            this._config.manifestLoadingRetryDelay = 200;\n            this._config.manifestLoadingMaxRetryTimeout = 3000;\n\n            this._config.levelLoadingMaxRetry = 3;\n            this._config.levelLoadingTimeOut = 6000;\n            this._config.levelLoadingRetryDelay = 200;\n            this._config.levelLoadingMaxRetryTimeout = 3000;\n\n            var href = location.href;\n            // webwork 删除url中的blob:\n            if (href.indexOf('blob:') === 0) {\n                href = href.slice(5);\n            }\n            this._config.url = _urlToolkit2.default.buildAbsoluteURL(href, config.src, { alwaysNormalize: true });\n            this._config.bitrateStart = config.bitrateStart;\n            this._config.credentials = config.credentials;\n            this._config.hlsStreamingMux = config.hlsStreamingMux;\n\n            this._fragLoadConfig = {\n                timeout: 0,\n                maxRetry: 3,\n                retryDelay: 200,\n                maxRetryDelay: 6000,\n                credentials: config.credentials\n            };\n        }\n    }, {\n        key: 'currentLevel',\n        get: function get() {\n            if (this._levels) {\n                return this._levels[this._currentLevelIndex];\n            }\n            return false;\n        }\n    }]);\n\n    return M3U8;\n}(_events2.default);\n\nexports.default = M3U8;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/m3u8.js?")},"./src/demux/hls/tsdemuxer.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n// import Hex from '../utils/hex';\n\n\nvar _adts = __webpack_require__(/*! ../adts */ \"./src/demux/adts.js\");\n\nvar ADTS = _interopRequireWildcard(_adts);\n\nvar _kernelEvents = __webpack_require__(/*! ../../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _expGolomb = __webpack_require__(/*! ../exp-golomb */ \"./src/demux/exp-golomb.js\");\n\nvar _expGolomb2 = _interopRequireDefault(_expGolomb);\n\nvar _spsParser = __webpack_require__(/*! ../sps-parser */ \"./src/demux/sps-parser.js\");\n\nvar _spsParser2 = _interopRequireDefault(_spsParser);\n\nvar _log = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.js\");\n\nvar _kernelErrors = __webpack_require__(/*! ../../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nvar RemuxerTrackIdConfig = {\n    video: 1,\n    audio: 2,\n    id3: 3,\n    text: 4\n};\n\nvar TSDemuxer = function () {\n    function TSDemuxer(observer, remuxer, config, typeSupported) {\n        _classCallCheck(this, TSDemuxer);\n\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.remuxer = remuxer;\n        this.sampleAes = null;\n        this.remuxStat = null;\n        this.remuxContiguous = null;\n    }\n\n    _createClass(TSDemuxer, [{\n        key: 'setDecryptData',\n        value: function setDecryptData(decryptdata) {\n            if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {\n                // this.sampleAes = new SampleAesDecrypter(this.observer, this.config, decryptdata, this.discardEPB);\n            } else {\n                this.sampleAes = null;\n            }\n        }\n    }, {\n        key: 'resetInitSegment',\n\n\n        /**\n         * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n         * Resets all internal track instances of the demuxer.\n         *\n         * @override Implements generic demuxing/remuxing interface (see DemuxerInline)\n         * @param {object} initSegment\n         * @param {string} audioCodec\n         * @param {string} videoCodec\n         * @param {number} duration (in TS timescale = 90kHz)\n         */\n        value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {\n            this.pmtParsed = false;\n            this._pmtId = -1;\n\n            this._avcTrack = TSDemuxer.createTrack('video', duration);\n            this._audioTrack = TSDemuxer.createTrack('audio', duration);\n\n            // flush any partial content\n            this.aacOverFlow = null;\n            this.aacLastPTS = null;\n            this.avcSample = null;\n            this.audioCodec = audioCodec;\n            this.videoCodec = videoCodec;\n            this._duration = duration;\n        }\n\n        /**\n         *\n         * @override\n         */\n\n    }, {\n        key: 'resetTimeStamp',\n        value: function resetTimeStamp() {}\n\n        // feed incoming data to the front of the parsing pipeline\n\n    }, {\n        key: 'append',\n        value: function append(data, timeOffset, contiguous, accurateTimeOffset) {\n            this.contiguous = contiguous;\n            this.timeOffset = timeOffset;\n            this.accurateTimeOffset = accurateTimeOffset;\n            if (this.remuxStat === null) {\n                this.remuxStat = { timeOffset: timeOffset, contiguous: contiguous, accurateTimeOffset: accurateTimeOffset };\n            }\n            var start = void 0,\n                len = data.length,\n                stt = void 0,\n                pid = void 0,\n                atf = void 0,\n                offset = void 0,\n                pes = void 0,\n                unknownPIDs = false;\n            var stat = this.remuxStat,\n                pmtParsed = this.pmtParsed,\n                avcTrack = this._avcTrack,\n                audioTrack = this._audioTrack,\n                avcId = avcTrack.pid,\n                audioId = audioTrack.pid,\n                pmtId = this._pmtId,\n                avcData = avcTrack.pesData,\n                audioData = audioTrack.pesData,\n                parsePAT = this._parsePAT,\n                parsePMT = this._parsePMT,\n                parsePES = this._parsePES,\n                parseAVCPES = this._parseAVCPES.bind(this),\n                parseAACPES = this._parseAACPES.bind(this);\n\n            var syncOffset = TSDemuxer._syncOffset(data);\n\n            // don't parse last TS packet if incomplete\n            len -= (len + syncOffset) % 188;\n\n            // loop through TS packets\n            for (start = syncOffset; start < len; start += 188) {\n                if (data[start] === 0x47) {\n                    stt = !!(data[start + 1] & 0x40);\n                    // pid is a 13-bit field starting at the last bit of TS[1]\n                    pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n                    atf = (data[start + 3] & 0x30) >> 4;\n                    // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n                    if (atf > 1) {\n                        offset = start + 5 + data[start + 4];\n                        // continue if there is only adaptation field\n                        if (offset === start + 188) {\n                            continue;\n                        }\n                    } else {\n                        offset = start + 4;\n                    }\n\n                    if (stt && (pid === avcId || pid === audioId)) {\n                        if (avcData && (pes = parsePES(avcData, true)) && pes.pts !== undefined) {\n                            parseAVCPES(pes, true);\n                            avcData = { data: [], size: 0 };\n                        }\n                    }\n\n                    switch (pid) {\n                        case avcId:\n                            if (stt) {\n                                if (avcData && (pes = parsePES(avcData, true)) && pes.pts !== undefined) {\n                                    parseAVCPES(pes, false);\n                                }\n\n                                avcData = { data: [], size: 0 };\n                            }\n                            if (avcData) {\n                                avcData.data.push(data.subarray(offset, start + 188));\n                                avcData.size += start + 188 - offset;\n                            }\n                            break;\n                        case audioId:\n                            if (stt) {\n                                if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {\n                                    if (audioTrack.isAAC) {\n                                        parseAACPES(pes);\n                                    } else {\n                                        parseMPEGPES(pes);\n                                    }\n                                }\n                                audioData = { data: [], size: 0 };\n                            }\n                            if (audioData) {\n                                audioData.data.push(data.subarray(offset, start + 188));\n                                audioData.size += start + 188 - offset;\n                            }\n                            break;\n                        case 0:\n                            if (stt) {\n                                offset += data[offset] + 1;\n                            }\n\n                            pmtId = this._pmtId = parsePAT(data, offset);\n                            break;\n                        case pmtId:\n                            if (stt) {\n                                offset += data[offset] + 1;\n                            }\n\n                            var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);\n\n                            // only update track id if track PID found while parsing PMT\n                            // this is to avoid resetting the PID to -1 in case\n                            // track PID transiently disappears from the stream\n                            // this could happen in case of transient missing audio samples for example\n                            // NOTE this is only the PID of the track as found in TS,\n                            // but we are not using this for MP4 track IDs.\n                            avcId = parsedPIDs.avc;\n                            if (avcId > 0) {\n                                avcTrack.pid = avcId;\n                            }\n\n                            audioId = parsedPIDs.audio;\n                            if (audioId > 0) {\n                                audioTrack.pid = audioId;\n                                audioTrack.isAAC = parsedPIDs.isAAC;\n                            }\n\n                            if (unknownPIDs && !pmtParsed) {\n                                _log.Log.v('reparse from beginning');\n                                unknownPIDs = false;\n                                // we set it to -188, the += 188 in the for loop will reset start to 0\n                                start = syncOffset - 188;\n                            }\n                            pmtParsed = this.pmtParsed = true;\n                            break;\n                        case 17:\n                        case 0x1fff:\n                            break;\n                        default:\n                            unknownPIDs = true;\n                            break;\n                    }\n                } else {\n                    this.observer.trigger(_kernelEvents2.default.ERROR, {\n                        type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                        details: _kernelErrors.ErrorDetails.FRAG_PARSING_ERROR,\n                        fatal: false,\n                        reason: 'TS packet did not start with 0x47'\n                    });\n                }\n            }\n            // try to parse last PES packets\n            if (avcData && (pes = parsePES(avcData, false)) && pes.pts !== undefined) {\n                parseAVCPES(pes, true);\n                avcTrack.pesData = null;\n            } else {\n                // either avcData null or PES truncated, keep it for next frag parsing\n                avcTrack.pesData = avcData;\n            }\n\n            if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {\n                if (audioTrack.isAAC) {\n                    parseAACPES(pes);\n                } else {\n                    parseMPEGPES(pes);\n                }\n\n                audioTrack.pesData = null;\n            } else {\n                if (audioData && audioData.size) {}\n                // Log.v('last AAC PES packet truncated,might overlap between fragments');\n\n\n                // either audioData null or PES truncated, keep it for next frag parsing\n                audioTrack.pesData = audioData;\n            }\n\n            if (audioId && audioTrack.samples.length === 0 || avcId && avcTrack.samples.length === 0) {\n                return;\n            }\n            if (this.sampleAes == null) {\n                this.remuxer.remux(audioTrack, avcTrack, stat.timeOffset, stat.contiguous, stat.accurateTimeOffset);\n            } else {\n                this.decryptAndRemux(audioTrack, avcTrack, stat.timeOffset, stat.contiguous, stat.accurateTimeOffset);\n            }\n            this.remuxStat = null;\n        }\n    }, {\n        key: 'flush',\n        value: function flush() {\n            var pes = void 0;\n            var avcTrack = this._avcTrack,\n                audioTrack = this._audioTrack,\n                avcData = avcTrack.pesData,\n                audioData = audioTrack.pesData,\n                parsePES = this._parsePES,\n                parseAVCPES = this._parseAVCPES.bind(this),\n                parseAACPES = this._parseAACPES.bind(this);\n            if (avcData && (pes = parsePES(avcData, false)) && pes.pts !== undefined) {\n                parseAVCPES(pes, true);\n            }\n            avcTrack.pesData = null;\n\n            if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {\n                if (audioTrack.isAAC) {\n                    parseAACPES(pes);\n                }\n            }\n            audioTrack.pesData = null;\n\n            if (this.sampleAes == null) {\n                this.remuxer.remux(audioTrack, avcTrack, this.timeOffset, true, this.accurateTimeOffset);\n            } else {\n                this.decryptAndRemux(audioTrack, avcTrack, this.timeOffset, true, this.accurateTimeOffset);\n            }\n            this.remuxStat = null;\n        }\n    }, {\n        key: 'reset',\n        value: function reset() {\n            var avcTrack = this._avcTrack,\n                audioTrack = this._audioTrack;\n            avcTrack.pesData = null;\n            avcTrack.samples = [];\n            avcTrack.len = 0;\n            avcTrack.audFound = false;\n            avcTrack.nbSamples = 0;\n            avcTrack.nbNalu = 0;\n\n            audioTrack.pesData = null;\n            audioTrack.samples = [];\n            audioTrack.len = 0;\n\n            this.remuxStat = null;\n        }\n    }, {\n        key: 'decryptAndRemux',\n        value: function decryptAndRemux(audioTrack, videoTrack, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n            if (audioTrack.samples && audioTrack.isAAC) {\n                var localthis = this;\n                this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n                    localthis.decryptAndRemuxAvc(audioTrack, videoTrack, textTrack, timeOffset, contiguous, accurateTimeOffset);\n                });\n            } else {\n                this.decryptAndRemuxAvc(audioTrack, videoTrack, textTrack, timeOffset, contiguous, accurateTimeOffset);\n            }\n        }\n    }, {\n        key: 'decryptAndRemuxAvc',\n        value: function decryptAndRemuxAvc(audioTrack, videoTrack, textTrack, timeOffset, contiguous, accurateTimeOffset) {\n            if (videoTrack.samples) {\n                var localthis = this;\n                this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n                    localthis.remuxer.remux(audioTrack, videoTrack, textTrack, timeOffset, contiguous, accurateTimeOffset);\n                });\n            } else {\n                this.remuxer.remux(audioTrack, videoTrack, textTrack, timeOffset, contiguous, accurateTimeOffset);\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._initPTS = this._initDTS = undefined;\n            this._duration = 0;\n        }\n    }, {\n        key: '_parsePAT',\n        value: function _parsePAT(data, offset) {\n            // skip the PSI header and parse the first PMT entry\n            return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n            // Log.v('PMT PID:'  + this._pmtId);\n        }\n    }, {\n        key: '_parsePMT',\n        value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {\n            var sectionLength = void 0,\n                tableEnd = void 0,\n                programInfoLength = void 0,\n                pid = void 0,\n                result = { audio: -1, avc: -1, id3: -1, isAAC: true };\n            sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n            tableEnd = offset + 3 + sectionLength - 4;\n            // to determine where the table is, we have to figure out how\n            // long the program info descriptors are\n            programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n            // advance the offset to the first entry in the mapping table\n            offset += 12 + programInfoLength;\n            while (offset < tableEnd) {\n                pid = (data[offset + 1] & 0x1f) << 8 | data[offset + 2];\n                switch (data[offset]) {\n                    case 0xcf:\n                        // SAMPLE-AES AAC\n                        if (!isSampleAes) {\n                            _log.Log.v('unkown stream type:' + data[offset]);\n                            break;\n                        }\n                    /* falls through */\n\n                    // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n                    case 0x0f:\n                        // Log.v('AAC PID:'  + pid);\n                        if (result.audio === -1) {\n                            result.audio = pid;\n                        }\n\n                        break;\n\n                    // Packetized metadata (ID3)\n                    case 0x15:\n                        // Log.v('ID3 PID:'  + pid);\n                        if (result.id3 === -1) {\n                            result.id3 = pid;\n                        }\n\n                        break;\n\n                    case 0xdb:\n                        // SAMPLE-AES AVC\n                        if (!isSampleAes) {\n                            _log.Log.v('unkown stream type:' + data[offset]);\n                            break;\n                        }\n                    /* falls through */\n\n                    // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n                    case 0x1b:\n                        // Log.v('AVC PID:'  + pid);\n                        if (result.avc === -1) {\n                            result.avc = pid;\n                        }\n\n                        break;\n\n                    // ISO/IEC 11172-3 (MPEG-1 audio)\n                    // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n                    case 0x03:\n                    case 0x04:\n                        // Log.v('MPEG PID:'  + pid);\n                        if (!mpegSupported) {\n                            _log.Log.v('MPEG audio found, not supported in this browser for now');\n                        } else if (result.audio === -1) {\n                            result.audio = pid;\n                            result.isAAC = false;\n                        }\n                        break;\n\n                    case 0x24:\n                        _log.Log.w('HEVC stream type found, not supported for now');\n                        break;\n\n                    default:\n                        _log.Log.v('unkown stream type:' + data[offset]);\n                        break;\n                }\n                // move to the next table entry\n                // skip past the elementary stream descriptors, if present\n                offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n            }\n            return result;\n        }\n    }, {\n        key: '_parsePES',\n        value: function _parsePES(stream, isEnd) {\n            var i = 0,\n                frag = void 0,\n                pesFlags = void 0,\n                pesPrefix = void 0,\n                pesLen = void 0,\n                pesHdrLen = void 0,\n                pesData = void 0,\n                pesPts = void 0,\n                pesDts = void 0,\n                payloadStartOffset = void 0,\n                data = stream.data;\n            // safety check\n            if (!stream || stream.size === 0) {\n                return null;\n            }\n\n            // we might need up to 19 bytes to read PES header\n            // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n            // usually only one merge is needed (and this is rare ...)\n            while (data[0].length < 19 && data.length > 1) {\n                var newData = new Uint8Array(data[0].length + data[1].length);\n                newData.set(data[0]);\n                newData.set(data[1], data[0].length);\n                data[0] = newData;\n                data.splice(1, 1);\n            }\n            // retrieve PTS/DTS from first fragment\n            frag = data[0];\n            pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n            if (pesPrefix === 1) {\n                pesLen = (frag[4] << 8) + frag[5];\n                // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n                // minus 6 : PES header size\n                if (pesLen && pesLen > stream.size - 6) {\n                    return null;\n                }\n                if (pesLen === 0 && !isEnd) {\n                    return null;\n                }\n\n                pesFlags = frag[7];\n                if (pesFlags & 0xc0) {\n                    /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n                    as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n                    as Bitwise operators treat their operands as a sequence of 32 bits */\n                    pesPts = (frag[9] & 0x0e) * 536870912 // 1 << 29\n                    + (frag[10] & 0xff) * 4194304 // 1 << 22\n                    + (frag[11] & 0xfe) * 16384 // 1 << 14\n                    + (frag[12] & 0xff) * 128 // 1 << 7\n                    + (frag[13] & 0xfe) / 2;\n                    // check if greater than 2^32 -1\n                    if (pesPts > 4294967295) {\n                        // decrement 2^33\n                        pesPts -= 8589934592;\n                    }\n                    if (pesFlags & 0x40) {\n                        pesDts = (frag[14] & 0x0e) * 536870912 // 1 << 29\n                        + (frag[15] & 0xff) * 4194304 // 1 << 22\n                        + (frag[16] & 0xfe) * 16384 // 1 << 14\n                        + (frag[17] & 0xff) * 128 // 1 << 7\n                        + (frag[18] & 0xfe) / 2;\n                        // check if greater than 2^32 -1\n                        if (pesDts > 4294967295) {\n                            // decrement 2^33\n                            pesDts -= 8589934592;\n                        }\n                        if (pesPts - pesDts > 60 * 90000) {\n                            _log.Log.w(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');\n                            pesPts = pesDts;\n                        }\n                    } else {\n                        pesDts = pesPts;\n                    }\n                }\n                pesHdrLen = frag[8];\n                // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n                payloadStartOffset = pesHdrLen + 9;\n\n                stream.size -= payloadStartOffset;\n                // reassemble PES packet\n                pesData = new Uint8Array(stream.size);\n                for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n                    frag = data[j];\n                    var len = frag.byteLength;\n                    if (payloadStartOffset) {\n                        if (payloadStartOffset > len) {\n                            // trim full frag if PES header bigger than frag\n                            payloadStartOffset -= len;\n                            continue;\n                        } else {\n                            // trim partial frag if PES header smaller than frag\n                            frag = frag.subarray(payloadStartOffset);\n                            len -= payloadStartOffset;\n                            payloadStartOffset = 0;\n                        }\n                    }\n                    pesData.set(frag, i);\n                    i += len;\n                }\n                if (pesLen) {\n                    // payload size : remove PES header + PES extension\n                    pesLen -= pesHdrLen + 3;\n                }\n                return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };\n            }\n            return null;\n        }\n    }, {\n        key: 'pushAccesUnit',\n        value: function pushAccesUnit(avcSample, avcTrack) {\n            if (avcSample.units.length && avcSample.frame) {\n                var samples = avcTrack.samples;\n                var nbSamples = samples.length;\n                // only push AVC sample if starting with a keyframe is not mandatory OR\n                //    if keyframe already found in this fragment OR\n                //       keyframe found in last fragment (track.sps) AND\n                //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous\n                if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {\n                    avcSample.id = nbSamples;\n                    samples.push(avcSample);\n                } else {\n                    // dropped samples, track it\n                    avcTrack.dropped++;\n                }\n            }\n            if (avcSample.debug.length) {\n                _log.Log.v(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n            }\n        }\n    }, {\n        key: '_parseAVCPES',\n        value: function _parseAVCPES(pes, last) {\n            var _this = this;\n\n            // Log.v('parse new PES');\n            var track = this._avcTrack,\n                units = this._parseAVCNALu(pes.data),\n                debug = false,\n                expGolombDecoder = void 0,\n                avcSample = this.avcSample,\n                push = void 0,\n                spsfound = false,\n                i = void 0,\n                pushAccesUnit = this.pushAccesUnit.bind(this),\n                createAVCSample = function createAVCSample(key, pts, dts, debug) {\n                return { key: key, pts: pts, dts: dts, units: [], debug: debug };\n            };\n            // free pes.data to save up some memory\n            pes.data = null;\n\n            // if new NAL units found and last sample still there, let's push ...\n            // this helps parsing streams with missing AUD (only do this if AUD never found)\n            if (avcSample && units.length && !track.audFound) {\n                pushAccesUnit(avcSample, track);\n                avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n            }\n\n            units.forEach(function (unit) {\n                switch (unit.type) {\n                    // NDR\n                    case 1:\n                        push = true;\n                        if (!avcSample) {\n                            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n                        }\n\n                        if (debug) {\n                            avcSample.debug += 'NDR ';\n                        }\n\n                        avcSample.frame = true;\n                        var data = unit.data;\n                        // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n                        if (spsfound && data.length > 4) {\n                            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                            var sliceType = new _expGolomb2.default(data).readSliceType();\n                            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                            // if (sliceType === 2 || sliceType === 7) {\n                            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                                avcSample.key = true;\n                            }\n                        }\n                        break;\n                    // IDR\n                    case 5:\n                        push = true;\n                        // handle PES not starting with AUD\n                        if (!avcSample) {\n                            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n                        }\n\n                        if (debug) {\n                            avcSample.debug += 'IDR ';\n                        }\n\n                        avcSample.key = true;\n                        avcSample.frame = true;\n                        break;\n                    // SEI\n                    case 6:\n                        push = true;\n                        if (debug && avcSample) {\n                            avcSample.debug += 'SEI ';\n                        }\n\n                        expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));\n\n                        // skip frameType\n                        expGolombDecoder.readUByte();\n\n                        var payloadType = 0;\n                        var payloadSize = 0;\n                        var endOfCaptions = false;\n                        var b = 0;\n\n                        while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {\n                            payloadType = 0;\n                            do {\n                                b = expGolombDecoder.readUByte();\n                                payloadType += b;\n                            } while (b === 0xff);\n\n                            // Parse payload size.\n                            payloadSize = 0;\n                            do {\n                                b = expGolombDecoder.readUByte();\n                                payloadSize += b;\n                            } while (b === 0xff);\n\n                            // TODO: there can be more than one payload in an SEI packet...\n                            // TODO: need to read type and size in a while loop to get them all\n                            if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {\n                                endOfCaptions = true;\n\n                                var countryCode = expGolombDecoder.readUByte();\n\n                                if (countryCode === 181) {\n                                    var providerCode = expGolombDecoder.readUShort();\n\n                                    if (providerCode === 49) {\n                                        var userStructure = expGolombDecoder.readUInt();\n\n                                        if (userStructure === 0x47413934) {\n                                            var userDataType = expGolombDecoder.readUByte();\n\n                                            // Raw CEA-608 bytes wrapped in CEA-708 packet\n                                            if (userDataType === 3) {\n                                                var firstByte = expGolombDecoder.readUByte();\n                                                var secondByte = expGolombDecoder.readUByte();\n\n                                                var totalCCs = 31 & firstByte;\n                                                var byteArray = [firstByte, secondByte];\n\n                                                for (i = 0; i < totalCCs; i++) {\n                                                    // 3 bytes per CC\n                                                    byteArray.push(expGolombDecoder.readUByte());\n                                                    byteArray.push(expGolombDecoder.readUByte());\n                                                    byteArray.push(expGolombDecoder.readUByte());\n                                                }\n\n                                                // this._insertSampleInOrder(this._txtTrack.samples, {\n                                                //     type: 3,\n                                                //     pts: pes.pts,\n                                                //     bytes: byteArray\n                                                // });\n                                            }\n                                        }\n                                    }\n                                }\n                            } else if (payloadSize < expGolombDecoder.bytesAvailable) {\n                                for (i = 0; i < payloadSize; i++) {\n                                    expGolombDecoder.readUByte();\n                                }\n                            }\n                        }\n                        break;\n                    // SPS\n                    case 7:\n                        push = true;\n                        spsfound = true;\n                        if (debug && avcSample) {\n                            avcSample.debug += 'SPS ';\n                        }\n\n                        if (!track.sps) {\n                            var config = _spsParser2.default.parseSPS(unit.data);\n                            track.width = config.codec_size.width;\n                            track.height = config.codec_size.height;\n                            track.pixelRatio = [config.sar_ratio.width, config.sar_ratio.height];\n                            track.sps = [unit.data];\n                            track.duration = _this._duration;\n                            track.fps = config.frame_rate.fps;\n                            var codecarray = unit.data.subarray(1, 4);\n                            var codecstring = 'avc1.';\n                            for (i = 0; i < 3; i++) {\n                                var h = codecarray[i].toString(16);\n                                if (h.length < 2) {\n                                    h = '0' + h;\n                                }\n\n                                codecstring += h;\n                            }\n                            track.codec = codecstring;\n                        }\n                        break;\n                    // PPS\n                    case 8:\n                        push = true;\n                        if (debug && avcSample) {\n                            avcSample.debug += 'PPS ';\n                        }\n\n                        if (!track.pps) {\n                            track.pps = [unit.data];\n                        }\n\n                        break;\n                    // AUD\n                    case 9:\n                        push = false;\n                        track.audFound = true;\n                        if (avcSample) {\n                            pushAccesUnit(avcSample, track);\n                        }\n\n                        avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n                        break;\n                    // Filler Data\n                    case 12:\n                        push = false;\n                        break;\n                    default:\n                        push = false;\n                        if (avcSample) {\n                            avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n                        }\n\n                        break;\n                }\n                if (avcSample && push) {\n                    var _units = avcSample.units;\n                    _units.push(unit);\n                }\n            });\n            // if last PES packet, push samples\n            if (last && avcSample) {\n                pushAccesUnit(avcSample, track);\n                this.avcSample = null;\n            }\n        }\n    }, {\n        key: '_insertSampleInOrder',\n        value: function _insertSampleInOrder(arr, data) {\n            var len = arr.length;\n            if (len > 0) {\n                if (data.pts >= arr[len - 1].pts) {\n                    arr.push(data);\n                } else {\n                    for (var pos = len - 1; pos >= 0; pos--) {\n                        if (data.pts < arr[pos].pts) {\n                            arr.splice(pos, 0, data);\n                            break;\n                        }\n                    }\n                }\n            } else {\n                arr.push(data);\n            }\n        }\n    }, {\n        key: '_getLastNalUnit',\n        value: function _getLastNalUnit() {\n            var avcSample = this.avcSample,\n                lastUnit = void 0;\n            // try to fallback to previous sample if current one is empty\n            if (!avcSample || avcSample.units.length === 0) {\n                var track = this._avcTrack,\n                    samples = track.samples;\n                avcSample = samples[samples.length - 1];\n            }\n            if (avcSample) {\n                var units = avcSample.units;\n                lastUnit = units[units.length - 1];\n            }\n            return lastUnit;\n        }\n    }, {\n        key: '_parseAVCNALu',\n        value: function _parseAVCNALu(array) {\n            var i = 0,\n                len = array.byteLength,\n                value = void 0,\n                overflow = void 0,\n                track = this._avcTrack,\n                state = track.naluState || 0,\n                lastState = state;\n            var units = [],\n                unit = void 0,\n                unitType = void 0,\n                lastUnitStart = -1,\n                lastUnitType = void 0;\n            // Log.v('PES:' + Hex.hexDump(array));\n\n            if (state === -1) {\n                // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n                lastUnitStart = 0;\n                // NALu type is value read from offset 0\n                lastUnitType = array[0] & 0x1f;\n                state = 0;\n                i = 1;\n            }\n\n            while (i < len) {\n                value = array[i++];\n                // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n                if (!state) {\n                    state = value ? 0 : 1;\n                    continue;\n                }\n                if (state === 1) {\n                    state = value ? 0 : 2;\n                    continue;\n                }\n                // here we have state either equal to 2 or 3\n                if (!value) {\n                    state = 3;\n                } else if (value === 1) {\n                    if (lastUnitStart >= 0) {\n                        unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };\n                        // Log.v('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n                        units.push(unit);\n                    } else {\n                        // lastUnitStart is undefined => this is the first start code found in this PES packet\n                        // first check if start code delimiter is overlapping between 2 PES packets,\n                        // ie it started in last packet (lastState not zero)\n                        // and ended at the beginning of this PES packet (i <= 4 - lastState)\n                        var lastUnit = this._getLastNalUnit();\n                        if (lastUnit) {\n                            if (lastState && i <= 4 - lastState) {\n                                // start delimiter overlapping between PES packets\n                                // strip start delimiter bytes from the end of last NAL unit\n                                // check if lastUnit had a state different from zero\n                                if (lastUnit.state) {\n                                    // strip last bytes\n                                    lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                                }\n                            }\n                            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n                            overflow = i - state - 1;\n                            if (overflow > 0) {\n                                // Log.v('first NALU found with overflow:' + overflow);\n                                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n                                tmp.set(lastUnit.data, 0);\n                                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n                                lastUnit.data = tmp;\n                            }\n                        }\n                    }\n                    // check if we can read unit type\n                    if (i < len) {\n                        unitType = array[i] & 0x1f;\n                        // Log.v('find NALU @ offset:' + i + ',type:' + unitType);\n                        lastUnitStart = i;\n                        lastUnitType = unitType;\n                        state = 0;\n                    } else {\n                        // not enough byte to read unit type. let's read it on next PES parsing\n                        state = -1;\n                    }\n                } else {\n                    state = 0;\n                }\n            }\n            if (lastUnitStart >= 0 && state >= 0) {\n                unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };\n                units.push(unit);\n                // Log.v('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n            }\n            // no NALu found\n            if (units.length === 0) {\n                // append pes.data to previous NAL unit\n                var _lastUnit = this._getLastNalUnit();\n                if (_lastUnit) {\n                    var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n                    _tmp.set(_lastUnit.data, 0);\n                    _tmp.set(array, _lastUnit.data.byteLength);\n                    _lastUnit.data = _tmp;\n                }\n            }\n            track.naluState = state;\n            return units;\n        }\n\n        /**\n         * remove Emulation Prevention bytes from a RBSP\n         */\n\n    }, {\n        key: 'discardEPB',\n        value: function discardEPB(data) {\n            var length = data.byteLength,\n                EPBPositions = [],\n                i = 1,\n                newLength = void 0,\n                newData = void 0;\n\n            // Find all `Emulation Prevention Bytes`\n            while (i < length - 2) {\n                if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n                    EPBPositions.push(i + 2);\n                    i += 2;\n                } else {\n                    i++;\n                }\n            }\n\n            // If no Emulation Prevention Bytes were found just return the original\n            // array\n            if (EPBPositions.length === 0) {\n                return data;\n            }\n\n            // Create a new array to hold the NAL unit data\n            newLength = length - EPBPositions.length;\n            newData = new Uint8Array(newLength);\n            var sourceIndex = 0;\n\n            for (i = 0; i < newLength; sourceIndex++, i++) {\n                if (sourceIndex === EPBPositions[0]) {\n                    // Skip this byte\n                    sourceIndex++;\n                    // Remove this position index\n                    EPBPositions.shift();\n                }\n                newData[i] = data[sourceIndex];\n            }\n            return newData;\n        }\n    }, {\n        key: '_parseAACPES',\n        value: function _parseAACPES(pes) {\n            var track = this._audioTrack,\n                data = pes.data,\n                pts = pes.pts,\n                startOffset = 0,\n                aacOverFlow = this.aacOverFlow,\n                aacLastPTS = this.aacLastPTS,\n                frameDuration = void 0,\n                frameIndex = void 0,\n                offset = void 0,\n                stamp = void 0,\n                len = void 0;\n            if (aacOverFlow) {\n                var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);\n                tmp.set(aacOverFlow, 0);\n                tmp.set(data, aacOverFlow.byteLength);\n                // Log.v(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);\n                data = tmp;\n            }\n            // look for ADTS header (0xFFFx)\n            for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n                if (ADTS.isHeader(data, offset)) {\n                    break;\n                }\n            }\n            // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n            if (offset) {\n                var reason = void 0,\n                    fatal = void 0;\n                if (offset < len - 1) {\n                    reason = 'AAC PES did not start with ADTS header,offset:' + offset;\n                    fatal = false;\n                } else {\n                    reason = 'no ADTS header found in AAC PES';\n                    fatal = true;\n                }\n                _log.Log.w('parsing error:' + reason);\n                this.observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                    details: _kernelErrors.ErrorDetails.FRAG_PARSING_ERROR,\n                    fatal: fatal,\n                    reason: reason\n                });\n                if (fatal) {\n                    return;\n                }\n            }\n\n            ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n            frameIndex = 0;\n            frameDuration = ADTS.getFrameDuration(track.samplerate);\n\n            // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n            // first sample PTS should be equal to last sample PTS + frameDuration\n            if (aacOverFlow && aacLastPTS) {\n                var newPTS = aacLastPTS + frameDuration;\n                if (Math.abs(newPTS - pts) > 1) {\n                    _log.Log.v('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));\n                    pts = newPTS;\n                }\n            }\n\n            // scan for aac samples\n            while (offset < len) {\n                if (ADTS.isHeader(data, offset) && offset + 5 < len) {\n                    var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);\n                    if (frame) {\n                        // Log.v(`${Math.round(frame.sample.pts)} : AAC`);\n                        offset += frame.length;\n                        stamp = frame.sample.pts;\n                        frameIndex++;\n                    } else {\n                        // Log.v('Unable to parse AAC frame');\n                        break;\n                    }\n                } else {\n                    // nothing found, keep looking\n                    offset++;\n                }\n            }\n\n            if (offset < len) {\n                aacOverFlow = data.subarray(offset, len);\n                // Log.v(`AAC: overflow detected:${len-offset}`);\n            } else {\n                aacOverFlow = null;\n            }\n\n            this.aacOverFlow = aacOverFlow;\n            this.aacLastPTS = stamp;\n        }\n    }], [{\n        key: 'probe',\n        value: function probe(data) {\n            var syncOffset = TSDemuxer._syncOffset(data);\n            if (syncOffset < 0) {\n                return false;\n            }\n            if (syncOffset) {\n                _log.Log.w('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');\n            }\n\n            return true;\n        }\n    }, {\n        key: '_syncOffset',\n        value: function _syncOffset(data) {\n            // scan 1000 first bytes\n            var scanwindow = Math.min(1000, data.length - 3 * 188);\n            var i = 0;\n            while (i < scanwindow) {\n                // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n                if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n\n        /**\n         * Creates a track model internal to demuxer used to drive remuxing input\n         *\n         * @param {string} type 'audio' | 'video' | 'id3' | 'text'\n         * @param {number} duration\n         * @return {object} TSDemuxer's internal track model\n         */\n\n    }, {\n        key: 'createTrack',\n        value: function createTrack(type, duration) {\n            return {\n                container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n                type: type,\n                id: RemuxerTrackIdConfig[type],\n                pid: -1,\n                inputTimeScale: 90000,\n                sequenceNumber: 0,\n                samples: [],\n                len: 0,\n                dropped: type === 'video' ? 0 : undefined,\n                isAAC: type === 'audio' ? true : undefined,\n                duration: type === 'audio' ? duration : undefined\n            };\n        }\n    }]);\n\n    return TSDemuxer;\n}();\n\nexports.default = TSDemuxer;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/hls/tsdemuxer.js?")},"./src/demux/sps-parser.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (C) 2016 Bilibili. All Rights Reserved.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author zheng qian <xqq@xqq.im>\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n/* eslint-disable */\n\n\nvar _expGolomb = __webpack_require__(/*! ./exp-golomb.js */ \"./src/demux/exp-golomb.js\");\n\nvar _expGolomb2 = _interopRequireDefault(_expGolomb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SPSParser = function () {\n    function SPSParser() {\n        _classCallCheck(this, SPSParser);\n    }\n\n    _createClass(SPSParser, null, [{\n        key: '_ebsp2rbsp',\n        value: function _ebsp2rbsp(uint8array) {\n            var src = uint8array;\n            var src_length = src.byteLength;\n            var dst = new Uint8Array(src_length);\n            var dst_idx = 0;\n\n            for (var i = 0; i < src_length; i++) {\n                if (i >= 2) {\n                    // Unescape: Skip 0x03 after 00 00\n                    if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                        continue;\n                    }\n                }\n                dst[dst_idx] = src[i];\n                dst_idx++;\n            }\n\n            return new Uint8Array(dst.buffer, 0, dst_idx);\n        }\n    }, {\n        key: 'parseSPS',\n        value: function parseSPS(uint8array) {\n            var rbsp = SPSParser._ebsp2rbsp(uint8array);\n            var gb = new _expGolomb2.default(rbsp);\n\n            gb.readByte();\n            var profile_idc = gb.readByte(); // profile_idc\n            gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n            var level_idc = gb.readByte(); // level_idc\n            gb.readUEG(); // seq_parameter_set_id\n\n            var profile_string = SPSParser.getProfileString(profile_idc);\n            var level_string = SPSParser.getLevelString(level_idc);\n            var chroma_format_idc = 1;\n            var chroma_format = 420;\n            var chroma_format_table = [0, 420, 422, 444];\n            var bit_depth = 8;\n\n            if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 || profile_idc === 244 || profile_idc === 44 || profile_idc === 83 || profile_idc === 86 || profile_idc === 118 || profile_idc === 128 || profile_idc === 138 || profile_idc === 144) {\n\n                chroma_format_idc = gb.readUEG();\n                if (chroma_format_idc === 3) {\n                    gb.readBits(1); // separate_colour_plane_flag\n                }\n                if (chroma_format_idc <= 3) {\n                    chroma_format = chroma_format_table[chroma_format_idc];\n                }\n\n                bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n                gb.readUEG(); // bit_depth_chroma_minus8\n                gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n                if (gb.readBool()) {\n                    // seq_scaling_matrix_present_flag\n                    var scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n                    for (var i = 0; i < scaling_list_count; i++) {\n                        if (gb.readBool()) {\n                            // seq_scaling_list_present_flag\n                            if (i < 6) {\n                                SPSParser._skipScalingList(gb, 16);\n                            } else {\n                                SPSParser._skipScalingList(gb, 64);\n                            }\n                        }\n                    }\n                }\n            }\n            gb.readUEG(); // log2_max_frame_num_minus4\n            var pic_order_cnt_type = gb.readUEG();\n            if (pic_order_cnt_type === 0) {\n                gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n            } else if (pic_order_cnt_type === 1) {\n                gb.readBits(1); // delta_pic_order_always_zero_flag\n                gb.readSEG(); // offset_for_non_ref_pic\n                gb.readSEG(); // offset_for_top_to_bottom_field\n                var num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n                for (var _i = 0; _i < num_ref_frames_in_pic_order_cnt_cycle; _i++) {\n                    gb.readSEG(); // offset_for_ref_frame\n                }\n            }\n            gb.readUEG(); // max_num_ref_frames\n            gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n            var pic_width_in_mbs_minus1 = gb.readUEG();\n            var pic_height_in_map_units_minus1 = gb.readUEG();\n\n            var frame_mbs_only_flag = gb.readBits(1);\n            if (frame_mbs_only_flag === 0) {\n                gb.readBits(1); // mb_adaptive_frame_field_flag\n            }\n            gb.readBits(1); // direct_8x8_inference_flag\n\n            var frame_crop_left_offset = 0;\n            var frame_crop_right_offset = 0;\n            var frame_crop_top_offset = 0;\n            var frame_crop_bottom_offset = 0;\n\n            var frame_cropping_flag = gb.readBool();\n            if (frame_cropping_flag) {\n                frame_crop_left_offset = gb.readUEG();\n                frame_crop_right_offset = gb.readUEG();\n                frame_crop_top_offset = gb.readUEG();\n                frame_crop_bottom_offset = gb.readUEG();\n            }\n\n            var sar_width = 1,\n                sar_height = 1;\n            var fps = 0,\n                fps_fixed = true,\n                fps_num = 0,\n                fps_den = 0;\n\n            var vui_parameters_present_flag = gb.readBool();\n            if (vui_parameters_present_flag) {\n                if (gb.readBool()) {\n                    // aspect_ratio_info_present_flag\n                    var aspect_ratio_idc = gb.readByte();\n                    var sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                    var sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n                    if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                        sar_width = sar_w_table[aspect_ratio_idc - 1];\n                        sar_height = sar_h_table[aspect_ratio_idc - 1];\n                    } else if (aspect_ratio_idc === 255) {\n                        sar_width = gb.readByte() << 8 | gb.readByte();\n                        sar_height = gb.readByte() << 8 | gb.readByte();\n                    }\n                }\n\n                if (gb.readBool()) {\n                    // overscan_info_present_flag\n                    gb.readBool(); // overscan_appropriate_flag\n                }\n                if (gb.readBool()) {\n                    // video_signal_type_present_flag\n                    gb.readBits(4); // video_format & video_full_range_flag\n                    if (gb.readBool()) {\n                        // colour_description_present_flag\n                        gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n                    }\n                }\n                if (gb.readBool()) {\n                    // chroma_loc_info_present_flag\n                    gb.readUEG(); // chroma_sample_loc_type_top_field\n                    gb.readUEG(); // chroma_sample_loc_type_bottom_field\n                }\n                if (gb.readBool()) {\n                    // timing_info_present_flag\n                    var num_units_in_tick = gb.readBits(32);\n                    var time_scale = gb.readBits(32);\n                    fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n                    fps_num = time_scale;\n                    fps_den = num_units_in_tick * 2;\n                    fps = fps_num / fps_den;\n                }\n            }\n\n            var sarScale = 1;\n            if (sar_width !== 1 || sar_height !== 1) {\n                sarScale = sar_width / sar_height;\n            }\n\n            var crop_unit_x = 0,\n                crop_unit_y = 0;\n            if (chroma_format_idc === 0) {\n                crop_unit_x = 1;\n                crop_unit_y = 2 - frame_mbs_only_flag;\n            } else {\n                var sub_wc = chroma_format_idc === 3 ? 1 : 2;\n                var sub_hc = chroma_format_idc === 1 ? 2 : 1;\n                crop_unit_x = sub_wc;\n                crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n            }\n\n            var codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n            var codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n            codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n            codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n            var present_width = Math.ceil(codec_width * sarScale);\n\n            gb.destroy();\n            gb = null;\n\n            return {\n                profile_string: profile_string, // baseline, high, high10, ...\n                level_string: level_string, // 3, 3.1, 4, 4.1, 5, 5.1, ...\n                bit_depth: bit_depth, // 8bit, 10bit, ...\n                chroma_format: chroma_format, // 4:2:0, 4:2:2, ...\n                chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n                frame_rate: {\n                    fixed: fps_fixed,\n                    fps: fps,\n                    fps_den: fps_den,\n                    fps_num: fps_num\n                },\n\n                sar_ratio: {\n                    width: sar_width,\n                    height: sar_height\n                },\n\n                codec_size: {\n                    width: codec_width,\n                    height: codec_height\n                },\n\n                present_size: {\n                    width: present_width,\n                    height: codec_height\n                }\n            };\n        }\n    }, {\n        key: '_skipScalingList',\n        value: function _skipScalingList(gb, count) {\n            var last_scale = 8,\n                next_scale = 8;\n            var delta_scale = 0;\n            for (var i = 0; i < count; i++) {\n                if (next_scale !== 0) {\n                    delta_scale = gb.readSEG();\n                    next_scale = (last_scale + delta_scale + 256) % 256;\n                }\n                last_scale = next_scale === 0 ? last_scale : next_scale;\n            }\n        }\n    }, {\n        key: 'getProfileString',\n        value: function getProfileString(profile_idc) {\n            switch (profile_idc) {\n                case 66:\n                    return 'Baseline';\n                case 77:\n                    return 'Main';\n                case 88:\n                    return 'Extended';\n                case 100:\n                    return 'High';\n                case 110:\n                    return 'High10';\n                case 122:\n                    return 'High422';\n                case 244:\n                    return 'High444';\n                default:\n                    return 'Unknown';\n            }\n        }\n    }, {\n        key: 'getLevelString',\n        value: function getLevelString(level_idc) {\n            return (level_idc / 10).toFixed(1);\n        }\n    }, {\n        key: 'getChromaFormatString',\n        value: function getChromaFormatString(chroma) {\n            switch (chroma) {\n                case 420:\n                    return '4:2:0';\n                case 422:\n                    return '4:2:2';\n                case 444:\n                    return '4:4:4';\n                default:\n                    return 'Unknown';\n            }\n        }\n    }]);\n\n    return SPSParser;\n}();\n\nexports.default = SPSParser;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/demux/sps-parser.js?")},"./src/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mseController = __webpack_require__(/*! ./core/mse-controller */ \"./src/core/mse-controller.js\");\n\nvar _mseController2 = _interopRequireDefault(_mseController);\n\nvar _transmuxerProxy = __webpack_require__(/*! ./core/transmuxer-proxy */ \"./src/core/transmuxer-proxy.js\");\n\nvar _transmuxerProxy2 = _interopRequireDefault(_transmuxerProxy);\n\nvar _transmuxerHls = __webpack_require__(/*! ./core/transmuxer-hls */ \"./src/core/transmuxer-hls.js\");\n\nvar _transmuxerHls2 = _interopRequireDefault(_transmuxerHls);\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nvar _adaptiveMultiRate = __webpack_require__(/*! @ks/adaptive-multi-rate */ \"./node_modules/@ks/adaptive-multi-rate/lib/index.js\");\n\nvar _adaptiveMultiRate2 = _interopRequireDefault(_adaptiveMultiRate);\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _log = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n\nvar _playerLogger = __webpack_require__(/*! ./player-logger */ \"./src/player-logger.js\");\n\nvar _playerLogger2 = _interopRequireDefault(_playerLogger);\n\nvar _reportTypes = __webpack_require__(/*! ./core/report-types */ \"./src/core/report-types.js\");\n\nvar _playbackRateManager = __webpack_require__(/*! ./utils/playback-rate-manager */ \"./src/utils/playback-rate-manager.js\");\n\nvar _playbackRateManager2 = _interopRequireDefault(_playbackRateManager);\n\nvar _$const = __webpack_require__(/*! $const */ \"./src/const.js\");\n\nvar _liveRealtimeBeacon = __webpack_require__(/*! ./utils/live-realtime-beacon */ \"./src/utils/live-realtime-beacon.js\");\n\nvar _liveRealtimeBeacon2 = _interopRequireDefault(_liveRealtimeBeacon);\n\nvar _fps = __webpack_require__(/*! ./utils/fps */ \"./src/utils/fps.js\");\n\nvar _fps2 = _interopRequireDefault(_fps);\n\nvar _kernelEvents = __webpack_require__(/*! ./core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _kernelErrors = __webpack_require__(/*! ./core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nvar _browser = __webpack_require__(/*! ./utils/browser */ \"./src/utils/browser.js\");\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CHECK_PLAY_RATE_COUNTDOWN_FIRST = 30;\nvar CHECK_PLAY_RATE_COUNTDOWN = 3;\nvar MAIN_TIMER_INTERVAL = 200;\n\n// 心跳间隔=MAIN_TIMER_INTERVAL*HEARTBEAT_COUNTDOWN = 1000\nvar HEARTBEAT_COUNTDOWN = 5;\n\n/**\n * flv controller\n * @export\n * @class Flv\n */\n\nvar Flv = function (_Events) {\n    _inherits(Flv, _Events);\n\n    _createClass(Flv, null, [{\n        key: 'isSupport',\n        value: function isSupport() {\n            var streaming = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            var mediaSource = window.MediaSource || window.WebKitMediaSource;\n            var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;\n            var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n            var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n\n            var loaderValid = !streaming || fetch || navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n            return !!isTypeSupported && !!sourceBufferValidAPI && loaderValid;\n        }\n    }, {\n        key: 'version',\n        get: function get() {\n            return \"1.0.11\";\n        }\n\n        /**\n         * flv Wrapper\n         * @param {any} videodom videoElement\n         * @param {any} config config\n         * @class Flv\n         */\n\n    }]);\n\n    function Flv(videodom, config) {\n        _classCallCheck(this, Flv);\n\n        var _this = _possibleConstructorReturn(this, (Flv.__proto__ || Object.getPrototypeOf(Flv)).call(this));\n\n        _this.tag = 'flv-player';\n        _this.video = videodom;\n        if (!_this.off) {\n            _this.off = _this.removeListener;\n        }\n        _this.config = _config.ConfigHelper.processConfig(config);\n        if (!_this.config) {\n            setTimeout(function () {\n                _this.emit('error', { errno: _$const.ERRORNO.CONFIG_DATA_ERROR, errmsg: 'config data error' });\n            }, 0);\n            return _possibleConstructorReturn(_this);\n        }\n        if (_this.config.startFrom > 0) {\n            _this.video.currentTime = _this.config.startFrom / 1000;\n        }\n        _this.box = 'flv';\n        _this.lazyloadPaused = false;\n        _this.seekTimer = null;\n        _this._mainTimer = null;\n        _this.realtimeBeaconTimer = null;\n        _this.requestSetTime = false;\n        _this._parseUrlConfig();\n        _this.bindEvents();\n        _this.attachMedia();\n        _this.initLogger();\n        _this._initFps();\n        _this._startMainTimer();\n        _this._bufferStrategyTime = _this.config.bufferStrategyFirst;\n        _this._isSafari = navigator.userAgent.toLowerCase().indexOf('safari');\n        // 每_checkPlaybackRateCountdown*200ms检查一次是否需要切换播放速度, 首次检测值为\n        _this._checkPlaybackRateCountdown = CHECK_PLAY_RATE_COUNTDOWN_FIRST;\n        _this._playbackRateManager = new _playbackRateManager2.default();\n        // 心跳\n        _this._heartbeatCountdown = 0;\n        _this._heartbeatEnable = false;\n        _this._seek = _this._seek.bind(_this);\n        _this._seekWithLoad = _this._seekWithLoad.bind(_this);\n        _log.Log.i('kernel', Flv.version);\n        _log.Log.i(_this.tag, 'isLive', _this.config.isLive);\n        return _this;\n    }\n\n    _createClass(Flv, [{\n        key: '_initFps',\n        value: function _initFps() {\n            this._fps = new _fps2.default();\n            this._fps.attachMedia(this.video);\n        }\n        /**\n         * 初始化事件处理器\n         */\n\n    }, {\n        key: 'initLogger',\n        value: function initLogger() {\n            var _this2 = this;\n\n            this.logger = new _playerLogger2.default(Flv.version, this.video, this.config);\n            this.logger.on('report', function (handle) {\n                _this2.emit('report', handle);\n            });\n        }\n\n        /**\n         * bind events\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'bindEvents',\n        value: function bindEvents() {\n            if (this.video) {\n                this._onVideoCanplay = this._onVideoCanplay.bind(this);\n                this._onVideoWaiting = this._onVideoWaiting.bind(this);\n                this._onVideoPlaying = this._onVideoPlaying.bind(this);\n                this._onVideoError = this._onVideoError.bind(this);\n                this._onVideoPlay = this._onVideoPlay.bind(this);\n                this._onVideoEnded = this._onVideoEnded.bind(this);\n                this.video.addEventListener('canplay', this._onVideoCanplay);\n                this.video.addEventListener('waiting', this._onVideoWaiting);\n                this.video.addEventListener('playing', this._onVideoPlaying);\n                this.video.addEventListener('play', this._onVideoPlay);\n                this.video.addEventListener('error', this._onVideoError);\n                this.video.addEventListener('ended', this._onVideoEnded);\n            }\n        }\n        /**\n         * 移除mediasource事件\n         * @param {MSEController} mediaSource MSEController\n         */\n\n    }, {\n        key: 'unbindMediaSourceEvent',\n        value: function unbindMediaSourceEvent(mediaSource) {\n            mediaSource.removeAllListeners();\n        }\n    }, {\n        key: '_onVideoPlay',\n        value: function _onVideoPlay() {\n            if (!this.transmuxer) {\n                this.load();\n            }\n            this._startBeacon();\n        }\n    }, {\n        key: '_onVideoEnded',\n        value: function _onVideoEnded() {\n            this._stopBeacon();\n        }\n\n        /**\n         * new mediaSource\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'attachMedia',\n        value: function attachMedia() {\n            var _this3 = this;\n\n            this.mediaSource = new _mseController2.default(this.video, this.config);\n\n            this.mediaSource.on(_kernelEvents2.default.ERROR, function (errorMessage) {\n                _this3._onError(errorMessage);\n                if (_this3.transmuxer) {\n                    _this3.transmuxer.pause();\n                }\n            });\n            this.mediaSource.on('bufferFull', function () {\n                _this3.pauseTransmuxer();\n            });\n            this.mediaSource.on('updateend', function () {\n                _this3.onmseUpdateEnd();\n            });\n        }\n\n        /**\n         * load\n         * @param {string} src src\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'load',\n        value: function load(src) {\n            if (src) {\n                _config.ConfigHelper.setSrc(this.config, src);\n            }\n            this._heartbeatEnable = true;\n            if (this.config.box === 'hls') {\n                this.transmuxer = new _transmuxerHls2.default(this.config);\n            } else {\n                this.transmuxer = new _transmuxerProxy2.default(this.config);\n            }\n            // TODO:multipart-flv beacon\n            this.realtimeBeaconBuilder = new _liveRealtimeBeacon2.default(this.config.multipart ? this.config.src.segments[0].url : this.transmuxer.getCurrentUrl(0));\n            this._startBeacon();\n            this.transmuxer.bufferedLengthFun = this._getBufferedLength.bind(this);\n            this.transmuxer.currentTimeFun = this._getCurrentTime.bind(this);\n            this.transmuxerEvent(this.transmuxer);\n            this.transmuxer.init();\n            this.transmuxer.loadSource();\n        }\n\n        /**\n         * 获取实时播放状态\n         * @returns {object} 播放状态\n         */\n\n    }, {\n        key: 'getStat',\n        value: function getStat() {\n            if (this.logger) {\n                var stat = {\n                    videodatarate: this.logger.data.videodatarate,\n                    audiodatarate: this.logger.data.audiodatarate,\n                    url: this.transmuxer.getCurrentUrl(this.video.currentTime * 1000),\n                    fps: this.logger.playingInfo.mediaInfo.fps\n                };\n                return stat;\n            }\n            return null;\n        }\n\n        /**\n         * 切换码率\n         * @param {number} value 码率\n         */\n\n    }, {\n        key: 'selectBitrate',\n        value: function selectBitrate(value) {\n            var _this4 = this;\n\n            if (value === this.getCurrentBitrate()) {\n                return;\n            }\n            // TODO: flv为平滑切换\n            var smooth = this.config.box === 'flv';\n            if (this.transmuxer) {\n                this.transmuxer.pause();\n            }\n            setTimeout(function () {\n                if (_this4.mediaSource && !smooth) {\n                    _this4.mediaSource.flush();\n                }\n                if (_this4.transmuxer) {\n                    _this4.transmuxer.selectBitrate(value);\n                }\n                _this4._selectBitrate = true;\n                if (!_this4._bitrateTimer && !smooth && _browser2.default.chrome) {\n                    _this4._bitrateTimer = setInterval(function () {\n                        if (_this4._selectBitrate) {\n                            if (_this4.isTimeinBuffered(_this4.video.currentTime)) {\n                                // 做一次buffer内seek，重新解码\n                                _this4.video.currentTime = _this4.video.currentTime;\n                                _this4._selectBitrate = false;\n                                clearInterval(_this4._bitrateTimer);\n                                _this4._bitrateTimer = null;\n                            }\n                        } else {\n                            clearInterval(_this4._bitrateTimer);\n                            _this4._bitrateTimer = null;\n                        }\n                    }, 100);\n                }\n            }, 100);\n        }\n\n        /**\n         * 获取码率列表\n         * @returns {array} 码率列表\n         */\n\n    }, {\n        key: 'getBitrates',\n        value: function getBitrates() {\n            if (this.transmuxer) {\n                return this.transmuxer.getBitrates();\n            }\n            return [];\n        }\n    }, {\n        key: 'transmuxerEvent',\n        value: function transmuxerEvent(transmuxer) {\n            var _this5 = this;\n\n            var mediaSource = this.mediaSource;\n            transmuxer.on(_kernelEvents2.default.PARSING_DATA, function (handle) {\n                mediaSource.emit(_kernelEvents2.default.PARSING_DATA, handle);\n            });\n\n            transmuxer.on(_kernelEvents2.default.PARSING_INIT_SEGMENT, function (handle) {\n                _this5.logger.record({ type: _reportTypes.REPORT_TYPES.MEDIA_SEGMENT_INIT, ts: Date.now() });\n                mediaSource.emit(_kernelEvents2.default.PARSING_INIT_SEGMENT, handle);\n            });\n\n            transmuxer.on(_kernelEvents2.default.ERROR, function (errorMessage) {\n                _this5._onError(errorMessage);\n                transmuxer.pause();\n                mediaSource.pause();\n            });\n\n            transmuxer.on(_kernelEvents2.default.END, function () {\n                mediaSource.endOfData();\n            });\n\n            transmuxer.on(_kernelEvents2.default.MEDIA_INFO, function (mediaInfo) {\n                _this5.logger.record({ type: _reportTypes.REPORT_TYPES.MEDIA_INFO, data: mediaInfo });\n                _this5.emit(_kernelEvents2.default.REPORT, { type: 'mediaInfo', value: mediaInfo });\n                if (!_this5.mediaInfo) {\n                    _this5.video.addEventListener('seeking', _this5._seek);\n                }\n                _this5.mediaInfo = mediaInfo;\n                mediaSource.init(mediaInfo);\n            });\n            transmuxer.on(_kernelEvents2.default.REPORT, function (handle) {\n                _this5.logger.record(handle);\n            });\n            transmuxer.on(_kernelEvents2.default.LOST_FRAMES, function (handle) {\n                _this5.realtimeBeaconBuilder.lostFrame(handle.drop);\n            });\n            transmuxer.on('adaptiveAlgorithm', function (data) {\n                return _this5.emit('adaptiveAlgorithm', data);\n            });\n            transmuxer.on(_kernelEvents2.default.LEVEL_SWITCHED, function (data) {\n                if (!data.smooth) {\n                    _this5.mediaSource.flush();\n                }\n                _this5.emit('levelSwitched', data.bitrate);\n            });\n            transmuxer.on(_kernelEvents2.default.SCRIPT_PARSED, function (data) {\n                if (data.hasOwnProperty('onMetaData')) {\n                    _this5.emit('report', { type: 'metadata', value: data.onMetaData });\n                }\n            });\n            transmuxer.on(_kernelEvents2.default.MANIFEST_PARSED, function (data) {\n                _this5.emit('manifestParsed', data);\n            });\n        }\n\n        /**\n         * seek in buffered\n         * @param {number} seconds time\n         * @returns {boolean} isTimeinBuffered\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'isTimeinBuffered',\n        value: function isTimeinBuffered(seconds) {\n            var buffered = this.video.buffered;\n            for (var i = 0; i < buffered.length; i++) {\n                var from = buffered.start(i);\n                var to = buffered.end(i);\n                if (seconds >= from && seconds < to) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: '_getBufferEnd',\n        value: function _getBufferEnd(buffered, currentTime) {\n            var currentRangeEnd = 0;\n\n            for (var i = 0; i < buffered.length; i++) {\n                var start = buffered.start(i);\n                var end = buffered.end(i);\n                if (start <= currentTime && currentTime < end) {\n                    currentRangeEnd = end;\n                    return currentRangeEnd;\n                }\n            }\n            return null;\n        }\n    }, {\n        key: 'getCurrentBufferEnd',\n        value: function getCurrentBufferEnd() {\n            return this._getBufferEnd(this.video.buffered, this.video.currentTime);\n        }\n\n        /**\n         * 获取当前播放时间\n         * @returns {Number} 播放时间，毫秒\n         */\n\n    }, {\n        key: '_getCurrentTime',\n        value: function _getCurrentTime() {\n            if (this.video) {\n                return this.video.currentTime * 1000;\n            }\n            return 0;\n        }\n\n        /**\n         * _seek\n         * @memberof Flv\n         * @returns {number} seekTime\n         */\n\n    }, {\n        key: '_seek',\n        value: function _seek() {\n            var currentTime = this.video.currentTime;\n            if (this.isTimeinBuffered(currentTime) || this.requestSetTime) {\n                this.requestSetTime = false;\n            } else if (currentTime === 0 && this.video.buffered.start(0) < 1) {\n                this.video.currentTime = this.video.buffered.start(0);\n            } else {\n                this._seekDelay();\n            }\n            return currentTime;\n        }\n    }, {\n        key: '_seekDelay',\n        value: function _seekDelay() {\n            this._clearSeekDelay();\n            this._seekDelayId = setTimeout(this._seekWithLoad.bind(this), 200);\n        }\n    }, {\n        key: '_clearSeekDelay',\n        value: function _clearSeekDelay() {\n            if (this._seekDelayId) {\n                clearTimeout(this._seekDelayId);\n                this._seekDelayId = 0;\n            }\n        }\n    }, {\n        key: '_seekWithLoad',\n        value: function _seekWithLoad() {\n            var _this6 = this;\n\n            if (this.config.isLive || !this.transmuxer) {\n                return;\n            }\n            var currentTime = this.video.currentTime;\n            this.transmuxer.pause();\n            var nearlestkeyframe = this.transmuxer.getNearestKeyframe(Math.floor(currentTime * 1000));\n            if (nearlestkeyframe) {\n                currentTime = nearlestkeyframe.keyframetime / 1000;\n            }\n            this.seekTimer = setTimeout(function () {\n                _this6.mediaSource.flush(currentTime);\n                _this6.transmuxer.seek(nearlestkeyframe);\n            }, 100);\n\n            if (this.config.alwaysSeekKeyframe) {\n                this.video.currentTime = currentTime;\n                this.requestSetTime = true;\n            }\n            this.lazyloadPaused = false;\n        }\n\n        /**\n         * mediaSource updateend\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'onmseUpdateEnd',\n        value: function onmseUpdateEnd() {\n            if (this.mediaSource.sourceBuffer.video) {\n                this.realtimeBeaconBuilder.videoBufferedUpdated(this.mediaSource.sourceBuffer.video.buffered);\n            }\n            if (this.config.isLive) {\n                return;\n            }\n            var currentBufferEnd = this.getCurrentBufferEnd();\n            var currentTime = this.video.currentTime;\n            if (currentBufferEnd >= currentTime + this.config.lazyLoadMaxDuration && !this.lazyloadPaused) {\n                _log.Log.v(this.tag, 'Maximum buffering duration exceeded, suspend transmuxing task');\n                this.pauseTransmuxer();\n            }\n        }\n\n        /**\n         * Check buffer length regularly and apply various policies to avoid buffering\n         * @memberof Flv\n         */\n\n    }, {\n        key: '_mainLoop',\n        value: function _mainLoop() {\n            var EPS = 1e-3;\n            var video = this.video;\n            if (this._heartbeatEnable) {\n                if (this._heartbeatCountdown <= 0) {\n                    this._heartbeatCountdown = HEARTBEAT_COUNTDOWN;\n                    this._heartbeat();\n                }\n                this._heartbeatCountdown--;\n            }\n\n            var currentBufferEnd = this.getCurrentBufferEnd();\n            if (this.config.isLive) {\n                // 每_checkPlaybackRateCountdown*200ms检查一次是否需要切换播放速度\n                if (this.config && this.config.adaptiveMultiRate && !this.video.paused) {\n                    if (!this._checkPlaybackRateCountdown) {\n                        var buffered = currentBufferEnd - this.video.currentTime;\n                        this._changePlaybackRate(this._playbackRateManager.nextPlayBackRate(buffered, this.video.playbackRate));\n                        this._checkPlaybackRateCountdown = CHECK_PLAY_RATE_COUNTDOWN;\n                    } else {\n                        this._checkPlaybackRateCountdown--;\n                    }\n                }\n\n                if (this.mediaSource) {\n                    this.mediaSource.doUpdate();\n                }\n            }\n            if (currentBufferEnd === null) {\n                var _buffered = this.video.buffered;\n                var lenBuffered = _buffered.length;\n                if (lenBuffered > 0 && _buffered.start(lenBuffered - 1) > video.currentTime + EPS) {\n                    if (_buffered.length > 1 && this.isTimeinBuffered(video.currentTime + 1)) {\n                        this.video.currentTime = _buffered.start(lenBuffered - 1) + 1;\n                    }\n                }\n                if (this.video.currentTime === 0 && lenBuffered > 0 && _buffered.start(lenBuffered - 1) >= 0.1 && this.isTimeinBuffered(video.currentTime + 0.3)) {\n                    this.video.currentTime = _buffered.start(lenBuffered - 1) + 0.3;\n                }\n            }\n            if (this.video.seeking && this.isTimeinBuffered(this.video.currentTime + 0.01)) {\n                if (this._seekBlock) {\n                    this.video.currentTime += 0.01;\n                    this._seekBlock = false;\n                }\n                this._seekBlock = true;\n            }\n        }\n    }, {\n        key: '_changePlaybackRate',\n        value: function _changePlaybackRate(toRate) {\n            if (this.video.playbackRate !== toRate) {\n                _log.Log.v('Change playback rate from ' + this.video.playbackRate + ' to ' + toRate);\n                this.video.playbackRate = toRate;\n                this.realtimeBeaconBuilder.playbackSpeedChanged(toRate);\n            }\n        }\n\n        /**\n         * Emit realtime analystic data\n         */\n\n    }, {\n        key: '_sendRealtimeBeacon',\n        value: function _sendRealtimeBeacon() {\n            if (this.transmuxer) {\n                // TODO: multipart-flv beacon\n                try {\n                    this.realtimeBeaconBuilder.setPlayUrl(this.config.box === 'flv' ? this.transmuxer.getCurrentUrl(this.video.currentTime * 1000) : this.config.src);\n                } catch (e) {\n                    _log.Log.v(this.tag, 'transmuxer url empty');\n                }\n            }\n            if (this.mediaSource.sourceBuffer.audio) {\n                var bufferEnd = this._getBufferEnd(this.mediaSource.sourceBuffer.audio.buffered, this.video.currentTime);\n                this.realtimeBeaconBuilder.setAudioBufferedSec(bufferEnd - this.video.currentTime);\n            }\n            if (this.mediaSource.sourceBuffer.video) {\n                var _bufferEnd = this._getBufferEnd(this.mediaSource.sourceBuffer.video.buffered, this.video.currentTime);\n                this.realtimeBeaconBuilder.setVideoBufferedSec(_bufferEnd - this.video.currentTime);\n            }\n            var beacon = this.realtimeBeaconBuilder.buildAndStartNewInterval();\n            _log.Log.v(this.tag, 'realtimeBeacon');\n            this.emit('report', { type: 'realtimeBeacon', value: beacon });\n        }\n        /**\n         * ‘canplay’ event listener\n         */\n\n    }, {\n        key: '_onVideoCanplay',\n        value: function _onVideoCanplay() {\n            this._checkAutoplay();\n            this.logger.record({ type: _reportTypes.REPORT_TYPES.CANPLAY, ts: Date.now() });\n        }\n\n        /**\n         * 尝试调用play方法，验证是否可自动播放\n         */\n\n    }, {\n        key: '_checkAutoplay',\n        value: function _checkAutoplay() {\n            if (this.video && this.video.autoplay && !this._autoplayChecked) {\n                this._callVideoplay();\n                this._autoplayChecked = true;\n            }\n        }\n\n        /**\n         * 'waiting' event listener\n         */\n\n    }, {\n        key: '_onVideoWaiting',\n        value: function _onVideoWaiting() {\n            if (this.video && !this.video.seeking) {\n                this.transmuxer.waitingBuffered(this._bufferStrategyTime);\n                this._increaseBufferTime();\n                var bufferedLength = this._getBufferedLength();\n                _log.Log.i(this.tag, 'waiting currentTime:', this.video.currentTime, 'bufferedLength:', bufferedLength);\n                this.realtimeBeaconBuilder.bufferingStarted(bufferedLength);\n            }\n        }\n\n        /**\n         * 卡顿时缓冲策略\n         */\n\n    }, {\n        key: '_increaseBufferTime',\n        value: function _increaseBufferTime() {\n            this._bufferStrategyTime = this._bufferStrategyTime || this.config.bufferStrategyFirst;\n            if (this._bufferStrategyTime >= 0 && this._bufferStrategyTime < 1000) {\n                this._bufferStrategyTime += this.config.bufferStrategyIncrementStep;\n            } else if (this._bufferStrategyTime >= 1000 && this._bufferStrategyTime < 2000) {\n                this._bufferStrategyTime += this.config.bufferStrategyIncrementStep * 0.8;\n            } else if (this._bufferStrategyTime >= 2000 && this._bufferStrategyTime < 3000) {\n                this._bufferStrategyTime += this.config.bufferStrategyIncrementStep * 0.6;\n            } else if (this._bufferStrategyTime >= 3000 && this._bufferStrategyTime < 4000) {\n                this._bufferStrategyTime += this.config.bufferStrategyIncrementStep * 0.4;\n            } else if (this._bufferStrategyTime >= 4000 && this._bufferStrategyTime < 5000) {\n                this._bufferStrategyTime += this.config.bufferStrategyIncrementStep * 0.2;\n            }\n            this._bufferStrategyTime = Math.min(this._bufferStrategyTime, this.config.bufferStrategyLimit);\n        }\n\n        /**\n         * 'playing' event listener\n         */\n\n    }, {\n        key: '_onVideoPlaying',\n        value: function _onVideoPlaying() {\n            _log.Log.i(this.tag, 'playing');\n            var bufferedLength = this._getBufferedLength();\n            this.logger.record({ type: _reportTypes.REPORT_TYPES.PLAYING, buffered: bufferedLength, ts: Date.now() });\n            this.realtimeBeaconBuilder.bufferingEnded();\n        }\n    }, {\n        key: '_onVideoError',\n        value: function _onVideoError(error) {\n            _log.Log.e(this.tag, 'video error', error);\n            this.emit('error', { errno: _$const.ERRORNO.CODEC_ERROR, errmsg: error.message });\n        }\n\n        /**\n         * 封装video.play，捕获play方法失败，目前用于处理游览器不允许autoplay\n         * @returns {Promise} playPromise\n         */\n\n    }, {\n        key: '_callVideoplay',\n        value: function _callVideoplay() {\n            var _this7 = this;\n\n            var playPromise = this.video.play();\n            if (typeof playPromise !== 'undefined') {\n                playPromise.then(function () {}).catch(function (error) {\n                    _log.Log.e(_this7.tag, 'can not autoplay!', error);\n                    _this7.emit('error', { errno: _$const.ERRORNO.VIDEO_ELEMENT_PLAY_ERROR, errmsg: error.message });\n                });\n            }\n            return playPromise;\n        }\n\n        /**\n         * pause transmuxer\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'pauseTransmuxer',\n        value: function pauseTransmuxer() {\n            this.transmuxer.pause();\n            this.mediaSource.pause();\n            this.lazyloadPaused = true;\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            _log.Log.i(this.tag, 'call resume');\n            this._seek(0);\n        }\n\n        /**\n         * destroy\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            window.clearInterval(this.seekTimer);\n            this._stopMainTimer();\n            this._stopBeacon();\n            this.video.removeEventListener('canplay', this._onVideoCanplay);\n            this.video.removeEventListener('seeking', this._seek);\n            this.video.removeEventListener('waiting', this._onVideoWaiting);\n            this.video.removeEventListener('playing', this._onVideoPlaying);\n            this.video.removeEventListener('play', this._onVideoPlay);\n            this.video.removeEventListener('ended', this._onVideoEnded);\n            if (this.video) {\n                URL.revokeObjectURL(this.video.src);\n                this.video.src = '';\n                this.video.removeAttribute('src');\n                if (this.transmuxer) {\n                    this.transmuxer.bufferedLengthFun = null;\n                    this.transmuxer.currentTimeFun = null;\n                    this.transmuxer.removeAllListeners();\n                    this.transmuxer.pause();\n                    this.transmuxer.destroy();\n                    this.transmuxer = null;\n                }\n                if (this.mediaSource) {\n                    this.unbindMediaSourceEvent(this.mediaSource);\n                    this.mediaSource.destroy();\n                    this.mediaSource = null;\n                }\n            }\n            if (this.logger) {\n                this.logger.removeAllListeners();\n                this.logger = null;\n            }\n            this.lazyloadPaused = false;\n\n            clearInterval(this._bitrateTimer);\n            this._bitrateTimer = null;\n        }\n    }, {\n        key: 'seek',\n        value: function seek(seconds) {\n            _log.Log.i(this.tag, 'call kernel seek');\n            if (!this.config.isLive) {\n                this.video.currentTime = seconds;\n            }\n        }\n    }, {\n        key: 'play',\n        value: function play() {\n            _log.Log.i(this.tag, 'call kernel play');\n            return this._callVideoplay();\n        }\n    }, {\n        key: 'pause',\n        value: function pause() {\n            _log.Log.i(this.tag, 'call kernel pause');\n            return this.video.pause();\n        }\n    }, {\n        key: 'refresh',\n        value: function refresh() {\n            _log.Log.i(this.tag, 'call kernel refresh');\n            if (this.transmuxer && this.mediaSource) {\n                this._seek(0);\n            } else {\n                _log.Log.v(this.tag, 'transmuxer & mediaSource not ready');\n            }\n        }\n\n        /**\n         * stop stream load\n         * @memberof Flv\n         */\n\n    }, {\n        key: 'stopLoad',\n        value: function stopLoad() {\n            _log.Log.i(this.tag, 'call kernel stopLoad');\n            if (this.transmuxer) {\n                this.transmuxer.pause();\n            }\n            this._stopBeacon();\n        }\n\n        /**\n         * 返回传入时间对应的流时间\n         * @param {number} time 时间（毫秒）\n         * @returns {number} 流时间\n         */\n\n    }, {\n        key: 'getStreamTime',\n        value: function getStreamTime(time) {\n            time = parseInt(time, 10);\n            if (this.transmuxer) {\n                return this.transmuxer.getStreamTime(time);\n            }\n            return NaN;\n        }\n\n        /*\n        * 计算video buffer量\n        * @private\n        */\n\n    }, {\n        key: '_getBufferedLength',\n        value: function _getBufferedLength() {\n            if (this.video && this.video.buffered.length > 0) {\n                return (this.video.buffered.end(this.video.buffered.length - 1) - this.video.currentTime) * 1000;\n            }\n            return 0;\n        }\n\n        /**\n         * test 手动切换接口\n         * @param {number} value value\n         */\n\n    }, {\n        key: 'testNextResolution',\n        value: function testNextResolution(value) {\n            this.transmuxer.testNextResolution(value);\n        }\n    }, {\n        key: 'getCurrentBitrate',\n        value: function getCurrentBitrate() {\n            return this.transmuxer.getCurrentBitrate();\n        }\n    }, {\n        key: '_parseUrlConfig',\n\n\n        /**\n         * 解析url中的开关参数\n         */\n        value: function _parseUrlConfig() {\n            var level = location.href.match(/kwaiKernelLog=([a-z]{1})/) ? location.href.match(/kwaiKernelLog=([a-z]{1})/)[1] : _log.LOG_LEVEL.LEVEL_ERROR;\n            this.config.kwaiKernelLog = level;\n            _log.Log.level(level);\n            _adaptiveMultiRate2.default.setLogLevel(level);\n        }\n\n        /**\n         * 心跳处理\n         */\n\n    }, {\n        key: '_heartbeat',\n        value: function _heartbeat() {\n            var data = {\n                totalReceive: this.logger.data.totalLoaded,\n                speed: this.logger.getLoadSpeed(),\n                videoDataRate: this.logger.data.videoDataRate,\n                audioDataRate: this.logger.data.audioDataRate,\n                decodedFPS: this.logger.data.decodedFPS,\n                droppedFPS: this.logger.data.droppedFPS,\n                decodedFrames: this.logger.data.decodedFrames,\n                droppedFrames: this.logger.data.droppedFrames\n            };\n            if (this._fps) {\n                this.logger.setFPS(this._fps.checkFPSInterval());\n                this.logger.refresh();\n            }\n            if (this.transmuxer) {\n                this.transmuxer.heartbeat();\n            }\n            this.emit('report', { type: 'heartbeat', value: data });\n            this.realtimeBeaconBuilder.updateDownloadedBytes(data.totalReceive);\n\n            if (this.lazyloadPaused && !this.video.seeking) {\n                var currentBufferEnd = this.getCurrentBufferEnd();\n                var currentTime = this.video.currentTime;\n                if (currentBufferEnd - currentTime < this.config.lazyLoadRecoverDuration) {\n                    this.lazyloadPaused = false;\n                    _log.Log.v(this.tag, 'Continue loading from paused position', currentBufferEnd, currentTime);\n                    this.transmuxer.resume();\n                    this.mediaSource.resume();\n                }\n            }\n        }\n\n        /**\n         * kernel内部错误与抛出错误转换\n         * @param {*} data 错误数据\n         */\n\n    }, {\n        key: '_onError',\n        value: function _onError(data) {\n            if (data.fatel) {\n                this.stopLoad();\n            }\n            var errInfo = { errno: _$const.ERRORNO.UNKNOW, errmsg: data.reason || 'unknow' };\n            switch (data.type) {\n                case _kernelErrors.ErrorTypes.NETWORK_ERROR:\n                    errInfo.errno = _$const.ERRORNO.NET_ERROR;\n                    errInfo.statusCode = data.statusCode;\n                    errInfo.url = data.url;\n                    break;\n                case _kernelErrors.ErrorTypes.MSE_ERROR:\n                    switch (data.details) {\n                        case _kernelErrors.ErrorDetails.APPENDBUFFER_ERROR:\n                            errInfo.errno = _$const.ERRORNO.APPENDBUFFER_ERROR;\n                            break;\n                        case _kernelErrors.ErrorDetails.ENDOFSTREAM_ERROR:\n                            errInfo.errno = _$const.ERRORNO.ENDOFSTREAM_ERROR;\n                            break;\n                        case _kernelErrors.ErrorDetails.MEDIASOURCE_ERROR:\n                            errInfo.errno = _$const.ERRORNO.MEDIASOURCE_ERROR;\n                            break;\n                        default:\n                            errInfo.errno = _$const.ERRORNO.SOURCEBUFFER_ERROR;\n                            break;\n                    }\n                    break;\n                case _kernelErrors.ErrorTypes.MEDIA_ERROR:\n                    errInfo.errno = _$const.ERRORNO.FORMAT_ERROR;\n                    if (data.details === _kernelErrors.ErrorDetails.CANNOT_SEEK) {\n                        errInfo.errno = _$const.ERRORNO.CANNOT_SEEK;\n                    }\n                    break;\n                case _kernelErrors.ErrorTypes.MUX_ERROR:\n                    errInfo.errno = _$const.ERRORNO.FORMAT_ERROR;\n                    break;\n                case _kernelErrors.ErrorTypes.OTHER_ERROR:\n                    errInfo.errno = _$const.ERRORNO.FORMAT_ERROR;\n                    break;\n            }\n            this.emit('error', errInfo);\n        }\n    }, {\n        key: '_startBeacon',\n        value: function _startBeacon() {\n            if (this.realtimeBeaconTimer === null) {\n                this.realtimeBeaconTimer = setInterval(this._sendRealtimeBeacon.bind(this), 10000);\n            }\n            this._heartbeatEnable = true;\n        }\n    }, {\n        key: '_stopBeacon',\n        value: function _stopBeacon() {\n            if (this.realtimeBeaconTimer) {\n                // Send the last realtime beacon and clear timer\n                window.clearInterval(this.realtimeBeaconTimer);\n                this._sendRealtimeBeacon();\n                this.realtimeBeaconTimer = null;\n            }\n            this._heartbeatEnable = false;\n            this._heartbeatCountdown = HEARTBEAT_COUNTDOWN;\n        }\n    }, {\n        key: '_startMainTimer',\n        value: function _startMainTimer() {\n            if (this._mainTimer === null) {\n                this._mainTimer = setInterval(this._mainLoop.bind(this), MAIN_TIMER_INTERVAL);\n            }\n        }\n    }, {\n        key: '_stopMainTimer',\n        value: function _stopMainTimer() {\n            if (this._mainTimer) {\n                window.clearInterval(this._mainTimer);\n                this._mainTimer = null;\n            }\n        }\n    }, {\n        key: 'monitorDataJson',\n        get: function get() {\n            return this.logger.dataJson;\n        }\n    }, {\n        key: 'monitorData',\n        get: function get() {\n            return this.logger.data;\n        }\n    }]);\n\n    return Flv;\n}(_events2.default);\n\nexports.default = Flv;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/index.js?")},"./src/io/download-cache.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * 下载数据缓存\n */\nvar DownloadCache = function () {\n    function DownloadCache() {\n        _classCallCheck(this, DownloadCache);\n\n        // 初始cache大小\n        this._cacheSize = 1024 * 1024 * 10;\n        // 读写指针\n        this._readOffset = 0;\n        this._writeOffset = 0;\n        // cache\n        this._cacheBuffer = new ArrayBuffer(this._cacheSize);\n        this._cache = new Uint8Array(this._cacheBuffer);\n    }\n\n    /**\n     * 添加至cache\n     * @param {ArrayBuffer} chunk 数据块\n     */\n\n\n    _createClass(DownloadCache, [{\n        key: "pushData",\n        value: function pushData(chunk) {\n            if (this._writeOffset + chunk.byteLength > this._cacheSize) {\n                var expected = this._writeOffset + chunk.byteLength - this._readOffset;\n                if (expected > this._cacheSize) {\n                    // 扩展\n                    this._collateCache();\n                    this._expandCache(expected);\n                } else {\n                    // 整理buffer\n                    this._collateCache();\n                }\n            }\n            this._cache.set(new Uint8Array(chunk), this._writeOffset);\n            this._writeOffset += chunk.byteLength;\n        }\n\n        /**\n         * 获取数据拷贝\n         * @param {number} len 数据长度\n         * @returns {Uint8Array} 数据\n         */\n\n    }, {\n        key: "getData",\n        value: function getData(len) {\n            if (len + this._readOffset > this._writeOffset) {\n                return null;\n            }\n            var data = this._cache.slice(this._readOffset, this._readOffset + len);\n            this._readOffset += len;\n            return data;\n        }\n\n        /**\n         * 获取数据读取Uint8Array，从cache中直接读取，异步使用可能出现故障\n         * @param {number} len 数据长度\n         * @returns {Uint8Array} 数据视图\n         */\n\n    }, {\n        key: "readData",\n        value: function readData(len) {\n            if (len + this._readOffset > this._writeOffset) {\n                return null;\n            }\n            return new Uint8Array(this._cacheBuffer, this._readOffset, len);\n        }\n\n        /**\n         * 后移读指针\n         * @param {number} len 数据长度\n         */\n\n    }, {\n        key: "skip",\n        value: function skip(len) {\n            if (len + this._readOffset > this._writeOffset) {\n                return;\n            }\n            this._readOffset += len;\n        }\n    }, {\n        key: "flush",\n        value: function flush() {\n            this._readOffset = this._writeOffset = 0;\n        }\n\n        /**\n         * 未读取数据长度\n         */\n\n    }, {\n        key: "_collateCache",\n\n\n        /**\n         * 整理cache中的数据，抛弃已读取的数据\n         */\n        value: function _collateCache() {\n            var remain = new Uint8Array(this._cacheBuffer, this._readOffset, this._writeOffset - this._readOffset);\n            this._cache.set(remain);\n            this._writeOffset -= this._readOffset;\n            this._readOffset = 0;\n        }\n\n        /**\n         * 扩展cache，cache不足时，cache容量max(翻倍,预期)\n         * @param {number} expected 预期最小值\n         */\n\n    }, {\n        key: "_expandCache",\n        value: function _expandCache(expected) {\n            this._cacheSize = Math.max(this._cacheSize * 2, expected);\n            this._cacheBuffer = ArrayBuffer.transfer(this._cacheBuffer, this._cacheSize);\n            this._cache = new Uint8Array(this._cacheBuffer);\n        }\n    }, {\n        key: "unreadLen",\n        get: function get() {\n            return this._writeOffset - this._readOffset;\n        }\n    }]);\n\n    return DownloadCache;\n}();\n\nexports.default = DownloadCache;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/download-cache.js?')},"./src/io/fetch.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fetch firfox 直播 点播\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * author songguangyu\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * email 522963130@qq.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _handleRange = __webpack_require__(/*! ./handleRange */ \"./src/io/handleRange.js\");\n\nvar _handleRange2 = _interopRequireDefault(_handleRange);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * FetchLoader\n * @class FetchLoader\n */\nvar FetchLoader = function () {\n    _createClass(FetchLoader, null, [{\n        key: 'isSupport',\n\n        /**\n         * broswer is support moz-chunk\n         * @returns {boolean} 是否支持\n         */\n        value: function isSupport() {\n            if (self.fetch && self.ReadableStream) {\n                return true;\n            }\n            return false;\n        }\n    }]);\n\n    function FetchLoader() {\n        _classCallCheck(this, FetchLoader);\n\n        this.tag = 'fetch';\n        this._requestAbort = false;\n        this._config = {\n            timeout: 0,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0\n        };\n    }\n    /**\n     * 开始加载\n     * @param {object} context context\n     * @param {string} context.src 下载地址\n     * @param {object} context.range 下载range\n     * @param {number} context.range.from range from\n     * @param {number} context.range.to range to\n     * @param {object} callbacks 回调\n     * @param {function} callbacks.onProgress 下载数据回调\n     * @param {function} callbacks.onError 下载错误回调\n     * @param {function} callbacks.onEnd 下载结束回调\n     * @param {function} callbacks.onInfo 下载信息回调\n     * @param {object} config loader config\n     */\n\n\n    _createClass(FetchLoader, [{\n        key: 'open',\n        value: function open(context, callbacks, config) {\n            this._context = context;\n            this._config = config || this._config;\n            this._callbacks = callbacks;\n            this._stats = { trequest: performance.now(), retry: 0, loaded: 0 };\n            this._retryDelay = this._config.retryDelay;\n\n            this._requestAbort = false;\n            var reqHeaders = new Headers();\n            var r = context.range || { from: 0, to: -1 };\n            if (r.to !== -1) {\n                var queryResult = (0, _handleRange2.default)(r);\n                for (var i in queryResult) {\n                    reqHeaders.append(i, queryResult[i]);\n                }\n            }\n            this._params = {\n                method: 'GET',\n                headers: reqHeaders,\n                mode: 'cors',\n                cache: 'default',\n                referrerPolicy: 'no-referrer-when-downgrade'\n            };\n            if (config.credentials) {\n                this._params.credentials = 'include';\n            }\n            this._loadInternal();\n        }\n\n        /**\n         * pause video\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this._requestAbort = true;\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._callbacks = null;\n            this._requestAbort = true;\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n\n            this._stats.aborted = true;\n            this._stats.code = null;\n            this.pause();\n        }\n    }, {\n        key: '_loadInternal',\n        value: function _loadInternal() {\n            var _this = this;\n\n            var context = this._context;\n            var params = this._params;\n            var config = this._config;\n            var stats = this._stats;\n            stats.tfirst = 0;\n            stats.loaded = 0;\n            clearTimeout(this._retryTimeout);\n            if (config.timeout) {\n                this._requestTimeout = setTimeout(this._onTimeout.bind(this), config.timeout);\n            }\n            fetch(context.src, params).then(function (res) {\n                clearTimeout(_this._requestTimeout);\n                _this._stats.code = res.status;\n                if (res.ok) {\n                    stats.tfirst = Math.max(stats.trequest, performance.now());\n                    context.responseUrl = res.responseUrl;\n                    if (context.responseType === 'arraybuffer') {\n                        if (context.progress) {\n                            return _this._pump(res.body.getReader());\n                        }\n                        res.arrayBuffer().then(function (responseData) {\n                            stats.loaded = stats.total = responseData.byteLength;\n                            stats.tload = Math.max(stats.tfirst, performance.now());\n                            if (_this._callbacks) {\n                                _this._callbacks.onEnd(context, responseData, stats);\n                            }\n                        });\n                        return null;\n                    }\n                    res.text().then(function (responseData) {\n                        stats.loaded = stats.total = responseData.length;\n                        stats.tload = Math.max(stats.tfirst, performance.now());\n                        if (_this._callbacks) {\n                            _this._callbacks.onEnd(context, responseData, stats);\n                        }\n                    });\n                    return null;\n                }\n                var error = new Error(res.status + ' ' + res.statusText);\n                _this._onError(error);\n                return null;\n            }).catch(function (e) {\n                _log.Log.e(_this.tag, e);\n                _this._onError(e);\n            });\n        }\n    }, {\n        key: '_onError',\n        value: function _onError(e) {\n            var stats = this._stats;\n            var config = this._config;\n            clearTimeout(this._requestTimeout);\n            if (stats.retry >= config.maxRetry || !config.maxRetry) {\n                if (this._callbacks) {\n                    this._callbacks.onError(this._context, { code: stats.code, text: e.message });\n                }\n            } else {\n                this.destroy();\n                stats.retry++;\n                if (this._retryDelay) {\n                    this._retryTimeout = setTimeout(this._loadInternal.bind(this), this._retryDelay);\n                    this._retryDelay = Math.min(2 * this._retryDelay, config.maxRetryDelay);\n                } else {\n                    this._loadInternal();\n                }\n            }\n        }\n    }, {\n        key: '_onTimeout',\n        value: function _onTimeout() {\n            var e = new Error('timeout');\n            this._onError(e);\n        }\n\n        /**\n         * pump data\n         * @param {ReadableStreamReader} reader 读取数据\n         * @returns {Promise} promise\n         * @private\n         */\n\n    }, {\n        key: '_pump',\n        value: function _pump(reader) {\n            var _this2 = this;\n\n            var stats = this._stats;\n            // ReadableStreamReader\n            return reader.read().then(function (result) {\n                if (result.done) {\n                    stats.tload = Math.max(stats.tfirst, performance.now());\n                    stats.total = stats.loaded;\n                    if (_this2._callbacks) {\n                        _this2._callbacks.onEnd(_this2._context, null, stats);\n                    }\n                    _log.Log.v(_this2.tag, 'load end');\n                } else {\n                    if (_this2._requestAbort === true) {\n                        _this2._requestAbort = false;\n                        return reader.cancel();\n                    }\n                    var chunk = result.value.buffer;\n                    if (_this2._callbacks) {\n                        stats.loaded += chunk.byteLength;\n                        _this2._callbacks.onProgress(_this2._context, chunk, stats);\n                    }\n                    (function () {\n                        _this2._pump(reader);\n                    })();\n                }\n                return null;\n            }).catch(function (e) {\n                _log.Log.e(_this2.tag, e);\n                _this2._onError(e);\n            });\n        }\n    }]);\n\n    return FetchLoader;\n}();\n\nexports.default = FetchLoader;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/fetch.js?")},"./src/io/handleRange.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nexports.default = function (range) {\n    var headers = {};\n    var param = void 0;\n\n    if (range.to !== -1) {\n        param = "bytes=" + range.from.toString() + "-" + range.to.toString();\n    } else {\n        param = "bytes=" + range.from.toString() + "-";\n    }\n    headers.Range = param;\n    return headers;\n};\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/handleRange.js?')},"./src/io/io-loader.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 处理range的静态函数\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * author songguangyu\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * email 522963130@qq.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _fetch = __webpack_require__(/*! ./fetch */ \"./src/io/fetch.js\");\n\nvar _fetch2 = _interopRequireDefault(_fetch);\n\nvar _xhrRange = __webpack_require__(/*! ./xhr-range */ \"./src/io/xhr-range.js\");\n\nvar _xhrRange2 = _interopRequireDefault(_xhrRange);\n\nvar _xhrMozChunk = __webpack_require__(/*! ./xhr-moz-chunk */ \"./src/io/xhr-moz-chunk.js\");\n\nvar _xhrMozChunk2 = _interopRequireDefault(_xhrMozChunk);\n\nvar _multipartLoader = __webpack_require__(/*! ./multipart-loader */ \"./src/io/multipart-loader.js\");\n\nvar _multipartLoader2 = _interopRequireDefault(_multipartLoader);\n\nvar _reportTypes = __webpack_require__(/*! ../core/report-types */ \"./src/core/report-types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Ioloader 处理io的调用器 缓存多余数据\n * @class Ioloader\n * @param  {object} video config\n */\nvar Ioloader = function () {\n    function Ioloader(config) {\n        _classCallCheck(this, Ioloader);\n\n        this.tag = 'Ioloader';\n        this._loader = null;\n        this._config = config || {};\n        this._totalReceive = 0;\n        this._seekPoint = -1;\n        this._selectLoader();\n    }\n\n    /**\n     * 数据接收器\n     * @param {object} context context\n     * @param  {arrayBuffer} chunk data\n     */\n\n\n    _createClass(Ioloader, [{\n        key: 'onLoaderChunkArrival',\n        value: function onLoaderChunkArrival(context, chunk) {\n            this._totalReceive += chunk.byteLength;\n            if (this._callbacks) {\n                context.ts = Date.now();\n                if (this._seekPoint !== -1) {\n                    this._callbacks.onProgress(context, chunk, this._seekPoint);\n                    this._seekPoint = -1;\n                } else {\n                    this._callbacks.onProgress(context, chunk);\n                }\n            }\n            return;\n        }\n\n        /**\n         * 暂停\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this.paused = true;\n            this._loader.pause();\n        }\n\n        /**\n         * 打开连接\n         * @param {object} callbacks 回调\n         * @param {function} callbacks.onProgress 下载数据回调\n         * @param {function} callbacks.onError 下载错误回调\n         * @param {function} callbacks.onEnd 下载结束回调\n         * @param {function} callbacks.onInfo 下载信息回调\n         * @param {number} startBytes 开始位置\n         * @param {number} keyframePoint 关键帧时间\n         */\n\n    }, {\n        key: 'open',\n        value: function open(callbacks, startBytes, keyframePoint) {\n            this._callbacks = callbacks;\n            this._callbacks.onInfo({ type: 'loadInfo', data: { type: _reportTypes.REPORT_TYPES.LOADER_OPEN, ts: Date.now() } });\n            if (typeof keyframePoint === 'undefined') {\n                this._seekPoint = -1;\n            }\n\n            this._loaderCallbacks = Object.assign([], this._callbacks);\n            this._loaderCallbacks.onProgress = this.onLoaderChunkArrival.bind(this);\n            this._loader.open({\n                src: this._config.src,\n                range: { from: startBytes || 0, to: -1 },\n                progress: true,\n                responseType: 'arraybuffer'\n            }, this._loaderCallbacks, this._config);\n        }\n\n        /**\n         * 重新播放\n         */\n\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this.paused = false;\n            var bytes = this._totalReceive;\n            if (this._config.multipart) {\n                this._loader.resume();\n            } else {\n                this.open(this._callbacks, bytes);\n            }\n        }\n\n        /**\n         * seek\n         * @param {number} bytes seek位置\n         * @param {number} keyframePoint 关键帧时间\n         */\n\n    }, {\n        key: 'seek',\n        value: function seek(bytes, keyframePoint) {\n            this._loader.destroy();\n            this._seekPoint = keyframePoint;\n            this._totalReceive = bytes;\n            this.open(this._callbacks, bytes, keyframePoint);\n        }\n\n        /**\n         * destory\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._callbacks = null;\n            this._loaderCallbacks = null;\n            this.pause();\n        }\n\n        /**\n         * 自动选择io处理器\n         * @private\n         */\n\n    }, {\n        key: '_selectLoader',\n        value: function _selectLoader() {\n            var config = this._config;\n            var url = this._config.src;\n            if (this._config.multipart) {\n                this._loader = new _multipartLoader2.default(url, config, this.queryHandle);\n            } else if (_fetch2.default.isSupport()) {\n                this._loader = new _fetch2.default();\n            } else if (_xhrMozChunk2.default.isSupport()) {\n                this._loader = new _xhrMozChunk2.default();\n            } else if (_xhrRange2.default.isSupport()) {\n                this._loader = new _xhrRange2.default();\n            }\n        }\n    }]);\n\n    return Ioloader;\n}();\n\nexports.default = Ioloader;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/io-loader.js?")},"./src/io/multipart-loader.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _fetch = __webpack_require__(/*! ./fetch */ \"./src/io/fetch.js\");\n\nvar _fetch2 = _interopRequireDefault(_fetch);\n\nvar _xhrRange = __webpack_require__(/*! ./xhr-range */ \"./src/io/xhr-range.js\");\n\nvar _xhrRange2 = _interopRequireDefault(_xhrRange);\n\nvar _xhrMozChunk = __webpack_require__(/*! ./xhr-moz-chunk */ \"./src/io/xhr-moz-chunk.js\");\n\nvar _xhrMozChunk2 = _interopRequireDefault(_xhrMozChunk);\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _reportTypes = __webpack_require__(/*! ../core/report-types */ \"./src/core/report-types.js\");\n\nvar _downloadCache = __webpack_require__(/*! ./download-cache */ \"./src/io/download-cache.js\");\n\nvar _downloadCache2 = _interopRequireDefault(_downloadCache);\n\nvar _urlToolkit = __webpack_require__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// FLV文件头长度\nvar FLV_HEAD_LEN = 13;\n/**\n * 分片flv加载器\n * 将分片加载及seek逻辑封装\n * @class\n */\n\nvar MultiPartLoader = function (_Events) {\n    _inherits(MultiPartLoader, _Events);\n\n    function MultiPartLoader(manifest, config) {\n        _classCallCheck(this, MultiPartLoader);\n\n        var _this = _possibleConstructorReturn(this, (MultiPartLoader.__proto__ || Object.getPrototypeOf(MultiPartLoader)).call(this));\n\n        _this.tag = 'MultiPartLoader';\n        _this._manifest = manifest;\n        _this._config = config;\n\n        _this._loaderClass = null;\n        _this._loader = null;\n        _this._segmentIndex = 0;\n        _this._autoNext = true;\n        // 下载回调时是否删除flv文件头\n        _this._sliceFlvHead = false;\n        // 下载是否暂停\n        _this._paused = false;\n\n        // 记录是否首次调用open，协助判断是否为外部seek\n        _this._firstOpen = true;\n\n        _this._periodId = NaN;\n\n        _this._segmentLoadSize = 0;\n        _this._segmentLoadTime = 0;\n\n        _this._partContext = null;\n        _this._cache = new _downloadCache2.default();\n        _this._selectLoader();\n        return _this;\n    }\n\n    /**\n     * 开始加载\n     * @param {object} context src\n     * @param {object} callbacks 回调\n     * @param {number} keyframePoint 关键帧时间\n     */\n\n\n    _createClass(MultiPartLoader, [{\n        key: 'open',\n        value: function open(context, callbacks, keyframePoint) {\n            this._context = context;\n            this._callbacks = callbacks;\n            this._initLoaderCallback();\n            var segment = void 0;\n            this._autoNext = true;\n            // 是否是外部seek操作触发的open\n            this._seek = typeof keyframePoint !== 'undefined' && !this._firstOpen;\n            this._paused = false;\n            if (!this._seek) {\n                segment = this._nextSegment();\n            } else {\n                this._sliceFlvHead = this._seek;\n                if (this._firstOpen) {\n                    // 处理起播时间\n                    segment = this._seekByTime(this._config.startFromKeyframePoint || 0);\n                } else {\n                    segment = this._seekByBytes(this._context.range.from || 0);\n                }\n                this._nextSegment();\n            }\n            this._firstOpen = false;\n            this._cache.flush();\n            this._loadSegment(segment);\n        }\n\n        /**\n         * 暂停\n         * 不会调用子loader的pause，会暂停下个分片的自动加载\n         * @memberof MultiPartLoader\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            _log.Log.v(this.tag, 'pause');\n            this._autoNext = false;\n            this._paused = true;\n            this._downloadReport('cancel', 0);\n        }\n\n        /**\n         * 暂停恢复\n         */\n\n    }, {\n        key: 'resume',\n        value: function resume() {\n            this._paused = false;\n            this._autoNext = true;\n            if (this._cache && this._cache.unreadLen) {\n                var chunk = this._cache.getData(this._cache.unreadLen).buffer;\n                this._callbacks.onProgress(this._partContext, chunk);\n            }\n            var segment = this._nextSegment();\n            this._loadSegment(segment);\n        }\n\n        /**\n         * 销毁\n         * @memberof MultiPartLoader\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this._callbacks = null;\n            this._disposeLoader();\n            this.loader = null;\n        }\n    }, {\n        key: '_initLoaderCallback',\n        value: function _initLoaderCallback() {\n            var _this2 = this;\n\n            this._loaderCallbacks = {\n                onProgress: this._onLoaderChunkArrival.bind(this),\n                onEnd: function onEnd() {\n                    _this2._downloadReport('success', 200);\n                    _this2._sliceFlvHead = true;\n                    if (_this2._hasNextSegment()) {\n                        if (_this2._autoNext) {\n                            _this2._loadSegment(_this2._nextSegment());\n                        }\n                    } else {\n                        _this2._callbacks.onEnd();\n                    }\n                },\n                onError: function onError(context, handle) {\n                    _this2._downloadReport('fail', handle.status);\n                    _this2._callbacks.onError(context, handle);\n                }\n            };\n            this._loaderCallbacks.onInfo = this._callbacks.onInfo;\n        }\n\n        /**\n         * 选择loader\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_selectLoader',\n        value: function _selectLoader() {\n            if (_fetch2.default.isSupport()) {\n                this._loaderClass = _fetch2.default;\n            } else if (_xhrMozChunk2.default.isSupport()) {\n                this._loaderClass = _xhrMozChunk2.default;\n            } else if (_xhrRange2.default.isSupport()) {\n                this._loaderClass = _xhrRange2.default;\n            }\n        }\n\n        /**\n         * 适配io-loader，封装子loader\n         * @param {object} context context\n         * @param  {arrayBuffer} chunk data\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_onLoaderChunkArrival',\n        value: function _onLoaderChunkArrival(context, chunk) {\n            this._partContext = context;\n            this._segmentLoadSize += chunk.byteLength;\n            if (this._callbacks) {\n                if (this._sliceFlvHead) {\n                    chunk = chunk.slice(FLV_HEAD_LEN, chunk.byteLength);\n                    this._sliceFlvHead = false;\n                }\n                if (this._paused) {\n                    this._cache.pushData(chunk);\n                } else {\n                    this._callbacks.onProgress(context, chunk);\n                }\n            }\n        }\n\n        /**\n         * 加载分片\n         * @param {object} segment 分片信息描述\n         * @param {string} segment.url 分片url\n         * @param {string} segment.time 分片对应的时间戳\n         * @param {number} segment.periodId 段落id\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_loadSegment',\n        value: function _loadSegment(segment) {\n            this._disposeLoader(this._loader);\n            this._loader = null;\n            if (!segment) {\n                return;\n            }\n            this._segment = segment;\n            if (this._config.baseURL) {\n                this._segment.url = _urlToolkit2.default.buildAbsoluteURL(this._config.baseURL, this._segment.url, { alwaysNormalize: true });\n            }\n            this._segmentLoadSize = 0;\n            this._segmentLoadTime = Date.now();\n            this._loader = new this._loaderClass(segment.url, this._config);\n            if (!isNaN(this._periodId) && this._periodId !== segment.periodId && !this._seek) {\n                _log.Log.v(this.tag, 'DISCONTINUITY');\n                this._callbacks.onInfo({ type: 'discontinuity', data: segment.time });\n            }\n            this._periodId = segment.periodId;\n            if (this._seek) {\n                this._seek = false;\n            }\n            this._loader.open({ src: segment.url, responseType: 'arraybuffer', progress: true }, this._loaderCallbacks, this._config);\n        }\n\n        /**\n         * 释放当前加载器\n         * @param {*} loader 加载器\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_disposeLoader',\n        value: function _disposeLoader(loader) {\n            if (loader) {\n                loader.arrivalDataCallback = null;\n                loader.destroy();\n            }\n        }\n\n        /**\n         * 根据bytes定位segment\n         * @param {number} bytes bytes位置\n         * @returns {object} segment信息\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_seekByBytes',\n        value: function _seekByBytes(bytes) {\n            var i = 0;\n            for (i = 0; i < this._manifest.segments.length; i++) {\n                if (this._manifest.segments[i].fileposition > bytes) {\n                    break;\n                }\n            }\n            this._segmentIndex = Math.max(0, i - 1);\n            return this._manifest.segments[this._segmentIndex];\n        }\n\n        /**\n         * 根据时间定位segment\n         * @param {number} ms 时间，毫秒\n         * @returns {object} segment信息\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_seekByTime',\n        value: function _seekByTime(ms) {\n            var i = 0;\n            for (i = 0; i < this._manifest.segments.length; i++) {\n                if (this._manifest.segments[i].time > ms) {\n                    break;\n                }\n            }\n            this._segmentIndex = Math.max(0, i - 1);\n            return this._manifest.segments[this._segmentIndex];\n        }\n\n        /**\n         * 是否还有分片\n         * @return {boolean} 是否还有分片数据\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_hasNextSegment',\n        value: function _hasNextSegment() {\n            return this._manifest.segments && this._manifest.segments.length > this._segmentIndex;\n        }\n\n        /**\n         * 获取下一个segment信息\n         * @return {object} segment信息\n         * @memberof MultiPartLoader\n         * @private\n         */\n\n    }, {\n        key: '_nextSegment',\n        value: function _nextSegment() {\n            var segment = null;\n            if (this._manifest.segments && this._manifest.segments.length > this._segmentIndex) {\n                segment = this._manifest.segments[this._segmentIndex];\n                this._segmentIndex++;\n            }\n            return segment;\n        }\n\n        /**\n         * 上报下载数据\n         * @param {String} stat 状态success fail cancel\n         * @param {*} errorCode 错误码\n         */\n\n    }, {\n        key: '_downloadReport',\n        value: function _downloadReport(stat, errorCode) {\n            var segment = this._segment;\n            this._callbacks.onInfo({\n                type: 'loadInfo',\n                data: {\n                    type: _reportTypes.REPORT_TYPES.MP_SLICE_LOAD_STAT,\n                    url: segment.url,\n                    resourceType: this._manifest.type,\n                    downloaded: this._segmentLoadSize,\n                    filesize: segment.filesize,\n                    cost: Date.now() - this._segmentLoadTime,\n                    stat: stat,\n                    errorCode: errorCode || 0\n                }\n            });\n        }\n    }]);\n\n    return MultiPartLoader;\n}(_events2.default);\n\nexports.default = MultiPartLoader;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/multipart-loader.js?")},"./src/io/xhr-moz-chunk.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _handleRange = __webpack_require__(/*! ./handleRange */ \"./src/io/handleRange.js\");\n\nvar _handleRange2 = _interopRequireDefault(_handleRange);\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * XHR firfox 直播 点播\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * author songguangyu\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * email 522963130@qq.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n// import Log from 'helper/log';\n\n\n/**\n * MozChunkLoader\n * @class MozChunkLoader\n * @param {string} video url\n * @param  {object} range.from range.to\n */\nvar MozChunkLoader = function (_Events) {\n    _inherits(MozChunkLoader, _Events);\n\n    _createClass(MozChunkLoader, null, [{\n        key: 'isSupport',\n\n        /**\n         * broswer is support moz-chunk\n         * @returns {boolean} 是否支持\n         */\n        value: function isSupport() {\n            try {\n                var xhr = new XMLHttpRequest();\n                // Firefox 37- requires .open() to be called before setting responseType\n                xhr.open('GET', 'https://example.com', true);\n                xhr.responseType = 'moz-chunked-arraybuffer';\n                return xhr.responseType === 'moz-chunked-arraybuffer';\n            } catch (e) {\n                return false;\n            }\n        }\n    }]);\n\n    function MozChunkLoader() {\n        _classCallCheck(this, MozChunkLoader);\n\n        var _this = _possibleConstructorReturn(this, (MozChunkLoader.__proto__ || Object.getPrototypeOf(MozChunkLoader)).call(this));\n\n        _this.tag = 'mozChunkLoader';\n        _this._xhr = null;\n        _this._totalLength = null;\n        _this._chunkSizeKB = 393216;\n        _this._range = {};\n        _this._bytesStart = 0;\n\n        _this._config = {\n            timeout: 0,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0\n        };\n        return _this;\n    }\n\n    /**\n     * 开始加载\n     * @param {object} context context\n     * @param {string} context.src 下载地址\n     * @param {object} context.range 下载range\n     * @param {number} context.range.from range from\n     * @param {number} context.range.to range to\n     * @param {object} callbacks 回调\n     * @param {function} callbacks.onProgress 下载数据回调\n     * @param {function} callbacks.onError 下载错误回调\n     * @param {function} callbacks.onEnd 下载结束回调\n     * @param {function} callbacks.onInfo 下载信息回调\n     * @param {object} config loader config\n     */\n\n\n    _createClass(MozChunkLoader, [{\n        key: 'open',\n        value: function open(context, callbacks, config) {\n            this.src = context.src;\n            this._callbacks = callbacks;\n            this._context = context;\n            this._config = config || this._config;\n            this._stats = { trequest: performance.now(), retry: 0, loaded: 0 };\n            this._retryDelay = this._config.retryDelay;\n            this._loadInternal();\n        }\n\n        /**\n         * pause\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this.abort();\n        }\n        /**\n         * abort request\n         */\n\n    }, {\n        key: 'abort',\n        value: function abort() {\n            if (this._xhr) {\n                this._xhr.onreadystatechange = null;\n                this._xhr.onprogress = null;\n                this._xhr.onload = null;\n                this._xhr.onerror = null;\n                this._xhr.abort();\n                this._xhr = null;\n            }\n\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n        }\n\n        /**\n         * destroy xhr Object clean cache\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this._xhr) {\n                this.abort();\n            }\n            this._totalLength = null;\n            this._bytesStart = null;\n            this._range = {};\n        }\n    }, {\n        key: '_loadInternal',\n        value: function _loadInternal() {\n            var context = this._context;\n            var stats = this._stats;\n            var config = this._config;\n            stats.tfirst = 0;\n            stats.loaded = 0;\n            stats.aborted = false;\n            clearTimeout(this._retryTimeout);\n            var xhr = this._xhr = new XMLHttpRequest();\n            xhr.open('GET', this.src, true);\n            xhr.responseType = 'moz-chunked-arraybuffer';\n            xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n            xhr.onprogress = this._onProgress.bind(this);\n            xhr.onload = this._onLoadEnd.bind(this);\n            xhr.onerror = this._onError.bind(this);\n            if (xhr.responseType === 'moz-chunked-arraybuffer' && context.progress) {\n                var r = context.range || { from: 0, to: -1 };\n                this._range.from = r.from;\n                this._range.to = r.to;\n                var headers = (0, _handleRange2.default)(r).headers;\n                for (var i in headers) {\n                    xhr.setRequestHeader(i, headers[i]);\n                }\n            }\n            if (config.timeout) {\n                this._requestTimeout = setTimeout(this._onTimeout.bind(this), config.timeout);\n            }\n            xhr.send();\n        }\n\n        /**\n         * xhr onReadyStateChange\n         */\n\n    }, {\n        key: '_onReadyStateChange',\n        value: function _onReadyStateChange() {\n            var xhr = this._xhr;\n            var stats = this._stats;\n            if (stats.aborted) {\n                return;\n            }\n\n            if (xhr.readyState >= 2) {\n                if (stats.tfirst === 0) {\n                    stats.tfirst = Math.max(performance.now(), stats.trequest);\n                }\n                if (xhr.readyState === 4) {\n                    clearTimeout(this._requestTimeout);\n                    stats.tload = Math.max(stats.tfirst, performance.now());\n                    if (xhr.status < 200 || xhr.status > 299) {\n                        this._onError(new Error('xhr error'));\n                    }\n                }\n            }\n        }\n\n        /**\n         * xhr onProgress\n         * @param {*} e xhr回调数据\n         */\n\n    }, {\n        key: '_onProgress',\n        value: function _onProgress(e) {\n            var stats = this._stats;\n            if (e.total !== null && e.total !== 0) {\n                stats.total = e.total;\n            }\n\n            var chunk = e.target.response;\n            if (this._callbacks) {\n                this._callbacks.onProgress(this._context, chunk, stats);\n            }\n            this._bytesStart += chunk.byteLength;\n        }\n\n        /**\n         * xhr onLoadEnd\n         * @param {*} e xhr回调数据\n         */\n\n    }, {\n        key: '_onLoadEnd',\n        value: function _onLoadEnd(e) {\n            this._context.responseUrl = e.target.responseURL;\n            var stats = this._stats;\n            if (this._xhr.status === 200 && this._callbacks) {\n                this._callbacks.onEnd(this._context, null, stats);\n            }\n        }\n\n        /**\n         * xhr onXhrError\n         * @param {*} e xhr回调数据\n         * @private\n         */\n\n    }, {\n        key: '_onError',\n        value: function _onError(e) {\n            var stats = this._stats;\n            var config = this._config;\n            var xhr = this._xhr;\n            clearTimeout(this._requestTimeout);\n            if (stats.retry >= config.maxRetry || !config.maxRetry) {\n                if (this._callbacks) {\n                    this._callbacks.onError(this._context, { code: xhr.status, text: e.message || 'xhr error' });\n                }\n            } else {\n                this.destroy();\n                stats.retry++;\n                if (this._retryDelay) {\n                    this._retryTimeout = setTimeout(this._loadInternal.bind(this), this._retryDelay);\n                    this._retryDelay = Math.min(2 * this._retryDelay, config.maxRetryDelay);\n                } else {\n                    this._loadInternal();\n                }\n            }\n        }\n    }]);\n\n    return MozChunkLoader;\n}(_events2.default);\n\nexports.default = MozChunkLoader;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/xhr-moz-chunk.js?")},"./src/io/xhr-range.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR 点播\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * author songguangyu\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * email 522963130@qq.com\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _handleRange = __webpack_require__(/*! ./handleRange */ \"./src/io/handleRange.js\");\n\nvar _handleRange2 = _interopRequireDefault(_handleRange);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * RangeLoader\n * 依赖Content-Range\n * @class RangeLoader\n */\nvar RangeLoader = function () {\n    _createClass(RangeLoader, null, [{\n        key: 'isSupport',\n\n        /**\n         * broswer is support XMLHttpRequest\n         * @returns {boolean} 是否支持\n         */\n        value: function isSupport() {\n            try {\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET', 'https://example.com', true);\n                xhr.responseType = 'arraybuffer';\n                return xhr.responseType === 'arraybuffer';\n            } catch (e) {\n                return false;\n            }\n        }\n    }]);\n\n    function RangeLoader() {\n        _classCallCheck(this, RangeLoader);\n\n        this.tag = 'RangeLoader';\n        this._xhr = null;\n        this._chunkSizeKB = 524288;\n        this._range = {};\n        this._bytesStart = 0;\n        this._contentRangeRegExp = new RegExp('content-range: bytes [0-9]+-[0-9]+/([0-9]+)');\n        this._config = {\n            timeout: 0,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: 0\n        };\n    }\n\n    /**\n     * 开始加载\n     * @param {object} context context\n     * @param {string} context.src 下载地址\n     * @param {object} context.range 下载range\n     * @param {number} context.range.from range from\n     * @param {number} context.range.to range to\n     * @param {object} callbacks 回调\n     * @param {function} callbacks.onProgress 下载数据回调\n     * @param {function} callbacks.onError 下载错误回调\n     * @param {function} callbacks.onEnd 下载结束回调\n     * @param {function} callbacks.onInfo 下载信息回调\n     * @param {object} config 配置\n     */\n\n\n    _createClass(RangeLoader, [{\n        key: 'open',\n        value: function open(context, callbacks, config) {\n            this._context = context;\n            this._callbacks = callbacks;\n            this._config = config || this._config;\n            this._stats = { trequest: performance.now(), retry: 0, loaded: 0 };\n            this._retryDelay = this._config.retryDelay;\n            this._loadInternal();\n        }\n\n        /**\n         * pause\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            this.abort();\n        }\n        /**\n         * abort request\n         */\n\n    }, {\n        key: 'abort',\n        value: function abort() {\n            if (this._xhr) {\n                this._xhr.onreadystatechange = null;\n                this._xhr.onprogress = null;\n                this._xhr.onload = null;\n                this._xhr.onerror = null;\n                this._xhr.abort();\n                this._xhr = null;\n            }\n\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n\n            this._stats.aborted = true;\n        }\n\n        /**\n         * destroy xhr Object clean cache\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (this._xhr) {\n                this.abort();\n            }\n            this._bytesStart = null;\n            this._range = {};\n        }\n    }, {\n        key: '_loadInternal',\n        value: function _loadInternal() {\n            var context = this._context;\n            var stats = this._stats;\n            var config = this._config;\n            stats.tfirst = 0;\n            stats.loaded = 0;\n            stats.aborted = false;\n            clearTimeout(this._retryTimeout);\n            var xhr = this._xhr = new XMLHttpRequest();\n            xhr.open('GET', this._context.src, true);\n            xhr.withCredentials = !!config.credentials;\n            xhr.responseType = context.responseType || 'arraybuffer';\n            xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n            xhr.onprogress = this._onProgress.bind(this);\n            xhr.onload = this._onLoad.bind(this);\n            xhr.onerror = this._onError.bind(this);\n            if (xhr.responseType === 'arraybuffer' && context.progress) {\n                var r = context.range || { from: 0, to: -1 };\n                this._range.from = r.from;\n                if (r.to === -1) {\n                    if (stats.total) {\n                        r.to = Math.min(stats.total - 1, r.from + this._chunkSizeKB);\n                    } else {\n                        r.to = r.from + this._chunkSizeKB;\n                    }\n                }\n                this._bytesStart = r.from;\n                this._range.to = r.to;\n                var headers = (0, _handleRange2.default)(r);\n                for (var i in headers) {\n                    xhr.setRequestHeader(i, headers[i]);\n                }\n            }\n            if (config.timeout) {\n                this._requestTimeout = setTimeout(this._onTimeout.bind(this), config.timeout);\n            }\n            xhr.send();\n        }\n\n        /**\n         * xhr onReadyStateChange\n         * @private\n         */\n\n    }, {\n        key: '_onReadyStateChange',\n        value: function _onReadyStateChange() {\n            var xhr = this._xhr;\n            var stats = this._stats;\n            if (stats.aborted) {\n                return;\n            }\n            if (xhr.readyState >= 2) {\n                if (stats.tfirst === 0) {\n                    stats.tfirst = Math.max(performance.now(), stats.trequest);\n                }\n                if (xhr.readyState === 4) {\n                    clearTimeout(this._requestTimeout);\n                    stats.tload = Math.max(stats.tfirst, performance.now());\n                    if (xhr.status < 200 || xhr.status > 299) {\n                        this._onError(new Error('xhr error'));\n                    }\n                }\n            }\n        }\n    }, {\n        key: '_onTimeout',\n        value: function _onTimeout() {\n            this._onError(new Error('timeout'));\n        }\n    }, {\n        key: '_onError',\n        value: function _onError(e) {\n            var stats = this._stats;\n            var config = this._config;\n            var xhr = this._xhr;\n            clearTimeout(this._requestTimeout);\n            if (stats.retry >= config.maxRetry || !config.maxRetry) {\n                this._callbacks.onError(this._context, { code: xhr.status, text: e.message || 'xhr error' });\n            } else {\n                this.destroy();\n                stats.retry++;\n                if (this._retryDelay) {\n                    this._retryTimeout = setTimeout(this._loadInternal.bind(this), this._retryDelay);\n                    this._retryDelay = Math.min(2 * this._retryDelay, config.maxRetryDelay);\n                } else {\n                    this._loadInternal();\n                }\n            }\n        }\n\n        /**\n         * xhr onProgress\n         * @private\n         */\n\n    }, {\n        key: '_onProgress',\n        value: function _onProgress() {}\n\n        /**\n         * xhr onLoad\n         * @param {*} e xhr回调数据\n         * @private\n         */\n\n    }, {\n        key: '_onLoad',\n        value: function _onLoad(e) {\n            var chunk = e.target.response;\n            this._context.responseUrl = e.target.responseURL;\n            var stats = this._stats;\n            if (stats.aborted) {\n                return;\n            }\n            if (this._xhr.status === 206) {\n                if (this._callbacks) {\n                    stats.loaded += chunk.byteLength;\n                    this._callbacks.onProgress(this._context, chunk, stats);\n                }\n                var responseHeader = this._xhr.getAllResponseHeaders();\n                var matchResult = responseHeader.match(this._contentRangeRegExp);\n                if (matchResult && matchResult.length === 2) {\n                    stats.total = parseInt(matchResult[1], 10);\n                } else {\n                    this._onError(new Error('need response content-range'));\n                    return;\n                }\n                var nextFrom = this._range.from + chunk.byteLength;\n                if (stats.total && stats.total <= nextFrom + 1) {\n                    if (this._callbacks) {\n                        this._callbacks.onEnd(this._context, null, stats);\n                    }\n                } else {\n                    this._context.range.from = nextFrom;\n                    this._context.range.to = -1;\n                    this._loadInternal();\n                }\n            } else if (this._xhr.status === 200) {\n                stats.loaded = stats.total = chunk.byteLength || chunk.length;\n                if (this._callbacks) {\n                    this._callbacks.onEnd(this._context, chunk, stats);\n                }\n            }\n        }\n    }]);\n\n    return RangeLoader;\n}();\n\nexports.default = RangeLoader;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/io/xhr-range.js?")},"./src/player-logger.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _reportTypes = __webpack_require__(/*! ./core/report-types */ \"./src/core/report-types.js\");\n\nvar _urlParse = __webpack_require__(/*! url-parse */ \"./node_modules/url-parse/index.js\");\n\nvar _urlParse2 = _interopRequireDefault(_urlParse);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RECORD_NUM_LIMIT = 10;\nvar RECORD_DOWNLOAD_NUM_LIMIT = 200;\n/**\n * 播放日志处理。收集播放器事件，集中处理\n * @class\n */\n\nvar PlayerLogger = function (_Events) {\n    _inherits(PlayerLogger, _Events);\n\n    function PlayerLogger(version, video, config) {\n        _classCallCheck(this, PlayerLogger);\n\n        var _this = _possibleConstructorReturn(this, (PlayerLogger.__proto__ || Object.getPrototypeOf(PlayerLogger)).call(this));\n\n        _this._version = version;\n        _this._video = video;\n        _this.reset();\n        _this._data.manifest = config.src;\n        return _this;\n    }\n\n    /**\n     * 重置状态\n     * @memberof PlayerLogger\n     */\n\n\n    _createClass(PlayerLogger, [{\n        key: 'reset',\n        value: function reset() {\n            this.loaderOpenTs = 0;\n            this.receiveFirstPackageTs = 0;\n            this.firstDemuxFlvTs = 0;\n            this.firstSegmentTs = 0;\n            this.firstPlay = 0;\n            this._data = {\n                version: this._version,\n                records: [],\n                manifest: {},\n                buffered: 0,\n                loading: 0,\n                playing: 0,\n                totalLoaded: 0,\n                segmentLog: { video: [], audio: [] },\n                videoDataRate: 0,\n                audioDataRate: 0,\n                decodedFPS: 0,\n                droppedFPS: 0,\n                decodedFrames: 0,\n                droppedFrames: 0,\n                refresh: this.refresh.bind(this)\n            };\n        }\n\n        /**\n         * 记录事件及对应的数据\n         * @param {object} event 事件数据\n         * @param {string} type 事件类型\n         * @memberof PlayerLogger\n         */\n\n    }, {\n        key: 'record',\n        value: function record(event) {\n            event.ts = event.ts || Date.now();\n            // 目前只记录播放前数据\n            if (!this.firstPlay) {\n                this._processFirstPlayData(event);\n            }\n            this._processPlayDataUsually(event);\n        }\n    }, {\n        key: 'getLoadSpeed',\n        value: function getLoadSpeed() {\n            var record = this._data.records[this._data.records.length - 1];\n            if (record) {\n                var tsEnd = Date.now();\n                record.speed = 0;\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = record.log[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var l = _step.value;\n\n                        if (l.ts > tsEnd - 1000) {\n                            record.speed += l.byteLength;\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                return record.speed;\n            }\n            return 0;\n        }\n    }, {\n        key: 'setFPS',\n        value: function setFPS(fps) {\n            if (fps) {\n                this._data.decodedFPS = fps.decodedFPS;\n                this._data.droppedFPS = fps.droppedFPS;\n                this._data.droppedFrames = fps.droppedFrames;\n                this._data.decodedFrames = fps.decodedFrames;\n            }\n        }\n    }, {\n        key: 'refresh',\n\n\n        /**\n         * 刷新实时状态记录\n         */\n        value: function refresh() {\n            for (var i = 0; i < this._data.records.length; i++) {\n                if (this._data.records[i].statu === 'loading' || this._data.records[i].statu === 'waiting') {\n                    if (this._video.currentTime >= this._data.records[i].sync / 1000) {\n                        this._data.records[i].statu = 'playing';\n                        this._data.playing = i;\n                    }\n                }\n                if (this._data.records[i].statu === 'playing') {\n                    if (this._video.currentTime >= this._data.records[i].end / 1000) {\n                        this._data.records[i].statu = 'stoped';\n                    }\n                }\n            }\n\n            this.getLoadSpeed();\n            if (this._video.buffered.length) {\n                this._data.buffered = Math.floor((this._video.buffered.end(this._video.buffered.length - 1) - this._video.currentTime) * 1000);\n            }\n        }\n\n        /**\n         * 处理播放开始前的数据\n         * @param {object} event 事件数据\n         * @param {number} event.ts 事件触发时间戳\n         * @param {string} event.type 事件类型\n         * @memberof PlayerLogger\n         * @private\n         */\n\n    }, {\n        key: '_processFirstPlayData',\n        value: function _processFirstPlayData(event) {\n            switch (event.type) {\n                case _reportTypes.REPORT_TYPES.LOADER_CHUNK_ARRIVAL:\n                    if (!this.receiveFirstPackageTs) {\n                        this.receiveFirstPackageTs = event.ts;\n                        this._emitPerformance('receive-first-package-duration', this.receiveFirstPackageTs - this.loaderOpenTs);\n                    }\n                    break;\n                case _reportTypes.REPORT_TYPES.MEDIA_DEMUX_FLV:\n                    if (!this.firstDemuxFlvTs) {\n                        this.firstDemuxFlvTs = event.ts;\n                        this._emitPerformance('first-flv-package-duration', this.firstDemuxFlvTs - this.receiveFirstPackageTs);\n                    }\n                    break;\n                case _reportTypes.REPORT_TYPES.MEDIA_SEGMENT:\n                    if (!this.firstSegmentTs) {\n                        this.firstSegmentTs = event.ts;\n                        this._emitPerformance('first-flv-to-mp4', this.firstSegmentTs - this.firstDemuxFlvTs);\n                    }\n                    break;\n                case _reportTypes.REPORT_TYPES.LOADER_OPEN:\n                    if (!this.loaderOpenTs) {\n                        this.loaderOpenTs = event.ts;\n                        this._emitPerformance('first_loader_open_timestamp', this.loaderOpenTs);\n                    }\n                    break;\n                case _reportTypes.REPORT_TYPES.PLAYING:\n                case _reportTypes.REPORT_TYPES.CANPLAY:\n                case _reportTypes.REPORT_TYPES.TIMEUPDATE:\n                    if (!this.firstPlay) {\n                        this.firstPlay = event.ts;\n                        this._emitPerformance('first_video_frame_duration', this.firstPlay - this.firstSegmentTs);\n                    }\n                    break;\n            }\n        }\n    }, {\n        key: '_emitPerformance',\n        value: function _emitPerformance(type, value) {\n            this.emit('report', { type: 'performance', value: { type: type, value: value } });\n        }\n\n        /**\n         * 处理事件\n         * @param {object} event 事件\n         * @param {number} event.ts 事件触发时间戳\n         * @param {string} event.type 事件类型\n         * @memberof PlayerLogger\n         * @private\n         */\n\n    }, {\n        key: '_processPlayDataUsually',\n        value: function _processPlayDataUsually(event) {\n            switch (event.type) {\n                case _reportTypes.REPORT_TYPES.LOADER_CHUNK_ARRIVAL:\n                    this._loaderChunkArrival(event);\n                    break;\n                case _reportTypes.REPORT_TYPES.MP_SLICE_LOAD_STAT:\n                    this.emit('report', {\n                        type: 'multipartDownloaded',\n                        value: {\n                            url: event.url,\n                            domain: new _urlParse2.default(event.url).host,\n                            resource_type: event.resourceType,\n                            downloaded_size: event.downloaded,\n                            total_size: event.filesize,\n                            network_cost: event.cost,\n                            load_status: event.stat,\n                            error_code: event.errorCode\n                        }\n                    });\n                    break;\n                case _reportTypes.REPORT_TYPES.LIVE_ADAPTIVE_QOS_STAT:\n                    event.bitrate_playing = this.playingInfo ? this.playingInfo.bitrate : 0;\n                    event.bitrate_downloading = this.loadingInfo ? this.loadingInfo.bitrate : 0;\n                    this.emit('report', {\n                        type: 'liveStreamAdaptiveQosStat',\n                        value: event\n                    });\n                    break;\n                case _reportTypes.REPORT_TYPES.NEW_SOURCE:\n                    this._newSource(event.index || 0, 0, event.sync, event.url);\n                    break;\n                case _reportTypes.REPORT_TYPES.MEDIA_INFO:\n                    Object.assign(this._data.records[this._data.records.length - 1].mediaInfo, event.data);\n                    break;\n                case _reportTypes.REPORT_TYPES.MEDIA_SEGMENT:\n                    this._mediaSegment(event);\n                    break;\n            }\n        }\n    }, {\n        key: '_mediaSegment',\n        value: function _mediaSegment(event) {\n            if (event.keyFrame) {\n                this._data.records[this._data.records.length - 1].key++;\n            }\n            var log = this._data.segmentLog[event.segmentType];\n            if (!Array.isArray(log)) {\n                return;\n            }\n            log.push({ pts: event.pts, len: event.byteLength });\n\n            if (log.length > 100) {\n                log.shift();\n            }\n            var time = log[log.length - 1].pts - log[0].pts;\n            if (time > 0) {\n                var totalLen = 0;\n                for (var i = 0; i < log.length - 1; i++) {\n                    totalLen += log[i].len;\n                }\n                if (event.segmentType === 'video') {\n                    this._data.videoDataRate = parseInt(totalLen * 8 / time, 10);\n                } else if (event.segmentType === 'audio') {\n                    this._data.audioDataRate = parseInt(totalLen * 8 / time, 10);\n                }\n            }\n        }\n\n        /**\n         * 加载器收到数据\n         * @param {object} data 数据\n         * @memberof PlayerLogger\n         * @private\n         */\n\n    }, {\n        key: '_loaderChunkArrival',\n        value: function _loaderChunkArrival(data) {\n            this._data.totalLoaded += data.byteLength;\n            var record = this._data.records[this._data.records.length - 1];\n            if (record.log.length > RECORD_DOWNLOAD_NUM_LIMIT) {\n                record.log.pop();\n            }\n\n            record.log.unshift(data);\n            record.len += data.byteLength;\n\n            record.connectionTime = Date.now() - record.startTs;\n            record.avgSpeed = (record.len / record.connectionTime * 1000).toFixed(2);\n        }\n\n        /**\n         * 流切换记录\n         * @param {number} index 流index\n         * @param {number} playTime 当前播放时间，ms\n         * @param {number} sync 对齐位置，ms\n         * @param {string} url 流地址\n         * @memberof PlayerLogger\n         * @private\n         */\n\n    }, {\n        key: '_newSource',\n        value: function _newSource(index, playTime, sync, url) {\n            if (this._data.records.length) {\n                var record = this._data.records[this._data.records.length - 1];\n                record.endTs = Date.now();\n                record.statu = 'waiting';\n                record.end = sync;\n                record.url = url;\n            }\n            var rep = null;\n            if (this._data.manifest && this._data.manifest.hasOwnProperty('adaptationSet')) {\n                rep = this._data.manifest.adaptationSet.representation[index];\n            }\n            if (this._data.records.length > RECORD_NUM_LIMIT) {\n                this._data.playing--;\n                this._data.loading--;\n                this._data.records.shift();\n            }\n\n            this._data.records.push({\n                statu: 'loading',\n                mediaInfo: {},\n                key: 0,\n                log: [],\n                speed: 0,\n                avgSpeed: 0,\n                len: 0,\n                i: index,\n                bitrate: rep ? rep.bitrate : null,\n                id: rep ? rep.id : 0,\n                time: playTime,\n                sync: sync,\n                end: Number.MAX_SAFE_INTEGER,\n                startTs: Date.now(),\n                endTs: 0,\n                connectionTime: 0,\n                url: ''\n            });\n            this._data.loading = this._data.records.length - 1;\n        }\n    }, {\n        key: 'playingInfo',\n        get: function get() {\n            return this._data.records[this._data.playing];\n        }\n    }, {\n        key: 'loadingInfo',\n        get: function get() {\n            return this._data.records[this._data.loading];\n        }\n    }, {\n        key: 'data',\n        get: function get() {\n            return this._data;\n        }\n    }, {\n        key: 'dataJson',\n        get: function get() {\n            return JSON.stringify(this._data);\n        }\n    }]);\n\n    return PlayerLogger;\n}(_events2.default);\n\nexports.default = PlayerLogger;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/player-logger.js?")},"./src/remux/aac-helper.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n *  AAC helper\n */\n\nvar AAC = function () {\n    function AAC() {\n        _classCallCheck(this, AAC);\n    }\n\n    _createClass(AAC, null, [{\n        key: \'getSilentFrame\',\n        value: function getSilentFrame(codec, channelCount) {\n            switch (codec) {\n                case \'mp4a.40.2\':\n                    if (channelCount === 1) {\n                        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n                    } else if (channelCount === 2) {\n                        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n                    } else if (channelCount === 3) {\n                        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n                    } else if (channelCount === 4) {\n                        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n                    } else if (channelCount === 5) {\n                        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n                    } else if (channelCount === 6) {\n                        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n                    }\n\n                    break;\n                // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n                default:\n                    if (channelCount === 1) {\n                        // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n                        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n                    } else if (channelCount === 2) {\n                        // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n                        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n                    } else if (channelCount === 3) {\n                        // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n                        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n                    }\n                    break;\n            }\n            return null;\n        }\n    }]);\n\n    return AAC;\n}();\n\nexports.default = AAC;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/remux/aac-helper.js?')},"./src/remux/mp4-generator.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Generate MP4 Box\n */\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar MP4 = function () {\n    function MP4() {\n        _classCallCheck(this, MP4);\n    }\n\n    _createClass(MP4, null, [{\n        key: 'init',\n        value: function init() {\n            MP4.types = {\n                'avc1': [], // codingname\n                'avcC': [],\n                'btrt': [],\n                'dinf': [],\n                'dref': [],\n                'esds': [],\n                'ftyp': [],\n                'hdlr': [],\n                'mdat': [],\n                'mdhd': [],\n                'mdia': [],\n                'mfhd': [],\n                'minf': [],\n                'moof': [],\n                'moov': [],\n                'mp4a': [],\n                '.mp3': [],\n                'mvex': [],\n                'mvhd': [],\n                'pasp': [],\n                'sdtp': [],\n                'stbl': [],\n                'stco': [],\n                'stsc': [],\n                'stsd': [],\n                'stsz': [],\n                'stts': [],\n                'tfdt': [],\n                'tfhd': [],\n                'traf': [],\n                'trak': [],\n                'trun': [],\n                'trex': [],\n                'tkhd': [],\n                'vmhd': [],\n                'smhd': []\n            };\n\n            var i = void 0;\n            for (i in MP4.types) {\n                if (MP4.types.hasOwnProperty(i)) {\n                    MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n                }\n            }\n\n            var videoHdlr = new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n            ]);\n\n            var audioHdlr = new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, // pre_defined\n            0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n            ]);\n\n            MP4.HDLR_TYPES = {\n                video: videoHdlr,\n                audio: audioHdlr\n            };\n\n            var dref = new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x01, // entry_count\n            0x00, 0x00, 0x00, 0x0c, // entry_size\n            0x75, 0x72, 0x6c, 0x20, // 'url' type\n            0x00, // version 0\n            0x00, 0x00, 0x01 // entry_flags\n            ]);\n\n            var stco = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00 // entry_count\n            ]);\n\n            MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n            MP4.STSZ = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, // sample_size\n            0x00, 0x00, 0x00, 0x00 // sample_count\n            ]);\n            MP4.VMHD = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x01, // flags\n            0x00, 0x00, // graphicsmode\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n            ]);\n            MP4.SMHD = new Uint8Array([0x00, // version\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, // balance\n            0x00, 0x00 // reserved\n            ]);\n\n            MP4.STSD = new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x01]); // entry_count\n\n            var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n            var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n            var minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n            MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n            MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n        }\n    }, {\n        key: 'box',\n        value: function box(type) {\n            var payload = Array.prototype.slice.call(arguments, 1),\n                size = 8,\n                i = payload.length,\n                len = i,\n                result = void 0;\n            // calculate the total size we need to allocate\n            while (i--) {\n                size += payload[i].byteLength;\n            }\n\n            result = new Uint8Array(size);\n            result[0] = size >> 24 & 0xff;\n            result[1] = size >> 16 & 0xff;\n            result[2] = size >> 8 & 0xff;\n            result[3] = size & 0xff;\n            result.set(type, 4);\n            // copy the payload into the result\n            for (i = 0, size = 8; i < len; i++) {\n                // copy payload[i] array @ offset size\n                result.set(payload[i], size);\n                size += payload[i].byteLength;\n            }\n            return result;\n        }\n    }, {\n        key: 'hdlr',\n        value: function hdlr(type) {\n            return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n        }\n    }, {\n        key: 'mdat',\n        value: function mdat(data) {\n            return MP4.box(MP4.types.mdat, data);\n        }\n    }, {\n        key: 'mdhd',\n        value: function mdhd(timescale, duration) {\n            duration *= timescale;\n            var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n            var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n            return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n            timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale\n            upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4, // 'und' language (undetermined)\n            0x00, 0x00]));\n        }\n    }, {\n        key: 'mdia',\n        value: function mdia(track) {\n            return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n        }\n    }, {\n        key: 'mfhd',\n        value: function mfhd(sequenceNumber) {\n            return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n            sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n            ]));\n        }\n    }, {\n        key: 'minf',\n        value: function minf(track) {\n            if (track.type === 'audio') {\n                return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n            }\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n        }\n    }, {\n        key: 'moof',\n        value: function moof(sn, baseMediaDecodeTime, track) {\n            return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n        }\n        /**\n         * @param tracks... (optional) {array} the tracks associated with this movie\n         */\n\n    }, {\n        key: 'moov',\n        value: function moov(tracks) {\n            var i = tracks.length,\n                boxes = [];\n\n            while (i--) {\n                boxes[i] = MP4.trak(tracks[i]);\n            }\n\n            return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n        }\n    }, {\n        key: 'mvex',\n        value: function mvex(tracks) {\n            var i = tracks.length,\n                boxes = [];\n\n            while (i--) {\n                boxes[i] = MP4.trex(tracks[i]);\n            }\n\n            return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n        }\n    }, {\n        key: 'mvhd',\n        value: function mvhd(timescale, duration) {\n            duration *= timescale;\n            var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n            var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n            var bytes = new Uint8Array([0x01, // version 1\n            0x00, 0x00, 0x00, // flags\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n            timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale\n            upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00, // 1.0 rate\n            0x01, 0x00, // 1.0 volume\n            0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n            0xff, 0xff, 0xff, 0xff // next_track_ID\n            ]);\n            return MP4.box(MP4.types.mvhd, bytes);\n        }\n    }, {\n        key: 'sdtp',\n        value: function sdtp(track) {\n            var samples = track.samples || [],\n                bytes = new Uint8Array(4 + samples.length),\n                flags = void 0,\n                i = void 0;\n            // leave the full box header (4 bytes) all zero\n            // write the sample table\n            for (i = 0; i < samples.length; i++) {\n                flags = samples[i].flags;\n                bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n            }\n\n            return MP4.box(MP4.types.sdtp, bytes);\n        }\n    }, {\n        key: 'stbl',\n        value: function stbl(track) {\n            return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n        }\n    }, {\n        key: 'avc1',\n        value: function avc1(track) {\n            var sps = [],\n                pps = [],\n                i = void 0,\n                data = void 0,\n                len = void 0;\n            // assemble the SPSs\n\n            for (i = 0; i < track.sps.length; i++) {\n                data = track.sps[i];\n                len = data.byteLength;\n                sps.push(len >>> 8 & 0xff);\n                sps.push(len & 0xff);\n\n                // SPS\n                sps = sps.concat(Array.prototype.slice.call(data));\n            }\n\n            // assemble the PPSs\n            for (i = 0; i < track.pps.length; i++) {\n                data = track.pps[i];\n                len = data.byteLength;\n                pps.push(len >>> 8 & 0xff);\n                pps.push(len & 0xff);\n\n                pps = pps.concat(Array.prototype.slice.call(data));\n            }\n\n            var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version\n            sps[3], // profile\n            sps[4], // profile compat\n            sps[5], // level\n            0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n            0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n            ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n            ]).concat(pps))),\n                // \"PPS\"\n            width = track.width,\n                height = track.height,\n                hSpacing = track.pixelRatio[0],\n                vSpacing = track.pixelRatio[1];\n\n            return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // data_reference_index\n            0x00, 0x00, // pre_defined\n            0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n            width >> 8 & 0xff, width & 0xff, // width\n            height >> 8 & 0xff, height & 0xff, // height\n            0x00, 0x48, 0x00, 0x00, // horizresolution\n            0x00, 0x48, 0x00, 0x00, // vertresolution\n            0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // frame_count\n            0x12, 0x64, 0x61, 0x69, 0x6c, // dailymotion/hls.js\n            0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n            0x00, 0x18, // depth = 24\n            0x11, 0x11]), // pre_defined = -1\n            avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n            0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n            0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate\n            MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing\n            hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n            vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n        }\n    }, {\n        key: 'esds',\n        value: function esds(track) {\n            var configlen = track.config.length;\n            return new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n\n            0x03, // descriptor_type\n            0x17 + configlen, // length\n            0x00, 0x01, // es_id\n            0x00, // stream_priority\n\n            0x04, // descriptor_type\n            0x0f + configlen, // length\n            0x40, // codec : mpeg4_audio\n            0x15, // stream_type\n            0x00, 0x00, 0x00, // buffer_size\n            0x00, 0x00, 0x00, 0x00, // maxBitrate\n            0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n            0x05 // descriptor_type\n            ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n        }\n    }, {\n        key: 'mp4a',\n        value: function mp4a(track) {\n            var samplerate = track.samplerate;\n            return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // data_reference_index\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, track.channelCount, // channelcount\n            0x00, 0x10, // sampleSize:16bits\n            0x00, 0x00, 0x00, 0x00, // reserved2\n            samplerate >> 8 & 0xff, samplerate & 0xff, //\n            0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n        }\n    }, {\n        key: 'mp3',\n        value: function mp3(track) {\n            var samplerate = track.samplerate;\n            return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, 0x00, // reserved\n            0x00, 0x01, // data_reference_index\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, track.channelCount, // channelcount\n            0x00, 0x10, // sampleSize:16bits\n            0x00, 0x00, 0x00, 0x00, // reserved2\n            samplerate >> 8 & 0xff, samplerate & 0xff, //\n            0x00, 0x00]));\n        }\n    }, {\n        key: 'stsd',\n        value: function stsd(track) {\n            if (track.type === 'audio') {\n                if (!track.isAAC && track.codec === 'mp3') {\n                    return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n                }\n\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n            }\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n    }, {\n        key: 'tkhd',\n        value: function tkhd(track) {\n            var id = track.id,\n                duration = track.duration * track.timescale,\n                width = track.width,\n                height = track.height,\n                upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),\n                lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n            return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1\n            0x00, 0x00, 0x07, // flags\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n            id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n            0x00, 0x00, 0x00, 0x00, // reserved\n            upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n            0x00, 0x00, // layer\n            0x00, 0x00, // alternate_group\n            0x00, 0x00, // non-audio track volume\n            0x00, 0x00, // reserved\n            0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n            width >> 8 & 0xff, width & 0xff, 0x00, 0x00, // width\n            height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n            ]));\n        }\n    }, {\n        key: 'traf',\n        value: function traf(track, baseMediaDecodeTime) {\n            var sampleDependencyTable = MP4.sdtp(track),\n                id = track.id,\n                upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),\n                lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n            return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n            ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1\n            0x00, 0x00, 0x00, // flags\n            upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 // tfhd\n            + 20 // tfdt\n            + 8 // traf header\n            + 16 // mfhd\n            + 8 // moof header\n            + 8), // mdat header\n            sampleDependencyTable);\n        }\n\n        /**\n         * Generate a track box.\n         * @param track {object} a track definition\n         * @return {Uint8Array} the track box\n         */\n\n    }, {\n        key: 'trak',\n        value: function trak(track) {\n            // TODO:\n            // track.duration = track.duration || 0xffffffff;\n            return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n        }\n    }, {\n        key: 'trex',\n        value: function trex(track) {\n            var id = track.id;\n            return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0\n            0x00, 0x00, 0x00, // flags\n            id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n            0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n            0x00, 0x00, 0x00, 0x00, // default_sample_duration\n            0x00, 0x00, 0x00, 0x00, // default_sample_size\n            0x00, 0x01, 0x00, 0x01 // default_sample_flags\n            ]));\n        }\n    }, {\n        key: 'trun',\n        value: function trun(track, offset) {\n            var samples = track.samples || [],\n                len = samples.length,\n                arraylen = 12 + 16 * len,\n                array = new Uint8Array(arraylen),\n                i = void 0,\n                sample = void 0,\n                duration = void 0,\n                size = void 0,\n                flags = void 0,\n                cts = void 0;\n            offset += 8 + arraylen;\n            array.set([0x00, // version 0\n            0x00, 0x0f, 0x01, // flags\n            len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff, // sample_count\n            offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n            ], 0);\n            for (i = 0; i < len; i++) {\n                sample = samples[i];\n                duration = sample.duration;\n                size = sample.size;\n                flags = sample.flags;\n                cts = sample.cts;\n                array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff, // sample_duration\n                size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff, // sample_size\n                flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f, // sample_flags\n                cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n                ], 12 + 16 * i);\n            }\n            return MP4.box(MP4.types.trun, array);\n        }\n    }, {\n        key: 'initSegment',\n        value: function initSegment(tracks) {\n            if (!MP4.types) {\n                MP4.init();\n            }\n\n            var movie = MP4.moov(tracks),\n                result = void 0;\n            result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n            result.set(MP4.FTYP);\n            result.set(movie, MP4.FTYP.byteLength);\n            return result;\n        }\n    }]);\n\n    return MP4;\n}();\n\nexports.default = MP4;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/remux/mp4-generator.js?")},"./src/remux/mp4-remuxer.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _aacHelper = __webpack_require__(/*! ./aac-helper */ \"./src/remux/aac-helper.js\");\n\nvar _aacHelper2 = _interopRequireDefault(_aacHelper);\n\nvar _mp4Generator = __webpack_require__(/*! ./mp4-generator */ \"./src/remux/mp4-generator.js\");\n\nvar _mp4Generator2 = _interopRequireDefault(_mp4Generator);\n\nvar _kernelEvents = __webpack_require__(/*! ../core/kernel-events */ \"./src/core/kernel-events.js\");\n\nvar _kernelEvents2 = _interopRequireDefault(_kernelEvents);\n\nvar _kernelErrors = __webpack_require__(/*! ../core/kernel-errors */ \"./src/core/kernel-errors.js\");\n\nvar _log = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.js\");\n\nvar _browser = __webpack_require__(/*! ../utils/browser */ \"./src/utils/browser.js\");\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// 10 seconds\nvar MAX_SILENT_FRAME_DURATION = 10 * 1000;\n\nvar MP4Remuxer = function () {\n    function MP4Remuxer(observer, config, typeSupported, vendor) {\n        _classCallCheck(this, MP4Remuxer);\n\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        var userAgent = navigator.userAgent;\n        this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');\n        this.ISGenerated = false;\n        // 计算平均sampleDuration\n        this._resetVideoTime();\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR = _browser2.default.chrome && (_browser2.default.version.major < 50 || _browser2.default.version.major === 50 && _browser2.default.version.build < 2661) ? true : false;\n    }\n\n    _createClass(MP4Remuxer, [{\n        key: 'destroy',\n        value: function destroy() {}\n    }, {\n        key: 'resetTimeStamp',\n        value: function resetTimeStamp(defaultTimeStamp) {\n            this._initPTS = this._initDTS = defaultTimeStamp;\n            this._resetVideoTime();\n        }\n    }, {\n        key: 'resetInitSegment',\n        value: function resetInitSegment() {\n            this.ISGenerated = false;\n        }\n    }, {\n        key: 'remux',\n        value: function remux(audioTrack, videoTrack, timeOffset, contiguous, accurateTimeOffset) {\n            // generate Init Segment if needed\n            if (!this.ISGenerated) {\n                this.generateIS(audioTrack, videoTrack, timeOffset);\n            }\n\n            if (this.ISGenerated) {\n                var nbAudioSamples = audioTrack.samples.length;\n                var nbVideoSamples = videoTrack.samples.length;\n                var audioTimeOffset = 0;\n                var videoTimeOffset = 0;\n                if (nbAudioSamples && nbVideoSamples) {\n                    // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n                    // if first audio DTS is not aligned with first video DTS then we need to take that into account\n                    // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n                    // drift between audio and video streams\n                    var audiovideoDeltaDts = (audioTrack.samples[0].dts - videoTrack.samples[0].dts) / videoTrack.inputTimeScale;\n                    audioTimeOffset += Math.max(0, audiovideoDeltaDts);\n                    videoTimeOffset += Math.max(0, -audiovideoDeltaDts);\n                }\n                // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is\n                // calculated in remuxAudio.\n                // Log.v('nb AAC samples:' + audioTrack.samples.length);\n                if (nbAudioSamples) {\n                    // if initSegment was generated without video samples, regenerate it again\n                    if (!audioTrack.timescale) {\n                        _log.Log.w('regenerate InitSegment as audio detected');\n                        this.generateIS(audioTrack, videoTrack, timeOffset);\n                    }\n                    var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);\n                    // Log.v('nb AVC samples:' + videoTrack.samples.length);\n                    if (nbVideoSamples) {\n                        var audioTrackLength = void 0;\n                        if (audioData) {\n                            audioTrackLength = audioData.endPTS - audioData.startPTS;\n                        }\n\n                        // if initSegment was generated without video samples, regenerate it again\n                        if (!videoTrack.timescale) {\n                            _log.Log.w('regenerate InitSegment as video detected');\n                            this.generateIS(audioTrack, videoTrack, timeOffset);\n                        }\n                        this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);\n                    }\n                } else {\n                    // Log.v('nb AVC samples:' + videoTrack.samples.length);\n                    if (nbVideoSamples) {\n                        var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);\n                        if (videoData && audioTrack.codec) {\n                            this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);\n                        }\n                    }\n                }\n            }\n\n            // notify end of parsing\n            this.observer.trigger(_kernelEvents2.default.HLS_FRAG_PARSED);\n        }\n    }, {\n        key: 'generateIS',\n        value: function generateIS(audioTrack, videoTrack, timeOffset) {\n            var observer = this.observer,\n                audioSamples = audioTrack.samples,\n                videoSamples = videoTrack.samples,\n                typeSupported = this.typeSupported,\n                container = 'audio/mp4',\n                tracks = {},\n                data = { tracks: tracks },\n                computePTSDTS = this._initPTS === undefined,\n                initPTS = void 0,\n                initDTS = void 0;\n\n            if (computePTSDTS) {\n                initPTS = initDTS = Infinity;\n            }\n\n            if (audioTrack.config && audioSamples.length) {\n                // let's use audio sampling rate as MP4 time scale.\n                // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n                // using audio sampling rate here helps having an integer MP4 frame duration\n                // this avoids potential rounding issue and AV sync issue\n                audioTrack.timescale = audioTrack.samplerate;\n                _log.Log.v('audio sampling rate : ' + audioTrack.samplerate);\n                if (!audioTrack.isAAC) {\n                    if (typeSupported.mpeg) {\n                        // Chrome and Safari\n                        container = 'audio/mpeg';\n                        audioTrack.codec = '';\n                    } else if (typeSupported.mp3) {\n                        // Firefox\n                        audioTrack.codec = 'mp3';\n                    }\n                }\n                tracks.audio = {\n                    container: container,\n                    codec: audioTrack.codec,\n                    initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),\n                    metadata: {\n                        channelCount: audioTrack.channelCount\n                    }\n                };\n                if (computePTSDTS) {\n                    // remember first PTS of this demuxing context. for audio, PTS = DTS\n                    initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;\n                }\n            }\n\n            if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n                // let's use input time scale as MP4 video timescale\n                // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n                var inputTimeScale = videoTrack.inputTimeScale;\n                videoTrack.timescale = inputTimeScale;\n                tracks.video = {\n                    container: 'video/mp4',\n                    codec: videoTrack.codec,\n                    initSegment: _mp4Generator2.default.initSegment([videoTrack]),\n                    metadata: {\n                        width: videoTrack.width,\n                        height: videoTrack.height,\n                        fps: videoTrack.fps\n                    }\n                };\n                if (computePTSDTS) {\n                    initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);\n                    initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);\n                    this.observer.trigger(_kernelEvents2.default.INIT_PTS_FOUND, { initPTS: initPTS });\n                }\n            }\n\n            if (Object.keys(tracks).length) {\n                observer.trigger(_kernelEvents2.default.PARSING_INIT_SEGMENT, data);\n                this.ISGenerated = true;\n                if (computePTSDTS) {\n                    this._initPTS = initPTS;\n                    this._initDTS = initDTS;\n                }\n            } else {\n                observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MEDIA_ERROR,\n                    details: _kernelErrors.ErrorDetails.FRAG_PARSING_ERROR,\n                    fatal: false,\n                    reason: 'no audio/video samples found'\n                });\n            }\n        }\n    }, {\n        key: 'remuxVideo',\n        value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {\n            var offset = 8,\n                timeScale = track.timescale,\n                mp4SampleDuration = void 0,\n                mdat = void 0,\n                moof = void 0,\n                firstPTS = void 0,\n                firstDTS = void 0,\n                nextDTS = void 0,\n                lastPTS = void 0,\n                lastDTS = void 0,\n                inputSamples = track.samples,\n                outputSamples = [],\n                nbSamples = inputSamples.length,\n                ptsNormalize = this._PTSNormalize,\n                initDTS = this._initDTS,\n                streamDTS = inputSamples[0].dts / timeScale,\n                key = inputSamples[0].key,\n                time = this._videoTime;\n            // for (let i = 0; i < track.samples.length; i++) {\n            //   let avcSample = track.samples[i];\n            //   let units = avcSample.units;\n            //   let unitsString = '';\n            //   for (let j = 0; j < units.length ; j++) {\n            //     unitsString += units[j].type + ',';\n            //     if (units[j].data.length < 500) {\n            //       unitsString += Hex.hexDump(units[j].data);\n            //     }\n            //   }\n            //   Log.v(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);\n            // }\n\n            // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n            var nextAvcDts = this.nextAvcDts;\n\n            var isSafari = this.isSafari;\n\n            if (nbSamples === 0) {\n                return;\n            }\n\n            // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive\n            if (isSafari) {\n                // also consider consecutive fragments as being contiguous (even if a level switch occurs),\n                // for sake of clarity:\n                // consecutive fragments are frags with\n                //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n                //  - less than 200 ms PTS gaps (timeScale/5)\n                contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initDTS) < timeScale / 5);\n            }\n\n            if (!contiguous) {\n                // if not contiguous, let's use target timeOffset\n                nextAvcDts = timeOffset * timeScale;\n            }\n\n            // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n            // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n            inputSamples.forEach(function (sample) {\n                sample.pts = ptsNormalize(sample.pts - initDTS, nextAvcDts);\n                sample.dts = ptsNormalize(sample.dts - initDTS, nextAvcDts);\n            });\n\n            // sort video samples by DTS then PTS then demux id order\n            inputSamples.sort(function (a, b) {\n                var deltadts = a.dts - b.dts;\n                var deltapts = a.pts - b.pts;\n                return deltadts || deltapts || a.id - b.id;\n            });\n\n            // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)\n            var PTSDTSshift = inputSamples.reduce(function (prev, curr) {\n                return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);\n            }, 0);\n            if (PTSDTSshift < 0) {\n                _log.Log.w('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');\n                for (var i = 0; i < inputSamples.length; i++) {\n                    inputSamples[i].dts += PTSDTSshift;\n                }\n            }\n\n            // compute first DTS and last DTS, normalize them against reference value\n            var sample = inputSamples[0];\n            firstDTS = Math.max(sample.dts, 0);\n            firstPTS = Math.max(sample.pts, 0);\n\n            // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)\n            var delta = Math.round((firstDTS - nextAvcDts) / 90);\n            // if fragment are contiguous, detect hole/overlapping between fragments\n            if (contiguous) {\n                if (delta) {\n                    if (delta > 1) {\n                        _log.Log.v('AVC:' + delta + ' ms hole between fragments detected,filling it');\n                    } else if (delta < -1) {\n                        _log.Log.v('AVC:' + -delta + ' ms overlapping between fragments detected');\n                    }\n\n                    firstPTS = Math.max(firstPTS - (firstDTS - nextAvcDts), nextAvcDts);\n                    // remove hole/gap : set DTS to next expected DTS\n                    firstDTS = nextAvcDts;\n                    inputSamples[0].dts = firstDTS;\n                    // offset PTS as well, ensure that PTS is smaller or equal than new DTS\n                    inputSamples[0].pts = firstPTS;\n                    _log.Log.v('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');\n                }\n            }\n            nextDTS = firstDTS;\n\n            // compute lastPTS/lastDTS\n            sample = inputSamples[inputSamples.length - 1];\n            lastDTS = Math.max(sample.dts, 0);\n            lastPTS = Math.max(sample.pts, 0, lastDTS);\n\n            // on Safari let's signal the same sample duration for all samples\n            // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n            // set this constant duration as being the avg delta between consecutive DTS.\n            if (isSafari) {\n                mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));\n            }\n\n            var nbNalu = 0,\n                naluLen = 0;\n            for (var _i = 0; _i < nbSamples; _i++) {\n                // compute total/avc sample length and nb of NAL units\n                var _sample = inputSamples[_i],\n                    units = _sample.units,\n                    nbUnits = units.length,\n                    sampleLen = 0;\n                for (var j = 0; j < nbUnits; j++) {\n                    sampleLen += units[j].data.length;\n                }\n\n                naluLen += sampleLen;\n                nbNalu += nbUnits;\n                _sample.length = sampleLen;\n\n                // normalize PTS/DTS\n                if (isSafari) {\n                    // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples\n                    _sample.dts = firstDTS + _i * mp4SampleDuration;\n                } else {\n                    // ensure sample monotonic DTS\n                    _sample.dts = Math.max(_sample.dts, firstDTS);\n                }\n                // ensure that computed value is greater or equal than sample DTS\n                _sample.pts = Math.max(_sample.pts, _sample.dts);\n            }\n\n            /* concatenate the video data and construct the mdat in place\n            (need 8 more bytes to fill length and mpdat type) */\n            var mdatSize = naluLen + 4 * nbNalu + 8;\n            try {\n                mdat = new Uint8Array(mdatSize);\n            } catch (err) {\n                this.observer.trigger(_kernelEvents2.default.ERROR, {\n                    type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                    details: _kernelErrors.ErrorDetails.REMUX_ALLOC_ERROR,\n                    fatal: false,\n                    bytes: mdatSize,\n                    reason: 'fail allocating video mdat ' + mdatSize\n                });\n                return;\n            }\n            var view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(_mp4Generator2.default.types.mdat, 4);\n\n            for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n                var avcSample = inputSamples[_i2],\n                    avcSampleUnits = avcSample.units,\n                    mp4SampleLength = 0,\n                    compositionTimeOffset = void 0;\n                // convert NALU bitstream to MP4 format (prepend NALU with size field)\n                for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n                    var unit = avcSampleUnits[_j],\n                        unitData = unit.data,\n                        unitDataLen = unit.data.byteLength;\n                    view.setUint32(offset, unitDataLen);\n                    offset += 4;\n                    mdat.set(unitData, offset);\n                    offset += unitDataLen;\n                    mp4SampleLength += 4 + unitDataLen;\n                }\n\n                if (!isSafari) {\n                    // expected sample duration is the Decoding Timestamp diff of consecutive samples\n                    if (_i2 < nbSamples - 1) {\n                        mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;\n                    } else {\n                        var config = this.config,\n                            lastFrameDuration = time.sampleDuration || avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;\n                        if (config.stretchShortVideoTrack) {\n                            // In some cases, a segment's audio track duration may exceed the video track duration.\n                            // Since we've already remuxed audio, and we know how long the audio track is, we look to\n                            // see if the delta to the next segment is longer than maxBufferHole.\n                            // If so, playback would potentially get stuck, so we artificially inflate\n                            // the duration of the last frame to minimize any potential gap between segments.\n                            var maxBufferHole = config.maxBufferHole,\n                                gapTolerance = Math.floor(maxBufferHole * timeScale),\n                                deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n                            if (deltaToFrameEnd > gapTolerance) {\n                                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                                if (mp4SampleDuration < 0) {\n                                    mp4SampleDuration = lastFrameDuration;\n                                }\n\n                                _log.Log.v('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');\n                            } else {\n                                mp4SampleDuration = lastFrameDuration;\n                            }\n                        } else {\n                            mp4SampleDuration = lastFrameDuration;\n                        }\n                    }\n                    compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n                } else {\n                    compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));\n                }\n\n                // 无法根据多个sample计算mp4SampleDuration时，利用fps和平均duration计算当前duration\n                if (!mp4SampleDuration && inputSamples.length < 2) {\n                    var fix = 0;\n                    if (contiguous) {\n                        fix = delta * 90;\n                    }\n                    mp4SampleDuration = Math.max((time.sampleDuration || track.refSampleDuration) - fix, 90);\n                }\n                // console.log('mp4SampleDuration', mp4SampleDuration);\n                outputSamples.push({\n                    size: mp4SampleLength,\n                    // constant duration\n                    duration: mp4SampleDuration,\n                    cts: compositionTimeOffset,\n                    flags: {\n                        isLeading: 0,\n                        isDependedOn: 0,\n                        hasRedundancy: 0,\n                        degradPrio: 0,\n                        dependsOn: avcSample.key ? 2 : 1,\n                        isNonSync: avcSample.key ? 0 : 1\n                    }\n                });\n            }\n            // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n\n            this.nextAvcDts = lastDTS + mp4SampleDuration;\n            var dropped = track.dropped;\n            track.len = 0;\n            track.nbNalu = 0;\n            track.dropped = 0;\n            if (outputSamples.length && this._forceFirstIDR) {\n                var flags = outputSamples[0].flags;\n                // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue\n                // https://code.google.com/p/chromium/issues/detail?id=229412\n                flags.dependsOn = 2;\n                flags.isNonSync = 0;\n            }\n            track.samples = outputSamples;\n            moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);\n            track.samples = [];\n\n            var data = {\n                data1: moof,\n                data2: mdat,\n                startPTS: firstPTS / timeScale,\n                endPTS: (lastPTS + mp4SampleDuration) / timeScale,\n                startDTS: firstDTS / timeScale,\n                endDTS: this.nextAvcDts / timeScale,\n                type: 'video',\n                hasAudio: false,\n                hasVideo: true,\n                nb: outputSamples.length,\n                dropped: dropped,\n                streamDTS: streamDTS,\n                key: key\n            };\n            data.endStreamDts = data.endDTS - data.startDTS + data.streamDTS;\n            this.observer.trigger(_kernelEvents2.default.PARSING_DATA, data);\n\n            // 记录数据计算平均duration\n            if (time.nbSamples === 0) {\n                time.firstDTS = firstDTS;\n            }\n            time.nbSamples += nbSamples;\n            time.sampleDuration = (this.nextAvcDts - time.firstDTS) / time.nbSamples;\n            time.endDts = this.nextAvcDts;\n\n            return data;\n        }\n    }, {\n        key: 'remuxAudio',\n        value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {\n            if (!track.samples.length) {\n                return;\n            }\n            var inputTimeScale = track.inputTimeScale,\n                mp4timeScale = track.timescale,\n                scaleFactor = inputTimeScale / mp4timeScale,\n                mp4SampleDuration = track.isAAC ? 1024 : 1152,\n                inputSampleDuration = mp4SampleDuration * scaleFactor,\n                ptsNormalize = this._PTSNormalize,\n                initDTS = this._initDTS,\n                rawMPEG = !track.isAAC && this.typeSupported.mpeg;\n            var offset = void 0,\n                mp4Sample = void 0,\n                fillFrame = void 0,\n                mdat = void 0,\n                moof = void 0,\n                firstPTS = void 0,\n                lastPTS = void 0,\n                inputSamples = track.samples,\n                outputSamples = [],\n                nextAudioPts = this.nextAudioPts,\n                streamDTS = inputSamples[0].dts / inputTimeScale;\n\n            // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n            // for sake of clarity:\n            // consecutive fragments are frags with\n            //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n            //  - less than 20 audio frames distance\n            // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n            // this helps ensuring audio continuity\n            // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n            contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);\n\n            // compute normalized PTS\n            inputSamples.forEach(function (sample) {\n                sample.pts = sample.dts = ptsNormalize(sample.pts - initDTS, timeOffset * inputTimeScale);\n            });\n\n            // filter out sample with negative PTS that are not playable anyway\n            // if we don't remove these negative samples, they will shift all audio samples forward.\n            // leading to audio overlap between current / next fragment\n            inputSamples = inputSamples.filter(function (sample) {\n                return sample.pts >= 0;\n            });\n\n            // in case all samples have negative PTS, and have been filtered out, return now\n            if (inputSamples.length === 0) {\n                return;\n            }\n            if (!contiguous) {\n                if (!accurateTimeOffset) {\n                    // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n                    nextAudioPts = inputSamples[0].pts;\n                } else {\n                    // if timeOffset is accurate, let's use it as predicted next audio PTS\n                    nextAudioPts = timeOffset * inputTimeScale;\n                }\n            }\n            // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n            // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n            // In an effort to prevent this from happening, we inject frames here where there are gaps.\n            // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n            // frame.\n            if (track.isAAC) {\n                var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n                for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {\n                    // First, let's see how far off this frame is from where we expect it to be\n                    var sample = inputSamples[i],\n                        delta;\n                    var pts = sample.pts;\n                    delta = pts - nextPts;\n\n                    var duration = Math.abs(1000 * delta / inputTimeScale);\n\n                    // If we're overlapping by more than a duration, drop this sample\n                    if (delta <= -maxAudioFramesDrift * inputSampleDuration) {\n                        _log.Log.w('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');\n                        inputSamples.splice(i, 1);\n                        track.len -= sample.unit.length;\n                        // Don't touch nextPtsNorm or i\n                    } // eslint-disable-line brace-style\n\n                    // Insert missing frames if:\n                    // 1: We're more than maxAudioFramesDrift frame away\n                    // 2: Not more than MAX_SILENT_FRAME_DURATION away\n                    // 3: currentTime (aka nextPtsNorm) is not 0\n                    else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {\n                            var missing = Math.round(delta / inputSampleDuration);\n                            _log.Log.w('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');\n                            for (var j = 0; j < missing; j++) {\n                                var newStamp = Math.max(nextPts, 0);\n                                fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                                if (!fillFrame) {\n                                    _log.Log.v('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                                    fillFrame = sample.unit.subarray();\n                                }\n                                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });\n                                track.len += fillFrame.length;\n                                nextPts += inputSampleDuration;\n                                i++;\n                            }\n\n                            // Adjust sample to next expected pts\n                            sample.pts = sample.dts = nextPts;\n                            nextPts += inputSampleDuration;\n                            i++;\n                        } else {\n                            // Otherwise, just adjust pts\n                            if (Math.abs(delta) > 0.1 * inputSampleDuration) {\n                                // Log.v(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);\n                            }\n                            sample.pts = sample.dts = nextPts;\n                            nextPts += inputSampleDuration;\n                            i++;\n                        }\n                }\n            }\n\n            for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n                var audioSample = inputSamples[_j2];\n                var unit = audioSample.unit;\n                var _pts = audioSample.pts;\n                // console.log('audioSample.pts', audioSample);\n                // Log.v(`Audio/PTS:${Math.round(pts/90)}`);\n                // if not first sample\n                if (lastPTS !== undefined) {\n                    mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);\n                } else {\n                    var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),\n                        numMissingFrames = 0;\n                    // if fragment are contiguous, detect hole/overlapping between fragments\n                    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n                    if (contiguous && track.isAAC) {\n                        // log delta\n                        if (_delta) {\n                            if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {\n                                numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);\n                                _log.Log.v(_delta + ' ms hole between AAC samples detected,filling it');\n                                if (numMissingFrames > 0) {\n                                    fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                                    if (!fillFrame) {\n                                        fillFrame = unit.subarray();\n                                    }\n\n                                    track.len += numMissingFrames * fillFrame.length;\n                                }\n                                // if we have frame overlap, overlapping for more than half a frame duraion\n                            } else if (_delta < -12) {\n                                // drop overlapping audio frames... browser will deal with it\n                                _log.Log.v('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');\n                                track.len -= unit.byteLength;\n                                continue;\n                            }\n                            // set PTS/DTS to expected PTS/DTS\n                            _pts = nextAudioPts;\n                        }\n                    }\n                    // remember first PTS of our audioSamples\n                    firstPTS = _pts;\n                    if (track.len > 0) {\n                        /* concatenate the audio data and construct the mdat in place\n                        (need 8 more bytes to fill length and mdat type) */\n                        var mdatSize = rawMPEG ? track.len : track.len + 8;\n                        offset = rawMPEG ? 0 : 8;\n                        try {\n                            mdat = new Uint8Array(mdatSize);\n                        } catch (err) {\n                            this.observer.trigger(_kernelEvents2.default.ERROR, {\n                                type: _kernelErrors.ErrorTypes.MUX_ERROR,\n                                details: _kernelErrors.ErrorDetails.REMUX_ALLOC_ERROR,\n                                fatal: false,\n                                bytes: mdatSize,\n                                reason: 'fail allocating audio mdat ' + mdatSize\n                            });\n                            return;\n                        }\n                        if (!rawMPEG) {\n                            var view = new DataView(mdat.buffer);\n                            view.setUint32(0, mdatSize);\n                            mdat.set(_mp4Generator2.default.types.mdat, 4);\n                        }\n                    } else {\n                        // no audio samples\n                        return;\n                    }\n                    for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {\n                        fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                        if (!fillFrame) {\n                            _log.Log.v('Unable to get silent frame for given audio codec; duplicating this frame instead.');\n                            fillFrame = unit.subarray();\n                        }\n                        mdat.set(fillFrame, offset);\n                        offset += fillFrame.byteLength;\n                        mp4Sample = {\n                            size: fillFrame.byteLength,\n                            cts: 0,\n                            duration: 1024,\n                            flags: {\n                                isLeading: 0,\n                                isDependedOn: 0,\n                                hasRedundancy: 0,\n                                degradPrio: 0,\n                                dependsOn: 1\n                            }\n                        };\n                        outputSamples.push(mp4Sample);\n                    }\n                }\n                mdat.set(unit, offset);\n                var unitLen = unit.byteLength;\n                offset += unitLen;\n                // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');\n                mp4Sample = {\n                    size: unitLen,\n                    cts: 0,\n                    duration: 0,\n                    flags: {\n                        isLeading: 0,\n                        isDependedOn: 0,\n                        hasRedundancy: 0,\n                        degradPrio: 0,\n                        dependsOn: 1\n                    }\n                };\n                outputSamples.push(mp4Sample);\n                lastPTS = _pts;\n            }\n            var lastSampleDuration = 0;\n            var nbSamples = outputSamples.length;\n            // set last sample duration as being identical to previous sample\n            if (nbSamples >= 2) {\n                lastSampleDuration = outputSamples[nbSamples - 2].duration;\n                mp4Sample.duration = lastSampleDuration;\n            }\n            if (nbSamples) {\n                // next audio sample PTS should be equal to last sample PTS + duration\n                // TEST:\n                // this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;\n                this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * (lastSampleDuration || mp4SampleDuration);\n                // Log.v('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));\n                track.len = 0;\n                track.samples = outputSamples;\n                if (rawMPEG) {\n                    moof = new Uint8Array();\n                } else {\n                    moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);\n                }\n\n                track.samples = [];\n                var start = firstPTS / inputTimeScale;\n                var end = nextAudioPts / inputTimeScale;\n                var audioData = {\n                    data1: moof,\n                    data2: mdat,\n                    startPTS: start,\n                    endPTS: end,\n                    startDTS: start,\n                    endDTS: end,\n                    type: 'audio',\n                    hasAudio: true,\n                    hasVideo: false,\n                    nb: nbSamples,\n                    streamDTS: streamDTS,\n                    endStreamDts: end - start + streamDTS\n                };\n                this.observer.trigger(_kernelEvents2.default.PARSING_DATA, audioData);\n                return audioData;\n            }\n            return null;\n        }\n    }, {\n        key: 'remuxEmptyAudio',\n        value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n            var inputTimeScale = track.inputTimeScale,\n                mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,\n                scaleFactor = inputTimeScale / mp4timeScale,\n                nextAudioPts = this.nextAudioPts,\n\n            // sync with video's timestamp\n            startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,\n                endDTS = videoData.endDTS * inputTimeScale + this._initDTS,\n\n            // one sample's duration value\n            sampleDuration = 1024,\n                frameDuration = scaleFactor * sampleDuration,\n\n            // samples count of this segment's duration\n            nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),\n\n            // silent frame\n            silentFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n            _log.Log.w('remux empty Audio');\n            // Can't remux if we can't generate a silent frame...\n            if (!silentFrame) {\n                _log.Log.d('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');\n                return;\n            }\n\n            var samples = [];\n            for (var i = 0; i < nbSamples; i++) {\n                var stamp = startDTS + i * frameDuration;\n                samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n                track.len += silentFrame.length;\n            }\n            track.samples = samples;\n\n            this.remuxAudio(track, timeOffset, contiguous);\n        }\n    }, {\n        key: '_PTSNormalize',\n        value: function _PTSNormalize(value, reference) {\n            var offset = void 0;\n            if (reference === undefined) {\n                return value;\n            }\n\n            if (reference < value) {\n                // - 2^33\n                offset = -8589934592;\n            } else {\n                // + 2^33\n                offset = 8589934592;\n            }\n            /* PTS is 33bit (from 0 to 2^33 -1)\n            if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n            PTS looping occured. fill the gap */\n            while (Math.abs(value - reference) > 4294967296) {\n                value += offset;\n            }\n\n            return value;\n        }\n    }, {\n        key: '_resetVideoTime',\n        value: function _resetVideoTime() {\n            this._videoTime = { nbSamples: 0, firstDTS: 0, sampleDuration: 3000 };\n        }\n    }]);\n\n    return MP4Remuxer;\n}();\n\nexports.default = MP4Remuxer;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/remux/mp4-remuxer.js?")},"./src/utils/attr-list.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/; // eslint-disable-line no-useless-escape\nvar ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n\nvar AttrList = function () {\n    function AttrList(attrs) {\n        _classCallCheck(this, AttrList);\n\n        if (typeof attrs === 'string') {\n            attrs = AttrList.parseAttrList(attrs);\n        }\n\n        for (var attr in attrs) {\n            if (attrs.hasOwnProperty(attr)) {\n                this[attr] = attrs[attr];\n            }\n        }\n    }\n\n    _createClass(AttrList, [{\n        key: 'decimalInteger',\n        value: function decimalInteger(attrName) {\n            var intValue = parseInt(this[attrName], 10);\n            if (intValue > Number.MAX_SAFE_INTEGER) {\n                return Infinity;\n            }\n\n            return intValue;\n        }\n    }, {\n        key: 'hexadecimalInteger',\n        value: function hexadecimalInteger(attrName) {\n            if (this[attrName]) {\n                var stringValue = (this[attrName] || '0x').slice(2);\n                stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n\n                var value = new Uint8Array(stringValue.length / 2);\n                for (var i = 0; i < stringValue.length / 2; i++) {\n                    value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n                }\n\n                return value;\n            }\n            return null;\n        }\n    }, {\n        key: 'hexadecimalIntegerAsNumber',\n        value: function hexadecimalIntegerAsNumber(attrName) {\n            var intValue = parseInt(this[attrName], 16);\n            if (intValue > Number.MAX_SAFE_INTEGER) {\n                return Infinity;\n            }\n\n            return intValue;\n        }\n    }, {\n        key: 'decimalFloatingPoint',\n        value: function decimalFloatingPoint(attrName) {\n            return parseFloat(this[attrName]);\n        }\n    }, {\n        key: 'enumeratedString',\n        value: function enumeratedString(attrName) {\n            return this[attrName];\n        }\n    }, {\n        key: 'decimalResolution',\n        value: function decimalResolution(attrName) {\n            var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n            if (res === null) {\n                return null;\n            }\n\n            return {\n                width: parseInt(res[1], 10),\n                height: parseInt(res[2], 10)\n            };\n        }\n    }], [{\n        key: 'parseAttrList',\n        value: function parseAttrList(input) {\n            var match = void 0;\n            var attrs = {};\n            ATTR_LIST_REGEX.lastIndex = 0;\n            while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n                var value = match[2];\n                var quote = '\"';\n\n                if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n                    value = value.slice(1, -1);\n                }\n\n                attrs[match[1]] = value;\n            }\n            return attrs;\n        }\n    }]);\n\n    return AttrList;\n}();\n\nexports.default = AttrList;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/attr-list.js?")},"./src/utils/browser.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nvar Browser = {};\n\nfunction detect() {\n    // modified from jquery-browser-plugin\n\n    var ua = self.navigator.userAgent.toLowerCase();\n\n    var match = /(edge)\\/([\\w.]+)/.exec(ua) || /(opr)[\\/]([\\w.]+)/.exec(ua) || /(chrome)[ \\/]([\\w.]+)/.exec(ua) || /(iemobile)[\\/]([\\w.]+)/.exec(ua) || /(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) || /(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) || /(webkit)[ \\/]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || ua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua) || ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) || [];\n\n    var platform_match = /(ipad)/.exec(ua) || /(ipod)/.exec(ua) || /(windows phone)/.exec(ua) || /(iphone)/.exec(ua) || /(kindle)/.exec(ua) || /(android)/.exec(ua) || /(windows)/.exec(ua) || /(mac)/.exec(ua) || /(linux)/.exec(ua) || /(cros)/.exec(ua) || [];\n\n    var matched = {\n        browser: match[5] || match[3] || match[1] || '',\n        version: match[2] || match[4] || '0',\n        majorVersion: match[4] || match[2] || '0',\n        platform: platform_match[0] || ''\n    };\n\n    var browser = {};\n    if (matched.browser) {\n        browser[matched.browser] = true;\n\n        var versionArray = matched.majorVersion.split('.');\n        browser.version = {\n            major: parseInt(matched.majorVersion, 10),\n            string: matched.version\n        };\n        if (versionArray.length > 1) {\n            browser.version.minor = parseInt(versionArray[1], 10);\n        }\n        if (versionArray.length > 2) {\n            browser.version.build = parseInt(versionArray[2], 10);\n        }\n    }\n\n    if (matched.platform) {\n        browser[matched.platform] = true;\n    }\n\n    if (browser.chrome || browser.opr || browser.safari) {\n        browser.webkit = true;\n    }\n\n    // MSIE. IE11 has 'rv' identifer\n    if (browser.rv || browser.iemobile) {\n        if (browser.rv) {\n            delete browser.rv;\n        }\n        var msie = 'msie';\n        matched.browser = msie;\n        browser[msie] = true;\n    }\n\n    // Microsoft Edge\n    if (browser.edge) {\n        delete browser.edge;\n        var msedge = 'msedge';\n        matched.browser = msedge;\n        browser[msedge] = true;\n    }\n\n    // Opera 15+\n    if (browser.opr) {\n        var opera = 'opera';\n        matched.browser = opera;\n        browser[opera] = true;\n    }\n\n    // Stock android browsers are marked as Safari\n    if (browser.safari && browser.android) {\n        var android = 'android';\n        matched.browser = android;\n        browser[android] = true;\n    }\n\n    browser.name = matched.browser;\n    browser.platform = matched.platform;\n\n    for (var key in Browser) {\n        if (Browser.hasOwnProperty(key)) {\n            delete Browser[key];\n        }\n    }\n    Browser = browser;\n    // Object.assign(Browser, browser);\n}\n\ndetect();\n\nexports.default = Browser;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/browser.js?")},"./src/utils/codecs.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// from http://mp4ra.org/codecs.html\nvar sampleEntryCodesISO = {\n    audio: {\n        'a3ds': true,\n        'ac-3': true,\n        'ac-4': true,\n        'alac': true,\n        'alaw': true,\n        'dra1': true,\n        'dts+': true,\n        'dts-': true,\n        'dtsc': true,\n        'dtse': true,\n        'dtsh': true,\n        'ec-3': true,\n        'enca': true,\n        'g719': true,\n        'g726': true,\n        'm4ae': true,\n        'mha1': true,\n        'mha2': true,\n        'mhm1': true,\n        'mhm2': true,\n        'mlpa': true,\n        'mp4a': true,\n        'raw ': true,\n        'Opus': true,\n        'samr': true,\n        'sawb': true,\n        'sawp': true,\n        'sevc': true,\n        'sqcp': true,\n        'ssmv': true,\n        'twos': true,\n        'ulaw': true\n    },\n    video: {\n        'avc1': true,\n        'avc2': true,\n        'avc3': true,\n        'avc4': true,\n        'avcp': true,\n        'drac': true,\n        'dvav': true,\n        'dvhe': true,\n        'encv': true,\n        'hev1': true,\n        'hvc1': true,\n        'mjp2': true,\n        'mp4v': true,\n        'mvc1': true,\n        'mvc2': true,\n        'mvc3': true,\n        'mvc4': true,\n        'resv': true,\n        'rv60': true,\n        's263': true,\n        'svc1': true,\n        'svc2': true,\n        'vc-1': true,\n        'vp08': true,\n        'vp09': true\n    }\n};\n\nfunction isCodecType(codec, type) {\n    var typeCodes = sampleEntryCodesISO[type];\n    return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\n\nfunction isCodecSupportedInMp4(codec, type) {\n    return window.MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs=\"' + codec + '\"');\n}\n\nexports.isCodecType = isCodecType;\nexports.isCodecSupportedInMp4 = isCodecSupportedInMp4;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/codecs.js?")},"./src/utils/decodeUTF8.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/* eslint-disable */\nfunction decodeUTF8(uint8array) {\n    var out = [];\n    var input = uint8array;\n    var i = 0;\n    var length = uint8array.length;\n\n    while (i < length) {\n        if (input[i] < 0x80) {\n            out.push(String.fromCharCode(input[i]));\n            ++i;\n            continue;\n        } else if (input[i] < 0xC0) {\n            // fallthrough\n        } else if (input[i] < 0xE0) {\n            if (checkContinuation(input, i, 1)) {\n                var ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n                if (ucs4 >= 0x80) {\n                    out.push(String.fromCharCode(ucs4 & 0xFFFF));\n                    i += 2;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF0) {\n            if (checkContinuation(input, i, 2)) {\n                var _ucs = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n                if (_ucs >= 0x800 && (_ucs & 0xF800) !== 0xD800) {\n                    out.push(String.fromCharCode(_ucs & 0xFFFF));\n                    i += 3;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xF8) {\n            if (checkContinuation(input, i, 3)) {\n                var _ucs2 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n                if (_ucs2 > 0x10000 && _ucs2 < 0x110000) {\n                    _ucs2 -= 0x10000;\n                    out.push(String.fromCharCode(_ucs2 >>> 10 | 0xD800));\n                    out.push(String.fromCharCode(_ucs2 & 0x3FF | 0xDC00));\n                    i += 4;\n                    continue;\n                }\n            }\n        }\n        out.push(String.fromCharCode(0xFFFD));\n        ++i;\n    }\n\n    return out.join('');\n}\n\nfunction checkContinuation(uint8array, start, checkLength) {\n    var array = uint8array;\n    if (start + checkLength < array.length) {\n        while (checkLength--) {\n            if ((array[++start] & 0xC0) !== 0x80) return false;\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\nexports.default = decodeUTF8;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/decodeUTF8.js?")},"./src/utils/fps.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(/*! events */ "./node_modules/events/events.js");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */\n\nvar _window = window,\n    performance = _window.performance;\n\nvar FPS = function (_Events) {\n    _inherits(FPS, _Events);\n\n    function FPS() {\n        _classCallCheck(this, FPS);\n\n        var _this = _possibleConstructorReturn(this, (FPS.__proto__ || Object.getPrototypeOf(FPS)).call(this));\n\n        _this.tag = \'fps\';\n        _this.lastDroppedFrames = 0;\n        _this.lastDecodedFrames = 0;\n        return _this;\n    }\n\n    _createClass(FPS, [{\n        key: \'attachMedia\',\n        value: function attachMedia(media) {\n            var video = this.video = media instanceof window.HTMLVideoElement ? media : null;\n            if (typeof video.getVideoPlaybackQuality === \'function\') {\n                this.isVideoPlaybackQualityAvailable = true;\n            }\n        }\n    }, {\n        key: \'checkFPS\',\n        value: function checkFPS(video, decodedFrames, droppedFrames) {\n            var currentTime = performance.now();\n            var info = null;\n            if (decodedFrames) {\n                if (this.lastTime) {\n                    var currentPeriod = currentTime - this.lastTime,\n                        currentDropped = droppedFrames - this.lastDroppedFrames,\n                        currentDecoded = decodedFrames - this.lastDecodedFrames,\n                        droppedFPS = (1000 * currentDropped / currentPeriod).toFixed(2),\n                        decodedFPS = (1000 * currentDecoded / currentPeriod).toFixed(2);\n\n                    this.lastTime = currentTime;\n                    this.lastDroppedFrames = droppedFrames;\n                    this.lastDecodedFrames = decodedFrames;\n\n                    info = {\n                        droppedFrames: droppedFrames,\n                        decodedFrames: decodedFrames,\n                        decodedFPS: decodedFPS,\n                        droppedFPS: droppedFPS\n                    };\n                    this.lastDroppedFrames = droppedFrames;\n                    this.lastDecodedFrames = decodedFrames;\n                }\n\n                this.lastTime = currentTime;\n            }\n            return info;\n        }\n    }, {\n        key: \'checkFPSInterval\',\n        value: function checkFPSInterval() {\n            var video = this.video;\n            if (video) {\n                if (this.isVideoPlaybackQualityAvailable) {\n                    var videoPlaybackQuality = video.getVideoPlaybackQuality();\n                    return this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n                }\n                return this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n            }\n            return null;\n        }\n    }]);\n\n    return FPS;\n}(_events2.default);\n\nexports.default = FPS;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/fps.js?')},"./src/utils/live-realtime-beacon.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _urlParse = __webpack_require__(/*! url-parse */ \"./node_modules/url-parse/index.js\");\n\nvar _urlParse2 = _interopRequireDefault(_urlParse);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FlvRealtimeBeaconBuilder = function () {\n    function FlvRealtimeBeaconBuilder(src) {\n        _classCallCheck(this, FlvRealtimeBeaconBuilder);\n\n        this._resetForNewSession(src);\n        this._resetForNewInterval();\n    }\n\n    _createClass(FlvRealtimeBeaconBuilder, [{\n        key: '_resetForNewSession',\n        value: function _resetForNewSession(src) {\n            this.currentPlaybackSpeed = 1.0;\n            this.lastDownloadedBytes = 0.0;\n            if (src) {\n                this.playUrl = src;\n                this.domain = new _urlParse2.default(src).host;\n            }\n            this.playStartTimestampMillis = Date.now();\n            this.lastVideoBuffered = { start: -1e9, end: -1e9 };\n            this.playbackSpeed = 1;\n        }\n    }, {\n        key: '_resetForNewInterval',\n        value: function _resetForNewInterval() {\n            this.currentPlaybackSpeedTimestamp = Date.now();\n            this.playbackSpeedStat = {};\n            this.statTimestampMillis = Date.now();\n            this.bufferingCount = 0;\n            this.bufferingDurationMillis = 0;\n            // null indicates not buffering, non-null indicates buffering\n            this.bufferingStartTimestampMillis = this.bufferingStartTimestampMillis ? Date.now() : null;\n            this.downloadedBytes = 0;\n            this.audioBufferedMillis = 0;\n            this.videoBufferedMillis = 0;\n            this.demuxedDurationSec = 0;\n            this.excessiveDataDroppedSec = 0;\n            // block时缓冲区仍然有数据的情况\n            this.blockCountWithBuffer = 0;\n            this.bufferDuringBlockSum = 0;\n\n            this.cdnDropFrameCount = 0;\n            this.cdnDropFrameDuration = 0;\n        }\n    }, {\n        key: '_recordSpeedStat',\n        value: function _recordSpeedStat() {\n            if (this.playbackSpeed !== 1) {\n                var now = Date.now();\n                var accumulatedMs = now - this.currentPlaybackSpeedTimestamp;\n                var speedKey = this.playbackSpeed + 'x';\n                if (this.playbackSpeedStat[speedKey]) {\n                    this.playbackSpeedStat[speedKey] += accumulatedMs;\n                } else {\n                    this.playbackSpeedStat[speedKey] = accumulatedMs;\n                }\n            }\n        }\n    }, {\n        key: 'videoBufferedUpdated',\n        value: function videoBufferedUpdated(buffered) {\n            if (buffered.length === 0) {\n                return;\n            }\n            var start = buffered.start(buffered.length - 1);\n            var end = buffered.end(buffered.length - 1);\n            if (start > this.lastVideoBuffered.end + 1e-3) {\n                this.demuxedDurationSec += end - start;\n                this.lastVideoBuffered = { start: start, end: end };\n            } else {\n                this.demuxedDurationSec += Math.max(0, end - this.lastVideoBuffered.end);\n                this.lastVideoBuffered.end = end;\n            }\n        }\n    }, {\n        key: 'playbackSpeedChanged',\n        value: function playbackSpeedChanged(newSpeed) {\n            if (newSpeed !== this.playbackSpeed) {\n                this._recordSpeedStat();\n                this.currentPlaybackSpeedTimestamp = Date.now();\n                this.playbackSpeed = newSpeed;\n            }\n        }\n    }, {\n        key: 'bufferingStarted',\n        value: function bufferingStarted(bufferedLength) {\n            var BUFFERED_THRESHOLD = 600;\n            ++this.bufferingCount;\n            this.bufferingStartTimestampMillis = Date.now();\n\n            // 卡时缓冲区>300ms数量\n            if (bufferedLength > BUFFERED_THRESHOLD) {\n                this.bufferDuringBlockSum += bufferedLength;\n                this.blockCountWithBuffer++;\n            }\n        }\n    }, {\n        key: 'bufferingEnded',\n        value: function bufferingEnded() {\n            var now = Date.now();\n            if (this.bufferingStartTimestampMillis != null) {\n                // If this.bufferingStartTimestampMillis is null or undefined\n                // Do not accumulated buffering duration\n                this.bufferingDurationMillis += now - this.bufferingStartTimestampMillis;\n            }\n            this.bufferingStartTimestampMillis = null;\n        }\n    }, {\n        key: 'updateDownloadedBytes',\n        value: function updateDownloadedBytes(newDownloadedBytes) {\n            var newlyDownloaded = newDownloadedBytes - this.lastDownloadedBytes;\n            this.downloadedBytes += newlyDownloaded;\n            this.lastDownloadedBytes = newDownloadedBytes;\n        }\n    }, {\n        key: 'setAudioBufferedSec',\n        value: function setAudioBufferedSec(audioBufferedSec) {\n            this.audioBufferedMillis = Math.round(audioBufferedSec * 1000);\n        }\n    }, {\n        key: 'setVideoBufferedSec',\n        value: function setVideoBufferedSec(videoBufferedSec) {\n            this.videoBufferedMillis = Math.round(videoBufferedSec * 1000);\n        }\n    }, {\n        key: 'excessiveDataDropped',\n        value: function excessiveDataDropped(droppedSec) {\n            this.excessiveDataDroppedSec += droppedSec;\n        }\n    }, {\n        key: 'lostFrame',\n        value: function lostFrame(dropMillis) {\n            this.cdnDropFrameCount += 1;\n            this.cdnDropFrameDuration += dropMillis;\n        }\n    }, {\n        key: 'setPlayUrl',\n        value: function setPlayUrl(src) {\n            this.playUrl = src;\n            this.domain = new _urlParse2.default(src).host;\n        }\n    }, {\n        key: 'buildAndStartNewInterval',\n        value: function buildAndStartNewInterval() {\n            this._recordSpeedStat();\n            var now = Date.now();\n            var ongoingBufferingDuration = this.bufferingStartTimestampMillis == null ? 0 : now - this.bufferingStartTimestampMillis;\n            var ongoingBufferingCount = this.bufferingStartTimestampMillis == null ? 0 : 1;\n            var ret = {\n                play_url: this.playUrl,\n                domain: this.domain,\n                play_start_time: this.playStartTimestampMillis,\n                tick_start: this.statTimestampMillis,\n                tick_duration: now - this.statTimestampMillis,\n                block_count: this.bufferingCount,\n                buffer_time: this.bufferingDurationMillis + ongoingBufferingDuration,\n                kbytes_received: this.downloadedBytes >> 10,\n                played_video_duration: now - this.statTimestampMillis - (this.bufferingDurationMillis + ongoingBufferingDuration),\n                demuxed_video_duration: Math.round(this.demuxedDurationSec * 1000),\n                dropped_packet_duration: Math.round(this.excessiveDataDroppedSec * 1000),\n                a_buf_len: this.audioBufferedMillis,\n                v_buf_len: this.videoBufferedMillis,\n                speed_chg_metric: this.playbackSpeedStat,\n                block_count_with_buffer: this.blockCountWithBuffer,\n                buffer_during_block: this.blockCountWithBuffer > 0 ? Math.round(this.bufferDuringBlockSum / this.blockCountWithBuffer) : 0,\n                skip_cnt: this.cdnDropFrameCount, // 跳帧总次数\n                skip_duration: this.cdnDropFrameDuration // 跳帧总时长(毫秒)\n            };\n            this._resetForNewInterval();\n            return ret;\n        }\n    }]);\n\n    return FlvRealtimeBeaconBuilder;\n}();\n\nexports.default = FlvRealtimeBeaconBuilder;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/live-realtime-beacon.js?")},"./src/utils/log.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar GLOBAL_TAG = 'kwai-k';\nvar FORCE_GLOBAL_TAG = true;\n\n/**\n * 处理log参数\n * @param {string=} tag tag\n * @param {Array=} msg messages\n * @returns {Array} msg\n */\nfunction formatter(tag, msg) {\n    if (!msg || msg.length === 0) {\n        msg = [tag];\n        tag = '';\n    }\n    tag = FORCE_GLOBAL_TAG ? GLOBAL_TAG + (tag ? '::' + tag : '') : tag || GLOBAL_TAG;\n    msg.unshift('[' + tag + '] > ');\n    return msg;\n}\n\nvar LOG_LEVEL = {\n    LEVEL_ERROR: 'e', // 日志等级-error，只输出error日志\n    LEVEL_WARN: 'w', // 日志等级-warn，输出error，warn日志\n    LEVEL_INFO: 'i', // 日志等级-info，输出error, warn, info日志\n    LEVEL_DEBUG: 'd', // 日志等级-debug，输出error, warn, info, debug日志\n    LEVEL_VERBOSE: 'v' // 日志等级-verbose，输出error, warn, info, debug, verbose日志\n};\n\n/**\n * console日志\n * @class\n */\n\nvar Log = function () {\n    function Log() {\n        _classCallCheck(this, Log);\n    }\n\n    _createClass(Log, null, [{\n        key: 'level',\n\n        /**\n         * 设置日志输出等级\n         * @param {string} l 日志输出等级 e|w|i|d|v\n         */\n        value: function level(l) {\n            Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = Log.ENABLE_VERBOSE = false;\n            switch (l) {\n                case LOG_LEVEL.LEVEL_ERROR:\n                    Log.ENABLE_ERROR = true;\n                    break;\n                case LOG_LEVEL.LEVEL_WARN:\n                    Log.ENABLE_ERROR = Log.ENABLE_WARN = true;\n                    break;\n                case LOG_LEVEL.LEVEL_INFO:\n                    Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = true;\n                    break;\n                case LOG_LEVEL.LEVEL_DEBUG:\n                    Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = true;\n                    break;\n                case LOG_LEVEL.LEVEL_VERBOSE:\n                    Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = Log.ENABLE_VERBOSE = true;\n                    break;\n            }\n        }\n\n        /**\n         * error日志\n         * @param {string=} tag 日志tag\n         * @param {*=} msg 日志信息，不定长\n         */\n\n    }, {\n        key: 'e',\n        value: function e(tag) {\n            if (!Log.ENABLE_ERROR) {\n                return;\n            }\n\n            for (var _len = arguments.length, msg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                msg[_key - 1] = arguments[_key];\n            }\n\n            (console.error || console.warn || console.log).apply(console, formatter(tag, msg));\n        }\n\n        /**\n         * warn日志\n         * @param {string=} tag 日志tag\n         * @param {*=} msg 日志信息，不定长\n         */\n\n    }, {\n        key: 'w',\n        value: function w(tag) {\n            if (!Log.ENABLE_WARN) {\n                return;\n            }\n\n            for (var _len2 = arguments.length, msg = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                msg[_key2 - 1] = arguments[_key2];\n            }\n\n            (console.warn || console.log).apply(console, formatter(tag, msg));\n        }\n\n        /**\n         * info日志\n         * @param {string=} tag 日志tag\n         * @param {*=} msg 日志信息，不定长\n         */\n\n    }, {\n        key: 'i',\n        value: function i(tag) {\n            if (!Log.ENABLE_INFO) {\n                return;\n            }\n\n            for (var _len3 = arguments.length, msg = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                msg[_key3 - 1] = arguments[_key3];\n            }\n\n            (console.info || console.log).apply(console, formatter(tag, msg));\n        }\n\n        /**\n         * debug日志\n         * @param {string=} tag 日志tag\n         * @param {*=} msg 日志信息，不定长\n         */\n\n    }, {\n        key: 'd',\n        value: function d(tag) {\n            if (!Log.ENABLE_DEBUG) {\n                return;\n            }\n\n            for (var _len4 = arguments.length, msg = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                msg[_key4 - 1] = arguments[_key4];\n            }\n\n            (console.debug || console.log).apply(console, formatter(tag, msg));\n        }\n\n        /**\n         * verbose日志\n         * @param {string=} tag 日志tag\n         * @param {*=} msg 日志信息，不定长\n         */\n\n    }, {\n        key: 'v',\n        value: function v(tag) {\n            if (!Log.ENABLE_VERBOSE) {\n                return;\n            }\n\n            for (var _len5 = arguments.length, msg = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                msg[_key5 - 1] = arguments[_key5];\n            }\n\n            console.log.apply(console, formatter(tag, msg));\n        }\n    }]);\n\n    return Log;\n}();\n\nLog.ENABLE_ERROR = true;\nLog.ENABLE_WARN = false;\nLog.ENABLE_INFO = false;\nLog.ENABLE_DEBUG = false;\nLog.ENABLE_VERBOSE = false;\n\nexports.Log = Log;\nexports.LOG_LEVEL = LOG_LEVEL;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/log.js?")},"./src/utils/playback-rate-manager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n// 播放速度\nvar PLAYBACK_RATE_DOWN1 = 0.9;\nvar PLAYBACK_RATE_NORMAL = 1;\nvar PLAYBACK_RATE_UP1 = 1.1;\nvar PLAYBACK_RATE_UP2 = 1.2;\n\n/**\n * 播放速度控制\n */\n\nvar PlaybackRateManager = function () {\n    function PlaybackRateManager() {\n        _classCallCheck(this, PlaybackRateManager);\n\n        // 速度控制规则，按playbackRate倒序\n        this._rules = [{ playbackRate: PLAYBACK_RATE_UP2, lower: 28, upper: Number.MAX_SAFE_INTEGER }, { playbackRate: PLAYBACK_RATE_UP1, lower: 16, upper: 22 }, { playbackRate: PLAYBACK_RATE_NORMAL, lower: 5, upper: 10 }, { playbackRate: PLAYBACK_RATE_DOWN1, lower: Number.MIN_SAFE_INTEGER, upper: 3 }];\n    }\n\n    /**\n     * 获取当前的播放速度\n     * @param {number} buffered 当前待播放的buffer长度，秒\n     * @param {number} currentPlaybackRate 当前的播放速度\n     * @returns {number} 播放速度\n     * @memberof PlaybackRateManager\n     */\n\n\n    _createClass(PlaybackRateManager, [{\n        key: "nextPlayBackRate",\n        value: function nextPlayBackRate(buffered, currentPlaybackRate) {\n            var playbackRate = PLAYBACK_RATE_NORMAL;\n\n            var i = 0;\n            for (i = 0; i < this._rules.length; i++) {\n                if (currentPlaybackRate >= this._rules[i].playbackRate) {\n                    break;\n                }\n            }\n\n            var downRule = i < this._rules.length - 1 ? this._rules[i + 1] : null;\n            var upRule = i > 0 ? this._rules[i - 1] : null;\n\n            playbackRate = this._rules[i].playbackRate;\n\n            if (upRule && buffered > upRule.lower) {\n                playbackRate = upRule.playbackRate;\n            }\n\n            if (downRule && buffered < downRule.upper) {\n                playbackRate = downRule.playbackRate;\n            }\n            return playbackRate;\n        }\n    }]);\n\n    return PlaybackRateManager;\n}();\n\nexports.default = PlaybackRateManager;\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/playback-rate-manager.js?')},"./src/utils/polyfill.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/* eslint-disable */\nif (!ArrayBuffer.transfer) {\n    ArrayBuffer.transfer = function (source, length) {\n        source = Object(source);\n        var dest = new ArrayBuffer(length);\n        if (!(source instanceof ArrayBuffer) || !(dest instanceof ArrayBuffer)) {\n            throw new TypeError('Source and destination must be ArrayBuffer instances');\n        }\n        if (dest.byteLength >= source.byteLength) {\n            var nextOffset = 0;\n            var leftBytes = source.byteLength;\n            var wordSizes = [8, 4, 2, 1];\n            wordSizes.forEach(function (_wordSize_) {\n                if (leftBytes >= _wordSize_) {\n                    var done = transferWith(_wordSize_, source, dest, nextOffset, leftBytes);\n                    nextOffset = done.nextOffset;\n                    leftBytes = done.leftBytes;\n                }\n            });\n        }\n        return dest;\n        function transferWith(wordSize, source, dest, nextOffset, leftBytes) {\n            var ViewClass = Uint8Array;\n            switch (wordSize) {\n                case 8:\n                    ViewClass = Float64Array;\n                    break;\n                case 4:\n                    ViewClass = Float32Array;\n                    break;\n                case 2:\n                    ViewClass = Uint16Array;\n                    break;\n                case 1:\n                    ViewClass = Uint8Array;\n                    break;\n                default:\n                    ViewClass = Uint8Array;\n                    break;\n            }\n            var view_source = new ViewClass(source, nextOffset, Math.trunc(leftBytes / wordSize));\n            var view_dest = new ViewClass(dest, nextOffset, Math.trunc(leftBytes / wordSize));\n            for (var i = 0; i < view_dest.length; i++) {\n                view_dest[i] = view_source[i];\n            }\n            return {\n                nextOffset: view_source.byteOffset + view_source.byteLength,\n                leftBytes: source.byteLength - (view_source.byteOffset + view_source.byteLength)\n            };\n        }\n    };\n}\n\n//# sourceURL=webpack://KwaiPlayerKernel/./src/utils/polyfill.js?")},0:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");\n\n\n//# sourceURL=webpack://KwaiPlayerKernel/multi_./src/index.js?')}}).default},module.exports=factory()},379:function(e,n,t){"use strict";t.r(n);var r,a,s=t(217),i=t.n(s),o=t(91),l=(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])},function(e,n){function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});!function(e){e.LEVEL_SWITCHED="levelSwitched",e.ERROR="error",e.MAINFEST_PARSED="manifestParsed"}(a||(a={}));var u=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return l(n,e),Object.defineProperty(n.prototype,"currentLevel",{get:function(){return this.findBitrateIndex(this._currentLevel)},set:function(e){this._currentLevel=this.findBitrateIndex(e),this._kernel.selectBitrate(e),this.onSwitching()},enumerable:!0,configurable:!0}),n.prototype.load=function(e,n){this._kernel=new i.a(this._media,{src:e,credentials:!1,bitrateStart:0,webWorker:!0,box:"hls",isLive:!1,lazyLoadMaxDuration:30}),this.addListeners(),this._kernel.load()},n.prototype.attachMedia=function(e){this._media=e},n.prototype.destroy=function(){this._kernel.destroy()},n.prototype.findBitrateIndex=function(e){return this._levels.findIndex(function(n){return e===n})},n.prototype.addListeners=function(){var e=this;this._kernel.on(a.LEVEL_SWITCHED,function(n){e.onSwitched()}),this._kernel.on(a.ERROR,function(n){e._observer.emit(o.c.KERNEL_ERROR,n)}),this._kernel.on(a.MAINFEST_PARSED,function(n){e.setupBitrate()})},n.prototype.setupBitrate=function(){this._levels=this._kernel.getBitrates(),e.prototype.setupBitrate.call(this)},n}(o.d);n.default=u}}]);