<html>
 <head> 
  <title>Typescriptor</title> 
  <meta charset="utf-8" /> 
  <link rel="stylesheet" href="./css/effect.css" /> 
 </head> 
 <body class="text-center"> 
  <div id="page"> 
   <header> 
    <nav> 
     <a href="#1">首页</a> 
     <a href="#2">DEMO</a> 
     <a href="#3">分享大纲</a> 
     <a href="#4">技能</a> 
     <a href="#5">技能</a> 
    </nav> 
   </header> 
   <main> 
    <section id="#2"> 
     <h2>DEMO</h2> 
     <iframe src="./player.html"></iframe> 
    </section> 
    <section id="#3"> 
     <h2>分享大纲</h2> 
     <iframe src="./player.html"></iframe> 
    </section> 
    <section id="#4"> 
     <h2>技能</h2> 
     <iframe src="./player.html"></iframe> 
    </section> 
    <section id="#5"> 
     <h2>联系方式</h2> 
     <iframe src="./player.html"></iframe> 
    </section> 
   </main> 
   <footer> 
   </footer> 
  </div> 
  <canvas id="reveal-effect"></canvas> 
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/100/three.min.js"></script> 
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.2/TweenMax.min.js"></script> 
  <script type="text/javascript">
		var renderer, scene, camera, cameraCtrl;
		var width, height, cx, cy, wWidth, wHeight;
		var TMath = THREE.Math;

		var conf = {
		  color: 0xffffff,
		  objectWidth: 12,
		  objectThickness: 3,
		  ambientColor: 0x808080,
		  light1Color: 0xffffff,
		  shadow: false,
		  perspective: 75,
		  cameraZ: 75,
		};

		var objects = [];
		var geometry, material;
		var hMap, hMap0, nx, ny;

		init();

		function init() {
		  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('reveal-effect'), antialias: true, alpha: true });
		  renderer.setSize(window.innerWidth, window.innerHeight);
		  document.body.appendChild(renderer.domElement);

		  camera = new THREE.PerspectiveCamera(conf.perspective, window.innerWidth / window.innerHeight, 0.1, 1000);
		  camera.position.z = conf.cameraZ;

		  scene = new THREE.Scene();
		  geometry = new THREE.BoxGeometry(conf.objectWidth, conf.objectWidth, conf.objectThickness);

		  window.addEventListener('load', initScene);
		  //document.getElementById('trigger').addEventListener('click', initScene);

		  animate();
		};

		function initScene() {
		  onResize();
		  scene = new THREE.Scene();
		  initLights();
		  initObjects();
		}

		function initLights() {
		  scene.add(new THREE.AmbientLight(conf.ambientColor));
		  var light = new THREE.PointLight(0xffffff);
		  light.position.z = 100;
		  scene.add(light);
		}

		function initObjects() {
		  objects = [];
		  nx = Math.round(wWidth / conf.objectWidth) + 1;
		  ny = Math.round(wHeight / conf.objectWidth) + 1;
		  var mesh, x, y;
		  for (var i = 0; i < nx; i++) {
		    for (var j = 0; j < ny; j++) {
		      material = new THREE.MeshLambertMaterial({ color: conf.color, transparent: true, opacity: 1 });
		      mesh = new THREE.Mesh(geometry, material);
		      x = -wWidth / 2 + i * conf.objectWidth;
		      y = -wHeight / 2 + j * conf.objectWidth;
		      mesh.position.set(x, y, 0);
		      objects.push(mesh);
		      scene.add(mesh);
		    }
		  }
		  document.body.classList.add('loaded');
		  startAnim();
		}

		function startAnim() {
		  document.body.classList.remove('revealed');
		  objects.forEach(mesh => {
		    mesh.rotation.set(0, 0, 0);
		    mesh.material.opacity = 1;
		    mesh.position.z = 0;
		    var delay = TMath.randFloat(1, 2);
		    var rx = TMath.randFloatSpread(2 * Math.PI);
		    var ry = TMath.randFloatSpread(2 * Math.PI);
		    var rz = TMath.randFloatSpread(2 * Math.PI);
		    TweenMax.to(mesh.rotation, 2, { x: rx, y: ry, z: rz, delay: delay });
		    TweenMax.to(mesh.position, 2, { z: 80, delay: delay + 0.5, ease: Power1.easeOut });
		    TweenMax.to(mesh.material, 2, { opacity: 0, delay: delay + 0.5 });
		  });
		  setTimeout(() => {
		    document.body.classList.add('revealed');
		  }, 4500);
		}

		function animate() {
		  requestAnimationFrame(animate);
		  renderer.render(scene, camera);
		};

		function onResize() {
		  width = window.innerWidth; cx = width / 2;
		  height = window.innerHeight; cy = height / 2;
		  camera.aspect = width / height;
		  camera.updateProjectionMatrix();
		  renderer.setSize(width, height);

		  size = getRendererSize();
		  wWidth = size[0];
		  wHeight = size[1];
		}

		function getRendererSize() {
		  var cam = new THREE.PerspectiveCamera(conf.perspective, camera.aspect);
		  var vFOV = cam.fov * Math.PI / 180;
		  var height = 2 * Math.tan(vFOV / 2) * Math.abs(conf.cameraZ);
		  var width = height * cam.aspect;
		  return [width, height];
		}

	</script>  
 </body>
</html>